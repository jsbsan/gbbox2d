' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' /* 

' */
dim  b2Island  as variant = Class.create()

b2Island.prototype = 
end

public  sub 	initialize(bodyCapacity as variant, contactCapacity as variant, jointCapacity as variant, allocator as variant)

dim 		 i  as variant = 0

		 me.m_bodyCapacity = bodyCapacity
		 me.m_contactCapacity = contactCapacity
		 me.m_jointCapacity	 = jointCapacity
		 me.m_bodyCount = 0
		 me.m_contactCount = 0
		 me.m_jointCount = 0
		' // me.m_bodies = (b2Body**)allocator->Allocate(bodyCapacity * sizeof(b2Body*))
		 me.m_bodies = new Array(bodyCapacity)
		for (i = 0; i < bodyCapacity; i++)
			 me.m_bodies[i] = null
		' // me.m_contacts = (b2Contact**)allocator->Allocate(contactCapacity	 * sizeof(b2Contact*))
		 me.m_contacts = new Array(contactCapacity)
		for (i = 0; i < contactCapacity; i++)
			 me.m_contacts[i] = null
		' // me.m_joints = (b2Joint**)allocator->Allocate(jointCapacity * sizeof(b2Joint*))
		 me.m_joints = new Array(jointCapacity)
		for (i = 0; i < jointCapacity; i++)
			 me.m_joints[i] = null
		 me.m_allocator = allocator
	' // ~b2Island()
end

public  sub 	Clear()

		 me.m_bodyCount = 0
		 me.m_contactCount = 0
		 me.m_jointCount = 0
end

public  sub 	Solve(step as variant, gravity as variant)

dim 		 i  as variant = 0

dim 		b
 as variant
		for (i = 0; i < me.m_bodyCount; ++i)
			b = me.m_bodies[i]
			if (b.m_invMass == 0.0)
				continue
			b.m_linearVelocity.Add( b2Math.MulFV (step.dt, b2Math.AddVV(gravity, b2Math.MulFV( b.m_invMass, b.m_force ) ) ) )
			b.m_angularVelocity += step.dt * b.m_invI * b.m_torque
			' // b.m_linearVelocity *= b.m_linearDamping
			b.m_linearVelocity.Multiply(b.m_linearDamping)
			b.m_angularVelocity *= b.m_angularDamping
			' //  Store positions for conservative advancement.
			b.m_position0.SetV(b.m_position)
			b.m_rotation0 = b.m_rotation
dim 		 contactSolver  as variant = new b2ContactSolver( me.m_contacts, me.m_contactCount, me.m_allocator)

		' //  Pre-solve
		contactSolver.PreSolve()
		for (i = 0; i < me.m_jointCount; ++i)
			 me.m_joints[i].PrepareVelocitySolver()
		' //  me.Solve velocity constraints.
		for (i = 0; i < step.iterations; ++i)
			contactSolver.SolveVelocityConstraints()
			for (var j = 0; j < me.m_jointCount; ++j)
			
				 me.m_joints[j].SolveVelocityConstraints(step)
			
		' //  Integrate positions.
		for (i = 0; i < me.m_bodyCount; ++i)
			b = me.m_bodies[i]
			if (b.m_invMass == 0.0)
				continue
			' // b.m_position.Add( b2Math.MulFV (step.dt, b.m_linearVelocity) )
			b.m_position.x += step.dt * b.m_linearVelocity.x
			b.m_position.y += step.dt * b.m_linearVelocity.y
			b.m_rotation += step.dt * b.m_angularVelocity
			b.m_R.Set(b.m_rotation)
		for (i = 0; i < me.m_jointCount; ++i)
			 me.m_joints[i].PreparePositionSolver()
		' //  me.Solve position constraints.
		if (b2World.s_enablePositionCorrection)
			for (b2Island.m_positionIterationCount = 0; b2Island.m_positionIterationCount < step.iterations; ++b2Island.m_positionIterationCount)
			
dim 				 contactsOkay  as variant = contactSolver.SolvePositionConstraints(b2Settings.b2_contactBaumgarte)

dim 				 jointsOkay  as variant = true

				for (i = 0; i < me.m_jointCount; ++i)
				
dim 					 jointOkay  as variant = me.m_joints[i].SolvePositionConstraints()

					jointsOkay = jointsOkay && jointOkay
				
				if (contactsOkay && jointsOkay)
				
					break
				
			
		' //  Post-solve.
		contactSolver.PostSolve()
		' //  Synchronize shapes and reset forces.
		for (i = 0; i < me.m_bodyCount; ++i)
			b = me.m_bodies[i]
			if (b.m_invMass == 0.0)
				continue
			b.m_R.Set(b.m_rotation)
			b.SynchronizeShapes()
			b.m_force.Set(0.0, 0.0)
			b.m_torque = 0.0
end

public  sub 	UpdateSleep(dt as variant)

dim 		 i  as variant = 0

dim 		b
 as variant
dim 		 minSleepTime  as variant = Number.MAX_VALUE

dim 		 linTolSqr  as variant = b2Settings.b2_linearSleepTolerance * b2Settings.b2_linearSleepTolerance

dim 		 angTolSqr  as variant = b2Settings.b2_angularSleepTolerance * b2Settings.b2_angularSleepTolerance

		for (i = 0; i < me.m_bodyCount; ++i)
			b = me.m_bodies[i]
			if (b.m_invMass == 0.0)
			
				continue
			
			if ((b.m_flags & b2Body.e_allowSleepFlag) == 0)
			
				b.m_sleepTime = 0.0
				minSleepTime = 0.0
			
			if ((b.m_flags & b2Body.e_allowSleepFlag) == 0 ||
				b.m_angularVelocity * b.m_angularVelocity > angTolSqr ||
				b2Math.b2Dot(b.m_linearVelocity, b.m_linearVelocity) > linTolSqr)
			
				b.m_sleepTime = 0.0
				minSleepTime = 0.0
			
			else
			
				b.m_sleepTime += dt
				minSleepTime = b2Math.b2Min(minSleepTime, b.m_sleepTime)
			
		if (minSleepTime >= b2Settings.b2_timeToSleep)
			for (i = 0; i < me.m_bodyCount; ++i)
			
				b = me.m_bodies[i]
				b.m_flags |= b2Body.e_sleepFlag
			
end

public  sub 	AddBody(body as variant)

		' // b2Settings.b2Assert( me.m_bodyCount < me.m_bodyCapacity)
		 me.m_bodies[ me.m_bodyCount++] = body
end

public  sub 	AddContact(contact as variant)

		' // b2Settings.b2Assert( me.m_contactCount < me.m_contactCapacity)
		 me.m_contacts[ me.m_contactCount++] = contact
end

public  sub 	AddJoint(joint as variant)

		' // b2Settings.b2Assert( me.m_jointCount < me.m_jointCapacity)
		 me.m_joints[ me.m_jointCount++] = joint
	m_allocator: null
	m_bodies: null
	m_contacts: null
	m_joints: null
	m_bodyCount: 0
	m_jointCount: 0
	m_contactCount: 0
	m_bodyCapacity: 0
	m_contactCapacity: 0
	m_jointCapacity: 0
	m_positionError: null
b2Island.m_positionIterationCount = 0