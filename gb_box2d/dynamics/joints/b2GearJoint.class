
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 ' you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */


inherits  b2Joint


public m_ground1 as variant= null
public m_ground2 as variant= null

 // One of these is NULL.
public m_revolute1 as variant= null
public m_prismatic1 as variant= null

 // One of these is NULL.
public m_revolute2 as variant= null
public m_prismatic2 as variant= null

public m_groundAnchor1 as variant= new b2Vec2()
public m_groundAnchor2 as variant= new b2Vec2()

public m_localAnchor1 as variant= new b2Vec2()
public m_localAnchor2 as variant= new b2Vec2()

public m_J as variant= new b2Jacobian()

public m_constant as variant= null
public m_ratio as variant= null

' // Effective mass
public m_mass as variant= null

' // Impulse for accumulation/warm starting.
public m_impulse as variant= null


public  sub	GetAnchor1() as variant ''funcio as variant ''funcion
		' // return me.m_body1.m_position + b2MulMV( me.m_body1.m_R, me.m_localAnchor1)
 '' TODO: posible funcion (revisar)

dim 		 tMat  as variant = me.m_body1.m_R

		return new b2Vec2(	 me.m_body1.m_position.x + (tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y), 							 me.m_body1.m_position.y + (tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y))
end

public  sub 	GetAnchor2() as variant ''funcio as variant ''funcion
		' // return me.m_body2->m_position + b2Mul( me.m_body2->m_R, me.m_localAnchor2)
 '' TODO: posible funcion (revisar)

dim 		 tMat  as variant = me.m_body2.m_R

		return new b2Vec2(	 me.m_body2.m_position.x + (tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y), 							 me.m_body2.m_position.y + (tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y))
end

public  sub 	GetReactionForce(invTimeStep as variant) as variant ''funcion
		' // b2Vec2 F(0.0f, 0.0f)
		return new b2Vec2()
 '' TODO: posible funcion (revisar)

end

public  sub 	GetReactionTorque(invTimeStep as variant) as variant ''funcion
		return 0.0
 '' TODO: posible funcion (revisar)

end

public  sub 	GetRatio() as variant ''funcion
		return me.m_ratio
end


	' // --------------- Internals Below -------------------

public  sub _new(def as variant)
dim 		coordinate1  as variant
dim 		coordinate2  as variant
		' //  The constructor for b2Joint
		' //  initialize instance variables for references
		 me.m_node1 = new b2JointNode()
		 me.m_node2 = new b2JointNode()
		' // 
		 me.m_type = def.type
		 me.m_prev = null
		 me.m_next = null
		 me.m_body1 = def.body1
		 me.m_body2 = def.body2
		 me.m_collideConnected = def.collideConnected
		 me.m_islandFlag = false
		 me.m_userData = def.userData
		' // 
		' //  initialize instance variables for references
		 me.m_groundAnchor1 = new b2Vec2()
		 me.m_groundAnchor2 = new b2Vec2()
		 me.m_localAnchor1 = new b2Vec2()
		 me.m_localAnchor2 = new b2Vec2()
		 me.m_J = new b2Jacobian()
		' // 
		' //  parent constructor
		' // super(def)
		' // b2Settings.b2Assert(def.joint1.m_type == b2Joint.e_revoluteJoint || def.joint1.m_type == b2Joint.e_prismaticJoint)
		' // b2Settings.b2Assert(def.joint2.m_type == b2Joint.e_revoluteJoint || def.joint2.m_type == b2Joint.e_prismaticJoint)
		' // b2Settings.b2Assert(def.joint1.m_body1.IsStatic())
		' // b2Settings.b2Assert(def.joint2.m_body1.IsStatic())
		 me.m_revolute1 = null
		 me.m_prismatic1 = null
		 me.m_revolute2 = null
		 me.m_prismatic2 = null

		 me.m_ground1 = def.joint1.m_body1
		 me.m_body1 = def.joint1.m_body2
		if (def.joint1.m_type = b2Joint.e_revoluteJoint) then 
			 me.m_revolute1 = def.joint1
			 me.m_groundAnchor1.SetV( me.m_revolute1.m_localAnchor1 )
			 me.m_localAnchor1.SetV( me.m_revolute1.m_localAnchor2 )
			coordinate1 = me.m_revolute1.GetJointAngle()
		else
			 me.m_prismatic1 = def.joint1
			 me.m_groundAnchor1.SetV( me.m_prismatic1.m_localAnchor1 )
			 me.m_localAnchor1.SetV( me.m_prismatic1.m_localAnchor2 )
			coordinate1 = me.m_prismatic1.GetJointTranslation()
		endif
		
		 me.m_ground2 = def.joint2.m_body1
		 me.m_body2 = def.joint2.m_body2
		if (def.joint2.m_type = b2Joint.e_revoluteJoint) them 
			 me.m_revolute2 = def.joint2
			 me.m_groundAnchor2.SetV( me.m_revolute2.m_localAnchor1 )
			 me.m_localAnchor2.SetV( me.m_revolute2.m_localAnchor2 )
			coordinate2 = me.m_revolute2.GetJointAngle()
		else
			 me.m_prismatic2 = def.joint2
			 me.m_groundAnchor2.SetV( me.m_prismatic2.m_localAnchor1 )
			 me.m_localAnchor2.SetV( me.m_prismatic2.m_localAnchor2 )
			coordinate2 = me.m_prismatic2.GetJointTranslation()
		endif
			
		 me.m_ratio = def.ratio
		 me.m_constant = coordinate1 + me.m_ratio * coordinate2
		 me.m_impulse = 0.0
end

public  sub 	PrepareVelocitySolver()

dim 		 g1  as variant = me.m_ground1

dim 		 g2  as variant = me.m_ground2

dim 		 b1  as variant = me.m_body1

dim 		 b2  as variant = me.m_body2

		' //  temp vars
dim 		ugX  as variant
dim 		ugY  as variant
dim 		rX  as variant
dim 		rY  as variant
dim 		tMat  as variant
dim 		tVec  as variant
dim 		crug  as variant
dim 		 K  as variant = 0.0

		 me.m_J.SetZero()
		if ( me.m_revolute1) then 
			 me.m_J.angular1 = -1.0
			K += b1.m_invI
		else
			' // b2Vec2 ug = b2MulMV(g1->m_R, me.m_prismatic1->m_localXAxis1)
			tMat = g1.m_R
			tVec = me.m_prismatic1.m_localXAxis1
			ugX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y
			ugY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y
			' // b2Vec2 r = b2MulMV(b1->m_R, me.m_localAnchor1)
			tMat = b1.m_R
			rX = tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y
			rY = tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y
			' // var crug = b2Cross(r, ug)
			crug = rX * ugY - rY * ugX
			' // me.m_J.linear1 = -ug
			 me.m_J.linear1.Set(-ugX, -ugY)
			 me.m_J.angular1 = -crug
			K += b1.m_invMass + b1.m_invI * crug * crug
		endif
		
		if ( me.m_revolute2) then 
			 me.m_J.angular2 = - me.m_ratio
			K += me.m_ratio * me.m_ratio * b2.m_invI
		else
			' // b2Vec2 ug = b2Mul(g2->m_R, me.m_prismatic2->m_localXAxis1)
			tMat = g2.m_R
			tVec = me.m_prismatic2.m_localXAxis1
			ugX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y
			ugY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y
			' // b2Vec2 r = b2Mul(b2->m_R, me.m_localAnchor2)
			tMat = b2.m_R
			rX = tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y
			rY = tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y
			' // float32 crug = b2Cross(r, ug)
			crug = rX * ugY - rY * ugX
			' // me.m_J.linear2 = - me.m_ratio * ug
			 me.m_J.linear2.Set(- me.m_ratio*ugX, - me.m_ratio*ugY)
			 me.m_J.angular2 = - me.m_ratio * crug
			K += me.m_ratio * me.m_ratio * (b2.m_invMass + b2.m_invI * crug * crug)
		endif
		
		' //  Compute effective mass.
		' // b2Settings.b2Assert(K > 0.0)
		 me.m_mass = 1.0 / K
		' //  Warm starting.
		' // b1.m_linearVelocity += b1.m_invMass * me.m_impulse * me.m_J.linear1
		b1.m_linearVelocity.x += b1.m_invMass * me.m_impulse * me.m_J.linear1.x
		b1.m_linearVelocity.y += b1.m_invMass * me.m_impulse * me.m_J.linear1.y
		b1.m_angularVelocity += b1.m_invI * me.m_impulse * me.m_J.angular1
		' // b2.m_linearVelocity += b2.m_invMass * me.m_impulse * me.m_J.linear2
		b2.m_linearVelocity.x += b2.m_invMass * me.m_impulse * me.m_J.linear2.x
		b2.m_linearVelocity.y += b2.m_invMass * me.m_impulse * me.m_J.linear2.y
		b2.m_angularVelocity += b2.m_invI * me.m_impulse * me.m_J.angular2
end

public  sub 	SolveVelocityConstraints(step as variant)

dim 		 b1  as variant = me.m_body1

dim 		 b2  as variant = me.m_body2

dim 		 Cdot  as variant = me.m_J.Compute(	b1.m_linearVelocity, b1.m_angularVelocity,b2.m_linearVelocity, b2.m_angularVelocity)
dim 		 impulse  as variant = - me.m_mass * Cdot

		 me.m_impulse += impulse
		b1.m_linearVelocity.x += b1.m_invMass * impulse * me.m_J.linear1.x
		b1.m_linearVelocity.y += b1.m_invMass * impulse * me.m_J.linear1.y
		b1.m_angularVelocity  += b1.m_invI * impulse * me.m_J.angular1
		b2.m_linearVelocity.x += b2.m_invMass * impulse * me.m_J.linear2.x
		b2.m_linearVelocity.y += b2.m_invMass * impulse * me.m_J.linear2.y
		b2.m_angularVelocity  += b2.m_invI * impulse * me.m_J.angular2
end

public  sub 	SolvePositionConstraints() as variant ''funcion
dim 		 linearError  as variant = 0.0

dim 		 b1  as variant = me.m_body1

dim 		 b2  as variant = me.m_body2

dim 		coordinate1  as variant
dim 		coordinate2  as variant


dim 		 C  as variant
dim 		 impulse  as variant

		if ( me.m_revolute1) then 
			coordinate1 = me.m_revolute1.GetJointAngle()
		else
			coordinate1 = me.m_prismatic1.GetJointTranslation()
		endif
		
		if ( me.m_revolute2)
			coordinate2 = me.m_revolute2.GetJointAngle()
		else
			coordinate2 = me.m_prismatic2.GetJointTranslation()
		endif
		
	 C  = me.m_constant - (coordinate1 + me.m_ratio * coordinate2)

	 impulse  = - me.m_mass * C

		b1.m_position.x += b1.m_invMass * impulse * me.m_J.linear1.x
		b1.m_position.y += b1.m_invMass * impulse * me.m_J.linear1.y
		b1.m_rotation += b1.m_invI * impulse * me.m_J.angular1
		b2.m_position.x += b2.m_invMass * impulse * me.m_J.linear2.x
		b2.m_position.y += b2.m_invMass * impulse * me.m_J.linear2.y
		b2.m_rotation += b2.m_invI * impulse * me.m_J.angular2
		b1.m_R.Set(b1.m_rotation)
		b2.m_R.Set(b2.m_rotation)
		return linearError < b2Settings.b2_linearSlop

end
