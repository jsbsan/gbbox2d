
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 ' you must not   
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  Point-to-point constraint
' //  C = p2 - p1
' //  Cdot = v2 - v1
' //       = v2 + cross(w2, r2) - v1 - cross(w1, r1)
' //  J = [-I -r1_skew I r2_skew ]
' //  Identity used:
' //  w k % (rx i + ry j) = w * (-ry i + rx j)
' //  Motor constraint
' //  Cdot = w2 - w1
' //  J = [0 0 -1 0 0 1]
' //  K = invI1 + invI2


inherits  b2Joint



public m_localAnchor1 as variant= new b2Vec2()
public m_localAnchor2 as variant= new b2Vec2()
public m_ptpImpulse as variant= new b2Vec2()
public m_motorImpulse as variant= null
public m_limitImpulse as variant= null
public m_limitPositionImpulse as variant= null

public m_ptpMass as variant= new b2Mat22()
public m_motorMass as variant= null
public m_intialAngle as variant= null
public m_lowerAngle as variant= null
public m_upperAngle as variant= null
public m_maxMotorTorque as variant= null
public m_motorSpeed as variant= null

public m_enableLimit as variant= null
public m_enableMotor as variant= null
public m_limitState as variant= 0

public tImpulse as variant= new b2Vec2()



public  sub 	GetAnchor1() as variant ''funcion
dim 		 tMat  as variant = me.m_body1.m_R

		return new b2Vec2(	 me.m_body1.m_position.x + (tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y),  me.m_body1.m_position.y + (tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y))
end

public  sub 	GetAnchor2() as variant ''funcion
dim 		 tMat  as variant = me.m_body2.m_R

		return new b2Vec2(	 me.m_body2.m_position.x + (tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y), 							 me.m_body2.m_position.y + (tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y))
end

public  sub 	GetJointAngle() as variant ''funcion
		return me.m_body2.m_rotation - me.m_body1.m_rotation
end

public  sub 	GetJointSpeed() as variant ''funcion
		return me.m_body2.m_angularVelocity - me.m_body1.m_angularVelocity

end

public  sub 	GetMotorTorque(invTimeStep as variant) as variant ''funcion
		return  invTimeStep * me.m_motorImpulse

end

public  sub 	SetMotorSpeed(speed as variant)

		 me.m_motorSpeed = speed
end

public  sub 	SetMotorTorque(torque as variant)

		 me.m_maxMotorTorque = torque
end

public  sub 	GetReactionForce(invTimeStep as variant) as variant ''funcio as variant ''funcion
dim 		 tVec  as variant = me.m_ptpImpulse.Copy()

		tVec.Multiply(invTimeStep)
		' // return invTimeStep * me.m_ptpImpulse
		return tVec
end

public  sub 	GetReactionTorque(invTimeStep as variant) as variant ''funcion
		return invTimeStep * me.m_limitImpulse
end


	' // --------------- Internals Below -------------------

public  sub  _new(def as variant)
dim 		tMat  as variant
dim 		tX  as variant
dim 		tY  as variant

		' //  The constructor for b2Joint
		' //  initialize instance variables for references
		 me.m_node1 = new b2JointNode()
		 me.m_node2 = new b2JointNode()
		' // 
		 me.m_type = def.type
		 me.m_prev = null
		 me.m_next = null
		 me.m_body1 = def.body1
		 me.m_body2 = def.body2
		 me.m_collideConnected = def.collideConnected
		 me.m_islandFlag = false
		 me.m_userData = def.userData
		' // 
		' //  initialize instance variables for references
		 me.K = new b2Mat22()
		 me.K1 = new b2Mat22()
		 me.K2 = new b2Mat22()
		 me.K3 = new b2Mat22()
		 me.m_localAnchor1 = new b2Vec2()
		 me.m_localAnchor2 = new b2Vec2()
		 me.m_ptpImpulse = new b2Vec2()
		 me.m_ptpMass = new b2Mat22()


		' // super(def)
		' // me.m_localAnchor1 = b2Math.b2MulTMV( me.m_body1.m_R, b2Math.SubtractVV( def.anchorPoint, me.m_body1.m_position))
		tMat = me.m_body1.m_R
		tX = def.anchorPoint.x - me.m_body1.m_position.x
		tY = def.anchorPoint.y - me.m_body1.m_position.y
		 me.m_localAnchor1.x = tX * tMat.col1.x + tY * tMat.col1.y
		 me.m_localAnchor1.y = tX * tMat.col2.x + tY * tMat.col2.y
		' // me.m_localAnchor2 = b2Math.b2MulTMV( me.m_body2.m_R, b2Math.SubtractVV( def.anchorPoint, me.m_body2.m_position))
		tMat = me.m_body2.m_R
		tX = def.anchorPoint.x - me.m_body2.m_position.x
		tY = def.anchorPoint.y - me.m_body2.m_position.y
		 me.m_localAnchor2.x = tX * tMat.col1.x + tY * tMat.col1.y
		 me.m_localAnchor2.y = tX * tMat.col2.x + tY * tMat.col2.y
		 me.m_intialAngle = me.m_body2.m_rotation - me.m_body1.m_rotation
		 me.m_ptpImpulse.Set(0.0, 0.0)
		 me.m_motorImpulse = 0.0
		 me.m_limitImpulse = 0.0
		 me.m_limitPositionImpulse = 0.0
		 me.m_lowerAngle = def.lowerAngle
		 me.m_upperAngle = def.upperAngle
		 me.m_maxMotorTorque = def.motorTorque
		 me.m_motorSpeed = def.motorSpeed
		 me.m_enableLimit = def.enableLimit
		 me.m_enableMotor = def.enableMotor
end

	' //  internal vars
Public K as variant = new b2Mat22()
Public k1 as variant = new b2Mat22()
Public k2 as variant = new b2Mat22()
Public k3 as variant = new b2Mat22()


public  sub 	PrepareVelocitySolver()

dim 		 b1  as variant = me.m_body1

dim 		 b2  as variant = me.m_body2

dim 		tMat  as variant


dim 		 r1X as variant  

dim 		 r1Y as variant 

dim 		 r2X  as variant

dim 		 r2Y  as variant


dim 		 invMass1  as variant

dim 		 invMass2  as variant

dim 		 invI1  as variant

dim 		 invI2  as variant
dim 			 jointAngle  as variant 
		' //  Compute the effective mass matrix.
		' // b2Vec2 r1 = b2Mul(b1->m_R, me.m_localAnchor1)
		tMat = b1.m_R
	 r1X = tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y

	 r1Y = tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y

		' // b2Vec2 r2 = b2Mul(b2->m_R, me.m_localAnchor2)
		tMat = b2.m_R
	 r2X = tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y

	 r2Y = tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y

		' //  me.K    = [(1/m1 + 1/m2) * eye(2) - skew(r1) * invI1 * skew(r1) - skew(r2) * invI2 * skew(r2)]
		' //       = [1/m1+1/m2     0    ] + invI1 * [r1.y*r1.y -r1.x*r1.y] + invI2 * [r1.y*r1.y -r1.x*r1.y]
		' //         [    0     1/m1+1/m2]           [-r1.x*r1.y r1.x*r1.x]           [-r1.x*r1.y r1.x*r1.x]
	 invMass1 = b1.m_invMass

	 invMass2 = b2.m_invMass

	 invI1 = b1.m_invI

	 invI2 = b2.m_invI

		' // var me.K1 = new b2Mat22()
		 me.K1.col1.x = invMass1 + invMass2
	 me.K1.col2.x = 0.0
		 me.K1.col1.y = 0.0
					 me.K1.col2.y = invMass1 + invMass2
		' // var me.K2 = new b2Mat22()
		 me.K2.col1.x =  invI1 * r1Y * r1Y
	 me.K2.col2.x = -invI1 * r1X * r1Y
		 me.K2.col1.y = -invI1 * r1X * r1Y
	 me.K2.col2.y =  invI1 * r1X * r1X
		' // var me.K3 = new b2Mat22()
		 me.K3.col1.x =  invI2 * r2Y * r2Y
	 me.K3.col2.x = -invI2 * r2X * r2Y
		 me.K3.col1.y = -invI2 * r2X * r2Y
	 me.K3.col2.y =  invI2 * r2X * r2X
		' // var me.K = b2Math.AddMM(b2Math.AddMM( me.K1, me.K2), me.K3)
		 me.K.SetM( me.K1)
		 me.K.AddM( me.K2)
		 me.K.AddM( me.K3)
		' // me.m_ptpMass = me.K.Invert()
		 me.K.Invert( me.m_ptpMass)
		 me.m_motorMass = 1.0 / (invI1 + invI2)
		
		if ( me.m_enableMotor = false) then 
			 me.m_motorImpulse = 0.0
		endif
		
		
		if ( me.m_enableLimit) then 
	    	 jointAngle = b2.m_rotation - b1.m_rotation - me.m_intialAngle

			if (b2Math.b2Abs( me.m_upperAngle - me.m_lowerAngle) < 2.0 * b2Settings.b2_angularSlop) then 
			
				 me.m_limitState = b2Joint.e_equalLimits
			
			else if (jointAngle <= me.m_lowerAngle) then 
			
				if ( me.m_limitState != b2Joint.e_atLowerLimit)
				
					 me.m_limitImpulse = 0.0
				endif
				
				 me.m_limitState = b2Joint.e_atLowerLimit
			
			else if (jointAngle >= me.m_upperAngle)
			
				if ( me.m_limitState <> b2Joint.e_atUpperLimit) then
				
					 me.m_limitImpulse = 0.0
				endif
				
				 me.m_limitState = b2Joint.e_atUpperLimit
		
			
			else
			
				 me.m_limitState = b2Joint.e_inactiveLimit
				 me.m_limitImpulse = 0.0
			endif
		else
			 me.m_limitImpulse = 0.0
		endif
		
		' //  Warm starting.
		if (b2World.s_enableWarmStarting) then 
			' // b1.m_linearVelocity.Subtract( b2Math.MulFV( invMass1, me.m_ptpImpulse) )
			b1.m_linearVelocity.x -= invMass1 * me.m_ptpImpulse.x
			b1.m_linearVelocity.y -= invMass1 * me.m_ptpImpulse.y
			' // b1.m_angularVelocity -= invI1 * (b2Math.b2CrossVV(r1, me.m_ptpImpulse) + me.m_motorImpulse + me.m_limitImpulse)
			b1.m_angularVelocity -= invI1 * ((r1X * me.m_ptpImpulse.y - r1Y * me.m_ptpImpulse.x) + me.m_motorImpulse + me.m_limitImpulse)
			' // b2.m_linearVelocity.Add( b2Math.MulFV( invMass2 , me.m_ptpImpulse ))
			b2.m_linearVelocity.x += invMass2 * me.m_ptpImpulse.x
			b2.m_linearVelocity.y += invMass2 * me.m_ptpImpulse.y
			' // b2.m_angularVelocity += invI2 * (b2Math.b2CrossVV(r2, me.m_ptpImpulse) + me.m_motorImpulse + me.m_limitImpulse)
			b2.m_angularVelocity += invI2 * ((r2X * me.m_ptpImpulse.y - r2Y * me.m_ptpImpulse.x) + me.m_motorImpulse + me.m_limitImpulse)
		else
			 me.m_ptpImpulse.SetZero()
			 me.m_motorImpulse = 0.0
			 me.m_limitImpulse = 0.0
		endif
		
		 me.m_limitPositionImpulse = 0.0
end

public  sub 	SolveVelocityConstraints(step as variant)

dim 		 b1  as variant = me.m_body1

dim 		 b2  as variant = me.m_body2

dim 		tMat  as variant



dim 		 r1X  as variant 

dim 		 r1Y  as variant 

dim 		 r2X  as variant 

dim 		 r2Y  as variant 

dim 		oldLimitImpulse  as variant


dim 		 ptpCdotX  as variant 

dim 		 ptpCdotY  as variant 


dim 		 ptpImpulseX  as variant 

dim 		 ptpImpulseY  as variant 

	


dim 			 motorCdot  as variant 

dim 			 motorImpulse as variant 

dim 			 oldMotorImpulse  as variant 


dim 			 limitCdot as variant


dim 			 limitImpulse  as variant 


		' // var r1 = b2Math.b2MulMV(b1.m_R, me.m_localAnchor1)
		tMat = b1.m_R
		 r1X  = tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y

		 r1Y  = tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y

		' // var r2 = b2Math.b2MulMV(b2.m_R, me.m_localAnchor2)
		tMat = b2.m_R
		 r2X  = tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y

		 r2Y  = tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y

		oldLimitImpulse  as variant
		' //  Solve point-to-point constraint
		' // b2Vec2 ptpCdot = b2.m_linearVelocity + b2Cross(b2.m_angularVelocity, r2) - b1.m_linearVelocity - b2Cross(b1.m_angularVelocity, r1)
		 ptpCdotX  = b2.m_linearVelocity.x + (-b2.m_angularVelocity * r2Y) - b1.m_linearVelocity.x - (-b1.m_angularVelocity * r1Y)

		 ptpCdotY  = b2.m_linearVelocity.y + (b2.m_angularVelocity * r2X) - b1.m_linearVelocity.y - (b1.m_angularVelocity * r1X)

		' // b2Vec2 ptpImpulse = -b2Mul( me.m_ptpMass, ptpCdot)
		 ptpImpulseX  = -( me.m_ptpMass.col1.x * ptpCdotX + me.m_ptpMass.col2.x * ptpCdotY)

		 ptpImpulseY  = -( me.m_ptpMass.col1.y * ptpCdotX + me.m_ptpMass.col2.y * ptpCdotY)

		 me.m_ptpImpulse.x += ptpImpulseX
		 me.m_ptpImpulse.y += ptpImpulseY
		' // b1->m_linearVelocity -= b1->m_invMass * ptpImpulse
		b1.m_linearVelocity.x -= b1.m_invMass * ptpImpulseX
		b1.m_linearVelocity.y -= b1.m_invMass * ptpImpulseY
		' // b1->m_angularVelocity -= b1->m_invI * b2Cross(r1, ptpImpulse)
		b1.m_angularVelocity -= b1.m_invI * (r1X * ptpImpulseY - r1Y * ptpImpulseX)
		' // b2->m_linearVelocity += b2->m_invMass * ptpImpulse
		b2.m_linearVelocity.x += b2.m_invMass * ptpImpulseX
		b2.m_linearVelocity.y += b2.m_invMass * ptpImpulseY
		' // b2->m_angularVelocity += b2->m_invI * b2Cross(r2, ptpImpulse)
		b2.m_angularVelocity += b2.m_invI * (r2X * ptpImpulseY - r2Y * ptpImpulseX)
		if ( me.m_enableMotor and me.m_limitState <> b2Joint.e_equalLimits) then 
			 motorCdot  = b2.m_angularVelocity - b1.m_angularVelocity - me.m_motorSpeed

			 motorImpulse  = - me.m_motorMass * motorCdot

			 oldMotorImpulse  = me.m_motorImpulse

			 me.m_motorImpulse = b2Math.b2Clamp( me.m_motorImpulse + motorImpulse, -step.dt * me.m_maxMotorTorque, step.dt * me.m_maxMotorTorque)
			motorImpulse = me.m_motorImpulse - oldMotorImpulse
			b1.m_angularVelocity -= b1.m_invI * motorImpulse
			b2.m_angularVelocity += b2.m_invI * motorImpulse
		endif
		
		if ( me.m_enableLimit and me.m_limitState <> b2Joint.e_inactiveLimit) then 
			 limitCdot  = b2.m_angularVelocity - b1.m_angularVelocity

			 limitImpulse  = - me.m_motorMass * limitCdot

			if ( me.m_limitState == b2Joint.e_equalLimits)
			
				 me.m_limitImpulse += limitImpulse
			
			else if ( me.m_limitState == b2Joint.e_atLowerLimit)
			
				oldLimitImpulse = me.m_limitImpulse
				 me.m_limitImpulse = b2Math.b2Max( me.m_limitImpulse + limitImpulse, 0.0)
				limitImpulse = me.m_limitImpulse - oldLimitImpulse
			
			else if ( me.m_limitState == b2Joint.e_atUpperLimit)
			
				oldLimitImpulse = me.m_limitImpulse
				 me.m_limitImpulse = b2Math.b2Min( me.m_limitImpulse + limitImpulse, 0.0)
				limitImpulse = me.m_limitImpulse - oldLimitImpulse
			endif
			
			b1.m_angularVelocity -= b1.m_invI * limitImpulse
			b2.m_angularVelocity += b2.m_invI * limitImpulse
		endif
		
end

public  sub 	SolvePositionConstraints() as variant ''funcion
dim 		oldLimitImpulse  as variant 
dim 		limitC  as variant
dim 		 b1  as variant = me.m_body1

dim 		 b2  as variant = me.m_body2

dim 		 positionError  as variant = 0.0

dim 		tMat  as variant



dim 		 r1X  as variant 

dim 		 r1Y  as variant 

	
dim 		 r2X  as variant 

dim 		 r2Y  as variant 

		' // b2Vec2 p1 = b1->m_position + r1
dim 		 p1X  as variant 

dim 		 p1Y  as variant 

		' // b2Vec2 p2 = b2->m_position + r2
dim 		 p2X  as variant 

dim 		 p2Y  as variant 

		' // b2Vec2 ptpC = p2 - p1
dim 		 ptpCX  as variant 

dim 		 ptpCY  as variant 

	
dim 		 invMass1  as variant 

dim 		 invMass2  as variant 

		' // float32 invI1 = b1->m_invI, invI2 = b2->m_invI
dim 		 invI1  as variant 

dim 		 invI2  as variant 


	dim 	 impulseX  as variant

dim 		 impulseY  as variant
dim 		 angularError  as variant

dim 			 angle  as variant 

dim 			 limitImpulse  as variant

		' //  Solve point-to-point position error.
		' // var r1 = b2Math.b2MulMV(b1.m_R, me.m_localAnchor1)
		tMat = b1.m_R
		 r1X  = tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y

		 r1Y  = tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y

		' // var r2 = b2Math.b2MulMV(b2.m_R, me.m_localAnchor2)
		tMat = b2.m_R
		 r2X  = tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y

		 r2Y  = tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y

		' // b2Vec2 p1 = b1->m_position + r1
		 p1X  = b1.m_position.x + r1X

		 p1Y  = b1.m_position.y + r1Y

		' // b2Vec2 p2 = b2->m_position + r2
		 p2X  = b2.m_position.x + r2X

		 p2Y  = b2.m_position.y + r2Y

		' // b2Vec2 ptpC = p2 - p1
		 ptpCX  = p2X - p1X

		 ptpCY  = p2Y - p1Y

		' // float32 positionError = ptpC.Length()
		positionError = sqrt(ptpCX*ptpCX + ptpCY*ptpCY)
		' //  Prevent overly large corrections.
		' // b2Vec2 dpMax(b2_maxLinearCorrection, b2_maxLinearCorrection)
		' // ptpC = b2Clamp(ptpC, -dpMax, dpMax)
		' // float32 invMass1 = b1->m_invMass, invMass2 = b2->m_invMass
		 invMass1  = b1.m_invMass

		 invMass2  = b2.m_invMass

		' // float32 invI1 = b1->m_invI, invI2 = b2->m_invI
		 invI1  = b1.m_invI

		 invI2  = b2.m_invI

		' // b2Mat22 me.K1
		 me.K1.col1.x = invMass1 + invMass2
	 me.K1.col2.x = 0.0
		 me.K1.col1.y = 0.0
					 me.K1.col2.y = invMass1 + invMass2
		' // b2Mat22 me.K2
		 me.K2.col1.x =  invI1 * r1Y * r1Y
	 me.K2.col2.x = -invI1 * r1X * r1Y
		 me.K2.col1.y = -invI1 * r1X * r1Y
	 me.K2.col2.y =  invI1 * r1X * r1X
		' // b2Mat22 me.K3
		 me.K3.col1.x =  invI2 * r2Y * r2Y
		 me.K3.col2.x = -invI2 * r2X * r2Y
		 me.K3.col1.y = -invI2 * r2X * r2Y
		 me.K3.col2.y =  invI2 * r2X * r2X
		' // b2Mat22 me.K = me.K1 + me.K2 + me.K3
		 me.K.SetM( me.K1)
		 me.K.AddM( me.K2)
		 me.K.AddM( me.K3)
		' // b2Vec2 impulse = me.K.Solve(-ptpC)
		 me.K.Solve(b2RevoluteJoint.tImpulse, -ptpCX, -ptpCY)
		 impulseX   = b2RevoluteJoint.tImpulse.x

		 impulseY   = b2RevoluteJoint.tImpulse.y

		' // b1.m_position -= b1.m_invMass * impulse
		b1.m_position.x -= b1.m_invMass * impulseX
		b1.m_position.y -= b1.m_invMass * impulseY
		' // b1.m_rotation -= b1.m_invI * b2Cross(r1, impulse)
		b1.m_rotation -= b1.m_invI * (r1X * impulseY - r1Y * impulseX)
		b1.m_R.Set(b1.m_rotation)
		' // b2.m_position += b2.m_invMass * impulse
		b2.m_position.x += b2.m_invMass * impulseX
		b2.m_position.y += b2.m_invMass * impulseY
		' // b2.m_rotation += b2.m_invI * b2Cross(r2, impulse)
		b2.m_rotation += b2.m_invI * (r2X * impulseY - r2Y * impulseX)
		b2.m_R.Set(b2.m_rotation)
		' //  Handle limits.
		 angularError   = 0.0

		if ( me.m_enableLimit and  me.m_limitState <> b2Joint.e_inactiveLimit) then 
			 angle   = b2.m_rotation - b1.m_rotation - me.m_intialAngle

			 limitImpulse   = 0.0

			if ( me.m_limitState = b2Joint.e_equalLimits) then 
			
				' //  Prevent large angular corrections
				limitC = b2Math.b2Clamp(angle, -b2Settings.b2_maxAngularCorrection, b2Settings.b2_maxAngularCorrection)
				limitImpulse = - me.m_motorMass * limitC
				angularError = b2Math.b2Abs(limitC)
			
			else if ( me.m_limitState = b2Joint.e_atLowerLimit) then 
			
				limitC = angle - me.m_lowerAngle
				angularError = b2Math.b2Max(0.0, -limitC)
				' //  Prevent large angular corrections and allow some slop.
				limitC = b2Math.b2Clamp(limitC + b2Settings.b2_angularSlop, -b2Settings.b2_maxAngularCorrection, 0.0)
				limitImpulse = - me.m_motorMass * limitC
				oldLimitImpulse = me.m_limitPositionImpulse
				 me.m_limitPositionImpulse = b2Math.b2Max( me.m_limitPositionImpulse + limitImpulse, 0.0)
				limitImpulse = me.m_limitPositionImpulse - oldLimitImpulse
			
			else if ( me.m_limitState = b2Joint.e_atUpperLimit) then 
			
				limitC = angle - me.m_upperAngle
				angularError = b2Math.b2Max(0.0, limitC)
				' //  Prevent large angular corrections and allow some slop.
				limitC = b2Math.b2Clamp(limitC - b2Settings.b2_angularSlop, 0.0, b2Settings.b2_maxAngularCorrection)
				limitImpulse = - me.m_motorMass * limitC
				oldLimitImpulse = me.m_limitPositionImpulse
				 me.m_limitPositionImpulse = b2Math.b2Min( me.m_limitPositionImpulse + limitImpulse, 0.0)
				limitImpulse = me.m_limitPositionImpulse - oldLimitImpulse
			endif
			
			b1.m_rotation -= b1.m_invI * limitImpulse
			b1.m_R.Set(b1.m_rotation)
			b2.m_rotation += b2.m_invI * limitImpulse
			b2.m_R.Set(b2.m_rotation)
		endif
		
	return positionError <= b2Settings.b2_linearSlop and angularError <= b2Settings.b2_angularSlop
end


