' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 ' you must not   
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  p = attached point, m = mouse point
' //  C = p - m
' //  Cdot = v
' //       = v + cross(w, r)
' //  J = [I r_skew]
' //  Identity used:
' //  w k % (rx i + ry j) = w * (-ry i + rx j)

inherits  b2Joint


	' //  Presolve vars
Public K as  new b2Mat22()
Public k1 as new b2Mat22()
Public k2 as new b2Mat22()

Public m_localAnchor as variant = new b2Vec2()
Public 	m_target as variant =new b2Vec2()
Public 	m_impulse as variant = new b2Vec2()
Public 	m_ptpMass as variant = new b2Mat22()
Public 	m_C as variant = new b2Vec2()
Public m_maxForce as variant = null
Public m_beta as variant = null
Public m_gamma as variant = null


public  sub 	GetAnchor1() as variant ''funcion
		return me.m_target
end

public  sub 	GetAnchor2() as variant ''funcion
dim 		 tVec  as variant = b2Math.b2MulMV( me.m_body2.m_R, me.m_localAnchor)
		tVec.Add( me.m_body2.m_position)
		return tVec
end

public  sub 	GetReactionForce(invTimeStep as variant) as variant ''funcion
		' // b2Vec2 F = invTimeStep * me.m_impulse
dim 		 F  as variant = new b2Vec2()

		F.SetV( me.m_impulse)
		F.Multiply(invTimeStep)
		return F
end

public  sub 	GetReactionTorque(invTimeStep as variant) as variant ''funcion
		return 0.0
end

public  sub 	SetTarget(target as variant)
		 me.m_body2.WakeUp()
		 me.m_target = target
end

	' // --------------- Internals Below -------------------
public  sub 	initialize(def as variant)
dim 		 tX  as variant 
dim 		 tY  as variant 

dim 		 mass  as variant 
dim 		 omega  as variant 
dim 		 d  as variant 
dim 		 k  as variant
		' //  The constructor for b2Joint
		' //  initialize instance variables for references
		 me.m_node1 = new b2JointNode()
		 me.m_node2 = new b2JointNode()
		' // 
		 me.m_type = def.type
		 me.m_prev = null
		 me.m_next = null
		 me.m_body1 = def.body1
		 me.m_body2 = def.body2
		 me.m_collideConnected = def.collideConnected
		 me.m_islandFlag = false
		 me.m_userData = def.userData
		' // 
		' //  initialize instance variables for references
		 me.K = new b2Mat22()
		 me.K1 = new b2Mat22()
		 me.K2 = new b2Mat22()
		 me.m_localAnchor = new b2Vec2()
		 me.m_target = new b2Vec2()
		 me.m_impulse = new b2Vec2()
		 me.m_ptpMass = new b2Mat22()
		 me.m_C = new b2Vec2()
		' // 
		' // super(def)
		 me.m_target.SetV(def.target)
		' // me.m_localAnchor = b2Math.b2MulTMV( me.m_body2.m_R, b2Math.SubtractVV( me.m_target, me.m_body2.m_position ) )
		 tX   = me.m_target.x - me.m_body2.m_position.x

		 tY   = me.m_target.y - me.m_body2.m_position.y

		 me.m_localAnchor.x = (tX * me.m_body2.m_R.col1.x + tY * me.m_body2.m_R.col1.y)
		 me.m_localAnchor.y = (tX * me.m_body2.m_R.col2.x + tY * me.m_body2.m_R.col2.y)
		 me.m_maxForce = def.maxForce
		 me.m_impulse.SetZero()
 			mass   = me.m_body2.m_mass

		' //  Frequency
 			omega   = 2.0 * b2Settings.b2_pi * def.frequencyHz

		' //  Damping coefficient
 			d   = 2.0 * mass * def.dampingRatio * omega

		' //  Spring stiffness
 			k   = mass * omega * omega

		' //  magic formulas
		 me.m_gamma = 1.0 / (d + def.timeStep * k)
		 me.m_beta = def.timeStep * k / (d + def.timeStep * k)
	
end 


public  sub 	PrepareVelocitySolver()

dim 		 b  as variant = me.m_body2

dim 		tMat  as variant
	
dim 		 rX  as variant = tMat.col1.x * me.m_localAnchor.x + tMat.col2.x * me.m_localAnchor.y

dim 		 rY  as variant = tMat.col1.y * me.m_localAnchor.x + tMat.col2.y * me.m_localAnchor.y

		' //  me.K    = [(1/m1 + 1/m2) * eye(2) - skew(r1) * invI1 * skew(r1) - skew(r2) * invI2 * skew(r2)]
		' //       = [1/m1+1/m2     0    ] + invI1 * [r1.y*r1.y -r1.x*r1.y] + invI2 * [r1.y*r1.y -r1.x*r1.y]
		' //         [    0     1/m1+1/m2]           [-r1.x*r1.y r1.x*r1.x]           [-r1.x*r1.y r1.x*r1.x]
dim 		 invMass  as variant = b.m_invMass

dim 		 invI  as variant = b.m_invI

dim 		 PX  as variant 

dim 		 PY  as variant 

	' //  Compute the effective mass matrix.
		' // b2Vec2 r = b2Mul(b.m_R, me.m_localAnchor)
		tMat = b.m_R


		' // b2Mat22 me.K1
		 me.K1.col1.x = invMass
	 me.K1.col2.x = 0.0
		 me.K1.col1.y = 0.0
		 me.K1.col2.y = invMass
		' // b2Mat22 me.K2
		 me.K2.col1.x =  invI * rY * rY
	 me.K2.col2.x = -invI * rX * rY
		 me.K2.col1.y = -invI * rX * rY
	 me.K2.col2.y =  invI * rX * rX
		' // b2Mat22 me.K = me.K1 + me.K2
		 me.K.SetM( me.K1)
		 me.K.AddM( me.K2)
		 me.K.col1.x += me.m_gamma
		 me.K.col2.y += me.m_gamma
		' // me.m_ptpMass = me.K.Invert()
		 me.K.Invert( me.m_ptpMass)
		' // me.m_C = b.m_position + r - me.m_target
		 me.m_C.x = b.m_position.x + rX - me.m_target.x
		 me.m_C.y = b.m_position.y + rY - me.m_target.y
		' //  Cheat with some damping
		b.m_angularVelocity *= 0.98
		' //  Warm starting.
		' // b2Vec2 P = me.m_impulse
	 PX   = me.m_impulse.x

		 PY   = me.m_impulse.y

		' // b.m_linearVelocity += invMass * P
		b.m_linearVelocity.x += invMass * PX
		b.m_linearVelocity.y += invMass * PY
		' // b.m_angularVelocity += invI * b2Cross(r, P)
		b.m_angularVelocity += invI * (rX * PY - rY * PX)
end

public  sub 	SolveVelocityConstraints(step as variant)

dim 		 body  as variant = me.m_body2

dim 		tMat  as variant
		' //  Compute the effective mass matrix.
		' // b2Vec2 r = b2Mul(body.m_R, me.m_localAnchor)
	
dim 		 rX  as variant 

dim 		 rY  as variant 

		' //  Cdot = v + cross(w, r)
		' // b2Vec2 Cdot = body->m_linearVelocity + b2Cross(body->m_angularVelocity, r)
dim 		 CdotX  as variant 

dim 		 CdotY  as variant

dim 		 tX  as variant
dim 		 tY  as variant
dim 		 impulseX  as variant
dim 		 impulseY  as variant
dim 		 oldImpulseX  as variant
dim 		 oldImpulseY  as variant
dim 		 length  as variant

	tMat = body.m_R
	
	
		 rX  = tMat.col1.x * me.m_localAnchor.x + tMat.col2.x * me.m_localAnchor.y

		 rY   = tMat.col1.y * me.m_localAnchor.x + tMat.col2.y * me.m_localAnchor.y

	
		' // b2Vec2 impulse = -b2Mul( me.m_ptpMass, Cdot + ( me.m_beta * step->inv_dt) * me.m_C + me.m_gamma * me.m_impulse)
		tMat = me.m_ptpMass
		 tX   = CdotX + ( me.m_beta * step.inv_dt) * me.m_C.x + me.m_gamma * me.m_impulse.x

		 tY   = CdotY + ( me.m_beta * step.inv_dt) * me.m_C.y + me.m_gamma * me.m_impulse.y

		 impulseX   = -(tMat.col1.x * tX + tMat.col2.x * tY)

		 impulseY   = -(tMat.col1.y * tX + tMat.col2.y * tY)

		 oldImpulseX   = me.m_impulse.x

		 oldImpulseY   = me.m_impulse.y

		' // me.m_impulse += impulse
		 me.m_impulse.x += impulseX
		 me.m_impulse.y += impulseY
		 length   = me.m_impulse.Length()

		if (length > step.dt * me.m_maxForce) then 
			' // me.m_impulse *= step.dt * me.m_maxForce / length
			 me.m_impulse.Multiply(step.dt * me.m_maxForce / length)
		endif
		
		' // impulse = me.m_impulse - oldImpulse
		impulseX = me.m_impulse.x - oldImpulseX
		impulseY = me.m_impulse.y - oldImpulseY
		' // body.m_linearVelocity += body->m_invMass * impulse
		body.m_linearVelocity.x += body.m_invMass * impulseX
		body.m_linearVelocity.y += body.m_invMass * impulseY
		' // body.m_angularVelocity += body->m_invI * b2Cross(r, impulse)
		body.m_angularVelocity += body.m_invI * (rX * impulseY - rY * impulseX)
end

public  sub 	SolvePositionConstraints() as variant ''funcion
		return true
end

