' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  p = attached point, m = mouse point
' //  C = p - m
' //  Cdot = v
' //       = v + cross(w, r)
' //  J = [I r_skew]
' //  Identity used:
' //  w k % (rx i + ry j) = w * (-ry i + rx j)
dim  b2MouseJoint  as variant = Class.create()

inherits , b2Joint
inherits 
end

public  sub 	GetAnchor1() as variant ''funcion
		return me.m_target
 '' TODO: posible funcion (revisar)

end

public  sub 	GetAnchor2() as variant ''funcion
dim 		 tVec  as variant = b2Math.b2MulMV( me.m_body2.m_R, me.m_localAnchor)

		tVec.Add( me.m_body2.m_position)
		return tVec
 '' TODO: posible funcion (revisar)

end

public  sub 	GetReactionForce(invTimeStep as variant) as variant ''funcion
		' // b2Vec2 F = invTimeStep * me.m_impulse
dim 		 F  as variant = new b2Vec2()

		F.SetV( me.m_impulse)
		F.Multiply(invTimeStep)
		return F
 '' TODO: posible funcion (revisar)

end

public  sub 	GetReactionTorque(invTimeStep as variant) as variant ''funcion
		' // NOT_USED(invTimeStep)
		return 0.0
 '' TODO: posible funcion (revisar)

end

public  sub 	SetTarget(target as variant)

		 me.m_body2.WakeUp()
		 me.m_target = target
	' // --------------- Internals Below -------------------
end

public  sub 	initialize(def as variant)

		' //  The constructor for b2Joint
		' //  initialize instance variables for references
		 me.m_node1 = new b2JointNode()
		 me.m_node2 = new b2JointNode()
		' // 
		 me.m_type = def.type
		 me.m_prev = null
		 me.m_next = null
		 me.m_body1 = def.body1
		 me.m_body2 = def.body2
		 me.m_collideConnected = def.collideConnected
		 me.m_islandFlag = false
		 me.m_userData = def.userData
		' // 
		' //  initialize instance variables for references
		 me.K = new b2Mat22()
		 me.K1 = new b2Mat22()
		 me.K2 = new b2Mat22()
		 me.m_localAnchor = new b2Vec2()
		 me.m_target = new b2Vec2()
		 me.m_impulse = new b2Vec2()
		 me.m_ptpMass = new b2Mat22()
		 me.m_C = new b2Vec2()
		' // 
		' // super(def)
		 me.m_target.SetV(def.target)
		' // me.m_localAnchor = b2Math.b2MulTMV( me.m_body2.m_R, b2Math.SubtractVV( me.m_target, me.m_body2.m_position ) )
dim 		 tX  as variant = me.m_target.x - me.m_body2.m_position.x

dim 		 tY  as variant = me.m_target.y - me.m_body2.m_position.y

		 me.m_localAnchor.x = (tX * me.m_body2.m_R.col1.x + tY * me.m_body2.m_R.col1.y)
		 me.m_localAnchor.y = (tX * me.m_body2.m_R.col2.x + tY * me.m_body2.m_R.col2.y)
		 me.m_maxForce = def.maxForce
		 me.m_impulse.SetZero()
dim 		 mass  as variant = me.m_body2.m_mass

		' //  Frequency
dim 		 omega  as variant = 2.0 * b2Settings.b2_pi * def.frequencyHz

		' //  Damping coefficient
dim 		 d  as variant = 2.0 * mass * def.dampingRatio * omega

		' //  Spring stiffness
dim 		 k  as variant = mass * omega * omega

		' //  magic formulas
		 me.m_gamma = 1.0 / (d + def.timeStep * k)
		 me.m_beta = def.timeStep * k / (d + def.timeStep * k)
	' //  Presolve vars
Public K: new b2Mat22(), as new 2Mat22(),
Public 1: new b2Mat22(), as new 2Mat22(),
Public 2: new b2Mat22(), as new 2Mat22(),
end

public  sub 	PrepareVelocitySolver()

dim 		 b  as variant = me.m_body2

dim 		tMat
 as variant
		' //  Compute the effective mass matrix.
		' // b2Vec2 r = b2Mul(b.m_R, me.m_localAnchor)
		tMat = b.m_R
dim 		 rX  as variant = tMat.col1.x * me.m_localAnchor.x + tMat.col2.x * me.m_localAnchor.y

dim 		 rY  as variant = tMat.col1.y * me.m_localAnchor.x + tMat.col2.y * me.m_localAnchor.y

		' //  me.K    = [(1/m1 + 1/m2) * eye(2) - skew(r1) * invI1 * skew(r1) - skew(r2) * invI2 * skew(r2)]
		' //       = [1/m1+1/m2     0    ] + invI1 * [r1.y*r1.y -r1.x*r1.y] + invI2 * [r1.y*r1.y -r1.x*r1.y]
		' //         [    0     1/m1+1/m2]           [-r1.x*r1.y r1.x*r1.x]           [-r1.x*r1.y r1.x*r1.x]
dim 		 invMass  as variant = b.m_invMass

dim 		 invI  as variant = b.m_invI

		' // b2Mat22 me.K1
		 me.K1.col1.x = invMass
	 me.K1.col2.x = 0.0
		 me.K1.col1.y = 0.0
		 me.K1.col2.y = invMass
		' // b2Mat22 me.K2
		 me.K2.col1.x =  invI * rY * rY
	 me.K2.col2.x = -invI * rX * rY
		 me.K2.col1.y = -invI * rX * rY
	 me.K2.col2.y =  invI * rX * rX
		' // b2Mat22 me.K = me.K1 + me.K2
		 me.K.SetM( me.K1)
		 me.K.AddM( me.K2)
		 me.K.col1.x += me.m_gamma
		 me.K.col2.y += me.m_gamma
		' // me.m_ptpMass = me.K.Invert()
		 me.K.Invert( me.m_ptpMass)
		' // me.m_C = b.m_position + r - me.m_target
		 me.m_C.x = b.m_position.x + rX - me.m_target.x
		 me.m_C.y = b.m_position.y + rY - me.m_target.y
		' //  Cheat with some damping
		b.m_angularVelocity *= 0.98
		' //  Warm starting.
		' // b2Vec2 P = me.m_impulse
dim 		 PX  as variant = me.m_impulse.x

dim 		 PY  as variant = me.m_impulse.y

		' // b.m_linearVelocity += invMass * P
		b.m_linearVelocity.x += invMass * PX
		b.m_linearVelocity.y += invMass * PY
		' // b.m_angularVelocity += invI * b2Cross(r, P)
		b.m_angularVelocity += invI * (rX * PY - rY * PX)
end

public  sub 	SolveVelocityConstraints(step as variant)

dim 		 body  as variant = me.m_body2

dim 		tMat
 as variant
		' //  Compute the effective mass matrix.
		' // b2Vec2 r = b2Mul(body.m_R, me.m_localAnchor)
		tMat = body.m_R
dim 		 rX  as variant = tMat.col1.x * me.m_localAnchor.x + tMat.col2.x * me.m_localAnchor.y

dim 		 rY  as variant = tMat.col1.y * me.m_localAnchor.x + tMat.col2.y * me.m_localAnchor.y

		' //  Cdot = v + cross(w, r)
		' // b2Vec2 Cdot = body->m_linearVelocity + b2Cross(body->m_angularVelocity, r)
dim 		 CdotX  as variant = body.m_linearVelocity.x + (-body.m_angularVelocity * rY)

dim 		 CdotY  as variant = body.m_linearVelocity.y + (body.m_angularVelocity * rX)

		' // b2Vec2 impulse = -b2Mul( me.m_ptpMass, Cdot + ( me.m_beta * step->inv_dt) * me.m_C + me.m_gamma * me.m_impulse)
		tMat = me.m_ptpMass
dim 		 tX  as variant = CdotX + ( me.m_beta * step.inv_dt) * me.m_C.x + me.m_gamma * me.m_impulse.x

dim 		 tY  as variant = CdotY + ( me.m_beta * step.inv_dt) * me.m_C.y + me.m_gamma * me.m_impulse.y

dim 		 impulseX  as variant = -(tMat.col1.x * tX + tMat.col2.x * tY)

dim 		 impulseY  as variant = -(tMat.col1.y * tX + tMat.col2.y * tY)

dim 		 oldImpulseX  as variant = me.m_impulse.x

dim 		 oldImpulseY  as variant = me.m_impulse.y

		' // me.m_impulse += impulse
		 me.m_impulse.x += impulseX
		 me.m_impulse.y += impulseY
dim 		 length  as variant = me.m_impulse.Length()

		if (length > step.dt * me.m_maxForce)
			' // me.m_impulse *= step.dt * me.m_maxForce / length
			 me.m_impulse.Multiply(step.dt * me.m_maxForce / length)
		' // impulse = me.m_impulse - oldImpulse
		impulseX = me.m_impulse.x - oldImpulseX
		impulseY = me.m_impulse.y - oldImpulseY
		' // body.m_linearVelocity += body->m_invMass * impulse
		body.m_linearVelocity.x += body.m_invMass * impulseX
		body.m_linearVelocity.y += body.m_invMass * impulseY
		' // body.m_angularVelocity += body->m_invI * b2Cross(r, impulse)
		body.m_angularVelocity += body.m_invI * (rX * impulseY - rY * impulseX)
end

public  sub 	SolvePositionConstraints() as variant ''funcion
		return true
 '' TODO: posible funcion (revisar)

Public r: new b2Vec2(), as new 2Vec2(),
Public t: new b2Vec2(), as new 2Vec2(),
Public e: new b2Vec2(), as new 2Vec2(),
Public s: new b2Mat22(), as new 2Mat22(),
Public C: new b2Vec2(), as new 2Vec2(),
	m_maxForce: null
	m_beta: null
	m_gamma: null)