' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 ' you must not    
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */

inherits b2Joint


public m_ground as variant= null,
public m_groundAnchor1 as variant= new b2Vec2()
public m_groundAnchor2 as variant= new b2Vec2()
public m_localAnchor1 as variant= new b2Vec2()
public m_localAnchor2 as variant= new b2Vec2()

public m_u1 as variant= new b2Vec2()
public m_u2 as variant= new b2Vec2()

public m_constant as variant= null
public m_ratio as variant= null

public m_maxLength1 as variant= null
public m_maxLength2 as variant= null

'// Effective masses
public m_pulleyMass as variant= null
public m_limitMass1 as variant= null
public m_limitMass2 as variant= null

' // Impulses for accumulation/warm starting.
public m_pulleyImpulse as variant= null
public m_limitImpulse1 as variant= null
public m_limitImpulse2 as variant= null

' // Position impulses for accumulation.
public m_limitPositionImpulse1 as variant= null
public m_limitPositionImpulse2 as variant= null

public m_limitState1 as variant= 0
public m_limitState2 as variant= 0

public b2_minPulleyLength as variant = b2Settings.b2_lengthUnitsPerMeter





public  sub 	GetAnchor1() as variant ''funcio as variant ''funcion
		' // return me.m_body1->m_position + b2Mul( me.m_body1->m_R ,me.m_localAnchor1)
dim 		 tMat  as variant = me.m_body1.m_R
		return new b2Vec2(	 me.m_body1.m_position.x + (tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y),  me.m_body1.m_position.y + (tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y))
end

public  sub 	GetAnchor2() as variant ''funcio as variant ''funcion
		' // return me.m_body2->m_position + b2Mul( me.m_body2->m_R, me.m_localAnchor2)
dim 		 tMat  as variant = me.m_body2.m_R

		return new b2Vec2(	 me.m_body2.m_position.x + (tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y),  me.m_body2.m_position.y + (tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y))
end

public  sub 	GetGroundPoint1() as variant ''funcio as variant ''funcion
		' // return me.m_ground->m_position + me.m_groundAnchor1
 		return new b2Vec2( me.m_ground.m_position.x + me.m_groundAnchor1.x, me.m_ground.m_position.y + me.m_groundAnchor1.y)
 end

public  sub 	GetGroundPoint2() as variant ''funcion
		return new b2Vec2( me.m_ground.m_position.x + me.m_groundAnchor2.x, me.m_ground.m_position.y + me.m_groundAnchor2.y)
 
end

public  sub 	GetReactionForce(invTimeStep as variant) as variant ''funcion
		' // b2Vec2 F(0.0f, 0.0f)
		return new b2Vec2()
 
end

public  sub 	GetReactionTorque(invTimeStep as variant) as variant ''funcion
		return 0.0
 
end

public  sub 	GetLength1() as float  ''funcion
dim 		tMat  as variant
dim 		 dX  as variant
dim 		 dY  as variant
dim 		 pX  as variant
dim 		 pY  as variant
		' // b2Vec2 p = me.m_body1->m_position + b2Mul( me.m_body1->m_R, me.m_localAnchor1)
		tMat = me.m_body1.m_R
		 pX  = me.m_body1.m_position.x + (tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y)

		 pY  = me.m_body1.m_position.y + (tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y)

		' // b2Vec2 s = me.m_ground->m_position + me.m_groundAnchor1
		' // b2Vec2 d = p - s
		 dX  = pX - ( me.m_ground.m_position.x + me.m_groundAnchor1.x)

		 dY  = pY - ( me.m_ground.m_position.y + me.m_groundAnchor1.y)

		return sqrt(dX*dX + dY*dY)
end

public  sub 	GetLength2() as variant ''funcion
dim 		tMat  as variant
dim 		 dX  as variant
dim 		 dY  as variant
dim 		 pX  as variant
dim 		 pY  as variant
		' // b2Vec2 p = me.m_body2->m_position + b2Mul( me.m_body2->m_R, me.m_localAnchor2)
		tMat = me.m_body2.m_R
		 pX   = me.m_body2.m_position.x + (tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y)

		 pY   = me.m_body2.m_position.y + (tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y)

		' // b2Vec2 s = me.m_ground->m_position + me.m_groundAnchor2
		' // b2Vec2 d = p - s
		 dX   = pX - ( me.m_ground.m_position.x + me.m_groundAnchor2.x)

		 dY   = pY - ( me.m_ground.m_position.y + me.m_groundAnchor2.y)

		return sqrt(dX*dX + dY*dY)
 
end

public  sub 	GetRatio() as variant ''funcion
		return me.m_ratio

end

	' // --------------- Internals Below -------------------

public  sub 	_new(def as variant)
dim 		tMat  as variant
dim 		tX  as variant
dim 		tY  as variant

dim 		 d1Len  as variant 
dim 		 d2Len  as variant
dim 		 length1  as variant
dim 		 length2  as variant

		' //  The constructor for b2Joint
		' //  initialize instance variables for references
		 me.m_node1 = new b2JointNode()
		 me.m_node2 = new b2JointNode()
		' // 
		 me.m_type = def.type
		 me.m_prev = null
		 me.m_next = null
		 me.m_body1 = def.body1
		 me.m_body2 = def.body2
		 me.m_collideConnected = def.collideConnected
		 me.m_islandFlag = false
		 me.m_userData = def.userData
		' // 
		' //  initialize instance variables for references
		 me.m_groundAnchor1 = new b2Vec2()
		 me.m_groundAnchor2 = new b2Vec2()
		 me.m_localAnchor1 = new b2Vec2()
		 me.m_localAnchor2 = new b2Vec2()
		 me.m_u1 = new b2Vec2()
		 me.m_u2 = new b2Vec2()
		' // 
		' //  parent
		' // super(def)
		 me.m_ground = me.m_body1.m_world.m_groundBody
		' // me.m_groundAnchor1 = def.groundPoint1 - me.m_ground.m_position
		 me.m_groundAnchor1.x = def.groundPoint1.x - me.m_ground.m_position.x
		 me.m_groundAnchor1.y = def.groundPoint1.y - me.m_ground.m_position.y
		' // me.m_groundAnchor2 = def.groundPoint2 - me.m_ground.m_position
		 me.m_groundAnchor2.x = def.groundPoint2.x - me.m_ground.m_position.x
		 me.m_groundAnchor2.y = def.groundPoint2.y - me.m_ground.m_position.y
		' // me.m_localAnchor1 = b2MulT( me.m_body1.m_R, def.anchorPoint1 - me.m_body1.m_position)
		tMat = me.m_body1.m_R
		tX = def.anchorPoint1.x - me.m_body1.m_position.x
		tY = def.anchorPoint1.y - me.m_body1.m_position.y
		 me.m_localAnchor1.x = tX*tMat.col1.x + tY*tMat.col1.y
		 me.m_localAnchor1.y = tX*tMat.col2.x + tY*tMat.col2.y
		' // me.m_localAnchor2 = b2MulT( me.m_body2.m_R, def.anchorPoint2 - me.m_body2.m_position)
		tMat = me.m_body2.m_R
		tX = def.anchorPoint2.x - me.m_body2.m_position.x
		tY = def.anchorPoint2.y - me.m_body2.m_position.y
		 me.m_localAnchor2.x = tX*tMat.col1.x + tY*tMat.col1.y
		 me.m_localAnchor2.y = tX*tMat.col2.x + tY*tMat.col2.y
		 me.m_ratio = def.ratio
		' // var d1 = def.groundPoint1 - def.anchorPoint1
		tX = def.groundPoint1.x - def.anchorPoint1.x
		tY = def.groundPoint1.y - def.anchorPoint1.y
		 d1Len = sqrt(tX*tX + tY*tY)

		' // var d2 = def.groundPoint2 - def.anchorPoint2
		tX = def.groundPoint2.x - def.anchorPoint2.x
		tY = def.groundPoint2.y - def.anchorPoint2.y
		 d2Len = sqrt(tX*tX + tY*tY)

		 length1 = b2Math.b2Max(0.5 * b2PulleyJoint.b2_minPulleyLength, d1Len)

		 length2 = b2Math.b2Max(0.5 * b2PulleyJoint.b2_minPulleyLength, d2Len)

		 me.m_constant = length1 + me.m_ratio * length2
		 me.m_maxLength1 = b2Math.b2Clamp(def.maxLength1, length1, me.m_constant - me.m_ratio * b2PulleyJoint.b2_minPulleyLength)
		 me.m_maxLength2 = b2Math.b2Clamp(def.maxLength2, length2, ( me.m_constant - b2PulleyJoint.b2_minPulleyLength) / me.m_ratio)
		 me.m_pulleyImpulse = 0.0
		 me.m_limitImpulse1 = 0.0
		 me.m_limitImpulse2 = 0.0
end

public  sub 	PrepareVelocitySolver()

dim 		 b1 as variant= me.m_body1

dim 		 b2  as variant = me.m_body2

dim 		tMat  as variant


dim 		 r1X  as variant 

dim 		 r1Y  as variant 


dim 		 r2X  as variant 

dim 		 r2Y  as variant 

		' // b2Vec2 p1 = b1->m_position + r1
dim 		 p1X  as variant 

dim 		 p1Y  as variant 

		' // b2Vec2 p2 = b2->m_position + r2
dim 		 p2X  as variant 

dim 		 p2Y  as variant 

		' // b2Vec2 s1 = me.m_ground->m_position + me.m_groundAnchor1
dim 		 s1X  as variant 

dim 		 s1Y  as variant 

	
dim 		 s2X  as variant 

dim 		 s2Y  as variant 


dim 		 length1  as variant 

dim 		 length2  as variant 



dim 		 cr1u1  as variant
dim 		 cr2u2  as variant

dim 		 P1X  as variant

dim 		 P1Y  as variant 

		
dim 		 P2X  as variant

dim 		 P2Y  as variant

		' // b2Vec2 r1 = b2Mul(b1->m_R, me.m_localAnchor1)
     tMat = b1.m_R
	 r1X   = tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y

	 r1Y   = tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y

		tMat = b2.m_R
	 r2X   = tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y

	 r2Y   = tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y

		' // b2Vec2 p1 = b1->m_position + r1
	 p1X   = b1.m_position.x + r1X

	 p1Y   = b1.m_position.y + r1Y

		' // b2Vec2 p2 = b2->m_position + r2
	 p2X   = b2.m_position.x + r2X

	 p2Y   = b2.m_position.y + r2Y

		' // b2Vec2 s1 = me.m_ground->m_position + me.m_groundAnchor1
	 s1X   = me.m_ground.m_position.x + me.m_groundAnchor1.x

	 s1Y   = me.m_ground.m_position.y + me.m_groundAnchor1.y

		' // b2Vec2 s2 = me.m_ground->m_position + me.m_groundAnchor2
	 s2X   = me.m_ground.m_position.x + me.m_groundAnchor2.x

	 s2Y   = me.m_ground.m_position.y + me.m_groundAnchor2.y

		' //  Get the pulley axes.
		' // me.m_u1 = p1 - s1
		 me.m_u1.Set(p1X - s1X, p1Y - s1Y)
		' // me.m_u2 = p2 - s2
		 me.m_u2.Set(p2X - s2X, p2Y - s2Y)
	 length1   = me.m_u1.Length()

	 length2   = me.m_u2.Length()

		if (length1 > b2Settings.b2_linearSlop) then
			' // me.m_u1 *= 1.0f / length1
			 me.m_u1.Multiply(1.0 / length1)
		else
			 me.m_u1.SetZero()
	    endif
	    
		if (length2 > b2Settings.b2_linearSlop) then 
			' // me.m_u2 *= 1.0f / length2 
			 me.m_u2.Multiply(1.0 / length2)
		else
			 me.m_u2.SetZero()
		endif
		
		if (length1 < me.m_maxLength1) then 
			 me.m_limitState1 = b2Joint.e_inactiveLimit
			 me.m_limitImpulse1 = 0.0
		else
			 me.m_limitState1 = b2Joint.e_atUpperLimit
			 me.m_limitPositionImpulse1 = 0.0
		endif
		
		if (length2 < me.m_maxLength2) then 
			 me.m_limitState2 = b2Joint.e_inactiveLimit 
			 me.m_limitImpulse2 = 0.0
		else
			 me.m_limitState2 = b2Joint.e_atUpperLimit
			 me.m_limitPositionImpulse2 = 0.0
		endif
		
		' //  Compute effective mass.
		' // var cr1u1 = b2Cross(r1, me.m_u1)
	 cr1u1   = r1X * me.m_u1.y - r1Y * me.m_u1.x

		' // var cr2u2 = b2Cross(r2, me.m_u2)
	 cr2u2   = r2X * me.m_u2.y - r2Y * me.m_u2.x

		 me.m_limitMass1 = b1.m_invMass + b1.m_invI * cr1u1 * cr1u1
		 me.m_limitMass2 = b2.m_invMass + b2.m_invI * cr2u2 * cr2u2
		 me.m_pulleyMass = me.m_limitMass1 + me.m_ratio * me.m_ratio * me.m_limitMass2
		' // b2Settings.b2Assert( me.m_limitMass1 > Number.MIN_VALUE)
		' // b2Settings.b2Assert( me.m_limitMass2 > Number.MIN_VALUE)
		' // b2Settings.b2Assert( me.m_pulleyMass > Number.MIN_VALUE)
		 me.m_limitMass1 = 1.0 / me.m_limitMass1
		 me.m_limitMass2 = 1.0 / me.m_limitMass2
		 me.m_pulleyMass = 1.0 / me.m_pulleyMass
		' //  Warm starting.
		' // b2Vec2 P1 = (- me.m_pulleyImpulse - me.m_limitImpulse1) * me.m_u1
	 P1X   = (- me.m_pulleyImpulse - me.m_limitImpulse1) * me.m_u1.x

	 P1Y   = (- me.m_pulleyImpulse - me.m_limitImpulse1) * me.m_u1.y

		' // b2Vec2 P2 = (- me.m_ratio * me.m_pulleyImpulse - me.m_limitImpulse2) * me.m_u2
	 P2X   = (- me.m_ratio * me.m_pulleyImpulse - me.m_limitImpulse2) * me.m_u2.x

	 P2Y   = (- me.m_ratio * me.m_pulleyImpulse - me.m_limitImpulse2) * me.m_u2.y

		' // b1.m_linearVelocity += b1.m_invMass * P1
		b1.m_linearVelocity.x += b1.m_invMass * P1X
		b1.m_linearVelocity.y += b1.m_invMass * P1Y
		' // b1.m_angularVelocity += b1.m_invI * b2Cross(r1, P1)
		b1.m_angularVelocity += b1.m_invI * (r1X * P1Y - r1Y * P1X)
		' // b2.m_linearVelocity += b2.m_invMass * P2
		b2.m_linearVelocity.x += b2.m_invMass * P2X
		b2.m_linearVelocity.y += b2.m_invMass * P2Y
		' // b2.m_angularVelocity += b2.m_invI * b2Cross(r2, P2)
		b2.m_angularVelocity += b2.m_invI * (r2X * P2Y - r2Y * P2X)
end

public  sub 	SolveVelocityConstraints(step as variant)

dim 		 b1  as variant = me.m_body1

dim 		 b2  as variant = me.m_body2

dim 		tMat  as variant


		' //  temp vars
dim 		v1X  as variant
dim 		v1Y  as variant
dim 		v2X  as variant
dim 		v2Y  as variant
dim 		P1X  as variant
dim 		P1Y  as variant
dim 		P2X  as variant
dim 		P2Y  as variant
dim 		Cdot  as variant
dim 		impulse  as variant
dim 		oldLimitImpulse  as variant


dim 		 r1X  as variant 
dim 		 r1Y  as variant
dim 		 r2X  as variant
dim 		 r2Y  as variant
		' // var r1 = b2Mul(b1.m_R, me.m_localAnchor1)
		tMat = b1.m_R
		 r1X  = tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y

		 r1Y  = tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y

		' // var r2 = b2Mul(b2.m_R, me.m_localAnchor2)
		tMat = b2.m_R
		 r2X  = tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y

		 r2Y  = tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y


		' // 
			' // b2Vec2 v1 = b1->m_linearVelocity + b2Cross(b1->m_angularVelocity, r1)
			v1X = b1.m_linearVelocity.x + (-b1.m_angularVelocity * r1Y)
			v1Y = b1.m_linearVelocity.y + (b1.m_angularVelocity * r1X)
			' // b2Vec2 v2 = b2->m_linearVelocity + b2Cross(b2->m_angularVelocity, r2)
			v2X = b2.m_linearVelocity.x + (-b2.m_angularVelocity * r2Y)
			v2Y = b2.m_linearVelocity.y + (b2.m_angularVelocity * r2X)
			' // Cdot = -b2Dot( me.m_u1, v1) - me.m_ratio * b2Dot( me.m_u2, v2)
			Cdot = -( me.m_u1.x * v1X + me.m_u1.y * v1Y) - me.m_ratio * ( me.m_u2.x * v2X + me.m_u2.y * v2Y)
			impulse = - me.m_pulleyMass * Cdot
			 me.m_pulleyImpulse += impulse
			' // b2Vec2 P1 = -impulse * me.m_u1
			P1X = -impulse * me.m_u1.x
			P1Y = -impulse * me.m_u1.y
			' // b2Vec2 P2 = - me.m_ratio * impulse * me.m_u2
			P2X = - me.m_ratio * impulse * me.m_u2.x
			P2Y = - me.m_ratio * impulse * me.m_u2.y
			' // b1.m_linearVelocity += b1.m_invMass * P1
			b1.m_linearVelocity.x += b1.m_invMass * P1X
			b1.m_linearVelocity.y += b1.m_invMass * P1Y
			' // b1.m_angularVelocity += b1.m_invI * b2Cross(r1, P1)
			b1.m_angularVelocity += b1.m_invI * (r1X * P1Y - r1Y * P1X)
			' // b2.m_linearVelocity += b2.m_invMass * P2
			b2.m_linearVelocity.x += b2.m_invMass * P2X
			b2.m_linearVelocity.y += b2.m_invMass * P2Y
			' // b2.m_angularVelocity += b2.m_invI * b2Cross(r2, P2)
			b2.m_angularVelocity += b2.m_invI * (r2X * P2Y - r2Y * P2X)
		' // 
		if ( me.m_limitState1 = b2Joint.e_atUpperLimit) then 
			' // b2Vec2 v1 = b1->m_linearVelocity + b2Cross(b1->m_angularVelocity, r1)
			v1X = b1.m_linearVelocity.x + (-b1.m_angularVelocity * r1Y)
			v1Y = b1.m_linearVelocity.y + (b1.m_angularVelocity * r1X)
			' // float32 Cdot = -b2Dot( me.m_u1, v1)
			Cdot = -( me.m_u1.x * v1X + me.m_u1.y * v1Y)
			impulse = - me.m_limitMass1 * Cdot
			oldLimitImpulse = me.m_limitImpulse1
			 me.m_limitImpulse1 = b2Math.b2Max(0.0, me.m_limitImpulse1 + impulse)
			impulse = me.m_limitImpulse1 - oldLimitImpulse
			' // b2Vec2 P1 = -impulse * me.m_u1
			P1X = -impulse * me.m_u1.x
			P1Y = -impulse * me.m_u1.y
			' // b1.m_linearVelocity += b1->m_invMass * P1
			b1.m_linearVelocity.x += b1.m_invMass * P1X
			b1.m_linearVelocity.y += b1.m_invMass * P1Y
			' // b1.m_angularVelocity += b1->m_invI * b2Cross(r1, P1)
			b1.m_angularVelocity += b1.m_invI * (r1X * P1Y - r1Y * P1X)
		endif
		
		if ( me.m_limitState2 = b2Joint.e_atUpperLimit) then 
			' // b2Vec2 v2 = b2->m_linearVelocity + b2Cross(b2->m_angularVelocity, r2)
			v2X = b2.m_linearVelocity.x + (-b2.m_angularVelocity * r2Y)
			v2Y = b2.m_linearVelocity.y + (b2.m_angularVelocity * r2X)
			' // float32 Cdot = -b2Dot( me.m_u2, v2)
			Cdot = -( me.m_u2.x * v2X + me.m_u2.y * v2Y)
			impulse = - me.m_limitMass2 * Cdot
			oldLimitImpulse = me.m_limitImpulse2
			 me.m_limitImpulse2 = b2Math.b2Max(0.0, me.m_limitImpulse2 + impulse)
			impulse = me.m_limitImpulse2 - oldLimitImpulse
			' // b2Vec2 P2 = -impulse * me.m_u2
			P2X = -impulse * me.m_u2.x
			P2Y = -impulse * me.m_u2.y
			' // b2->m_linearVelocity += b2->m_invMass * P2
			b2.m_linearVelocity.x += b2.m_invMass * P2X
			b2.m_linearVelocity.y += b2.m_invMass * P2Y
			' // b2->m_angularVelocity += b2->m_invI * b2Cross(r2, P2)
			b2.m_angularVelocity += b2.m_invI * (r2X * P2Y - r2Y * P2X)
		endif
		
end

public  sub 	SolvePositionConstraints() as variant ''funcion
dim 		 b1  as variant = me.m_body1

dim 		 b2  as variant = me.m_body2

dim 		tMat  as variant
		' // b2Vec2 s1 = me.m_ground->m_position + me.m_groundAnchor1
dim 		 s1X  as variant = me.m_ground.m_position.x + me.m_groundAnchor1.x

dim 		 s1Y  as variant = me.m_ground.m_position.y + me.m_groundAnchor1.y

		' // b2Vec2 s2 = me.m_ground->m_position + me.m_groundAnchor2
dim 		 s2X  as variant = me.m_ground.m_position.x + me.m_groundAnchor2.x

dim 		 s2Y  as variant = me.m_ground.m_position.y + me.m_groundAnchor2.y

		' //  temp vars
dim 		r1X  as variant
dim 		r1Y  as variant
dim 		r2X  as variant
dim 		r2Y  as variant
dim 		p1X  as variant
dim 		p1Y  as variant
dim 		p2X  as variant
dim 		p2Y  as variant
dim 		length1  as variant
dim 		length2  as variant
dim 		C  as variant
dim 		impulse  as variant
dim 		oldLimitPositionImpulse  as variant
dim 		 linearError  as variant = 0.0

			' // var r1 = b2Mul(b1.m_R, me.m_localAnchor1)
			tMat = b1.m_R
			r1X = tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y
			r1Y = tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y
			' // var r2 = b2Mul(b2.m_R, me.m_localAnchor2)
			tMat = b2.m_R
			r2X = tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y
			r2Y = tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y
			' // b2Vec2 p1 = b1->m_position + r1
			p1X = b1.m_position.x + r1X
			p1Y = b1.m_position.y + r1Y
			' // b2Vec2 p2 = b2->m_position + r2
			p2X = b2.m_position.x + r2X
			p2Y = b2.m_position.y + r2Y
			' //  Get the pulley axes.
			' // me.m_u1 = p1 - s1
			 me.m_u1.Set(p1X - s1X, p1Y - s1Y)
			' // me.m_u2 = p2 - s2
			 me.m_u2.Set(p2X - s2X, p2Y - s2Y)
			length1 = me.m_u1.Length()
			length2 = me.m_u2.Length()
			if (length1 > b2Settings.b2_linearSlop) then 
			
				' // me.m_u1 *= 1.0f / length1
				 me.m_u1.Multiply( 1.0 / length1 )
			
			else
			
				 me.m_u1.SetZero()
			endif
			
			if (length2 > b2Settings.b2_linearSlop) then 
			
				' // me.m_u2 *= 1.0f / length2
				 me.m_u2.Multiply( 1.0 / length2 )
			
			else
			
				 me.m_u2.SetZero()
			endif
			
			C = me.m_constant - length1 - me.m_ratio * length2
			linearError = b2Math.b2Max(linearError, Math.abs(C))
			C = b2Math.b2Clamp(C, -b2Settings.b2_maxLinearCorrection, b2Settings.b2_maxLinearCorrection)
			impulse = - me.m_pulleyMass * C
			p1X = -impulse * me.m_u1.x
			p1Y = -impulse * me.m_u1.y
			p2X = - me.m_ratio * impulse * me.m_u2.x
			p2Y = - me.m_ratio * impulse * me.m_u2.y
			b1.m_position.x += b1.m_invMass * p1X
			b1.m_position.y += b1.m_invMass * p1Y
			b1.m_rotation += b1.m_invI * (r1X * p1Y - r1Y * p1X)
			b2.m_position.x += b2.m_invMass * p2X
			b2.m_position.y += b2.m_invMass * p2Y
			b2.m_rotation += b2.m_invI * (r2X * p2Y - r2Y * p2X)
			b1.m_R.Set(b1.m_rotation)
			b2.m_R.Set(b2.m_rotation)
		if ( me.m_limitState1 == b2Joint.e_atUpperLimit)
			' // b2Vec2 r1 = b2Mul(b1->m_R, me.m_localAnchor1)
			tMat = b1.m_R
			r1X = tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y
			r1Y = tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y
			' // b2Vec2 p1 = b1->m_position + r1
			p1X = b1.m_position.x + r1X
			p1Y = b1.m_position.y + r1Y
			' // me.m_u1 = p1 - s1
			 me.m_u1.Set(p1X - s1X, p1Y - s1Y)
			length1 = me.m_u1.Length()
			if (length1 > b2Settings.b2_linearSlop)
			
				' // me.m_u1 *= 1.0 / length1
				 me.m_u1.x *= 1.0 / length1
				 me.m_u1.y *= 1.0 / length1
			
			else
			
				 me.m_u1.SetZero()
			
			C = me.m_maxLength1 - length1
			linearError = b2Math.b2Max(linearError, -C)
			C = b2Math.b2Clamp(C + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0.0)
			impulse = - me.m_limitMass1 * C
			oldLimitPositionImpulse = me.m_limitPositionImpulse1
			 me.m_limitPositionImpulse1 = b2Math.b2Max(0.0, me.m_limitPositionImpulse1 + impulse)
			impulse = me.m_limitPositionImpulse1 - oldLimitPositionImpulse
			' // P1 = -impulse * me.m_u1
			p1X = -impulse * me.m_u1.x
			p1Y = -impulse * me.m_u1.y
			b1.m_position.x += b1.m_invMass * p1X
			b1.m_position.y += b1.m_invMass * p1Y
			' // b1.m_rotation += b1.m_invI * b2Cross(r1, P1)
			b1.m_rotation += b1.m_invI * (r1X * p1Y - r1Y * p1X)
			b1.m_R.Set(b1.m_rotation)
			endif
			
		if ( me.m_limitState2 = b2Joint.e_atUpperLimit) then 
			' // b2Vec2 r2 = b2Mul(b2->m_R, me.m_localAnchor2)
			tMat = b2.m_R
			r2X = tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y
			r2Y = tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y
			' // b2Vec2 p2 = b2->m_position + r2
			p2X = b2.m_position.x + r2X
			p2Y = b2.m_position.y + r2Y
			' // me.m_u2 = p2 - s2
			 me.m_u2.Set(p2X - s2X, p2Y - s2Y)
			length2 = me.m_u2.Length()
			if (length2 > b2Settings.b2_linearSlop) then 
			
				' // me.m_u2 *= 1.0 / length2
				 me.m_u2.x *= 1.0 / length2
				 me.m_u2.y *= 1.0 / length2
			
			else
			
				 me.m_u2.SetZero()
			endif
			
			C = me.m_maxLength2 - length2
			linearError = b2Math.b2Max(linearError, -C)
			C = b2Math.b2Clamp(C + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0.0)
			impulse = - me.m_limitMass2 * C
			oldLimitPositionImpulse = me.m_limitPositionImpulse2
			 me.m_limitPositionImpulse2 = b2Math.b2Max(0.0, me.m_limitPositionImpulse2 + impulse)
			impulse = me.m_limitPositionImpulse2 - oldLimitPositionImpulse
			' // P2 = -impulse * me.m_u2
			p2X = -impulse * me.m_u2.x
			p2Y = -impulse * me.m_u2.y
			' // b2.m_position += b2.m_invMass * P2
			b2.m_position.x += b2.m_invMass * p2X
			b2.m_position.y += b2.m_invMass * p2Y
			' // b2.m_rotation += b2.m_invI * b2Cross(r2, P2)
			b2.m_rotation += b2.m_invI * (r2X * p2Y - r2Y * p2X)
			b2.m_R.Set(b2.m_rotation)
		endif
		
return linearError < b2Settings.b2_linearSlop

end
