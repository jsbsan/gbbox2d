' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2PulleyJoint  as variant = Class.create()

inherits , b2Joint
inherits 
end

public  sub 	GetAnchor1() as variant ''funcio as variant ''funcion
		' // return me.m_body1->m_position + b2Mul( me.m_body1->m_R, me.m_localAnchor1)
 '' TODO: posible funcion (revisar)

dim 		 tMat  as variant = me.m_body1.m_R

		return new b2Vec2(	 me.m_body1.m_position.x + (tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y), '' TODO: posible funcion (revisar)

							 me.m_body1.m_position.y + (tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y))
end

public  sub 	GetAnchor2() as variant ''funcio as variant ''funcion
		' // return me.m_body2->m_position + b2Mul( me.m_body2->m_R, me.m_localAnchor2)
 '' TODO: posible funcion (revisar)

dim 		 tMat  as variant = me.m_body2.m_R

		return new b2Vec2(	 me.m_body2.m_position.x + (tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y), '' TODO: posible funcion (revisar)

							 me.m_body2.m_position.y + (tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y))
end

public  sub 	GetGroundPoint1() as variant ''funcio as variant ''funcion
		' // return me.m_ground->m_position + me.m_groundAnchor1
 '' TODO: posible funcion (revisar)

		return new b2Vec2( me.m_ground.m_position.x + me.m_groundAnchor1.x, me.m_ground.m_position.y + me.m_groundAnchor1.y)
 '' TODO: posible funcion (revisar)

end

public  sub 	GetGroundPoint2() as variant ''funcion
		return new b2Vec2( me.m_ground.m_position.x + me.m_groundAnchor2.x, me.m_ground.m_position.y + me.m_groundAnchor2.y)
 '' TODO: posible funcion (revisar)

end

public  sub 	GetReactionForce(invTimeStep as variant) as variant ''funcion
		' // b2Vec2 F(0.0f, 0.0f)
		return new b2Vec2()
 '' TODO: posible funcion (revisar)

end

public  sub 	GetReactionTorque(invTimeStep as variant) as variant ''funcion
		return 0.0
 '' TODO: posible funcion (revisar)

end

public  sub 	GetLength1() as variant ''funcion
dim 		tMat
 as variant
		' // b2Vec2 p = me.m_body1->m_position + b2Mul( me.m_body1->m_R, me.m_localAnchor1)
		tMat = me.m_body1.m_R
dim 		 pX  as variant = me.m_body1.m_position.x + (tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y)

dim 		 pY  as variant = me.m_body1.m_position.y + (tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y)

		' // b2Vec2 s = me.m_ground->m_position + me.m_groundAnchor1
		' // b2Vec2 d = p - s
dim 		 dX  as variant = pX - ( me.m_ground.m_position.x + me.m_groundAnchor1.x)

dim 		 dY  as variant = pY - ( me.m_ground.m_position.y + me.m_groundAnchor1.y)

		return Math.sqrt(dX*dX + dY*dY)
 '' TODO: posible funcion (revisar)

end

public  sub 	GetLength2() as variant ''funcion
dim 		tMat
 as variant
		' // b2Vec2 p = me.m_body2->m_position + b2Mul( me.m_body2->m_R, me.m_localAnchor2)
		tMat = me.m_body2.m_R
dim 		 pX  as variant = me.m_body2.m_position.x + (tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y)

dim 		 pY  as variant = me.m_body2.m_position.y + (tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y)

		' // b2Vec2 s = me.m_ground->m_position + me.m_groundAnchor2
		' // b2Vec2 d = p - s
dim 		 dX  as variant = pX - ( me.m_ground.m_position.x + me.m_groundAnchor2.x)

dim 		 dY  as variant = pY - ( me.m_ground.m_position.y + me.m_groundAnchor2.y)

		return Math.sqrt(dX*dX + dY*dY)
 '' TODO: posible funcion (revisar)

end

public  sub 	GetRatio() as variant ''funcion
		return me.m_ratio
 '' TODO: posible funcion (revisar)

	' // --------------- Internals Below -------------------
end

public  sub 	initialize(def as variant)

		' //  The constructor for b2Joint
		' //  initialize instance variables for references
		 me.m_node1 = new b2JointNode()
		 me.m_node2 = new b2JointNode()
		' // 
		 me.m_type = def.type
		 me.m_prev = null
		 me.m_next = null
		 me.m_body1 = def.body1
		 me.m_body2 = def.body2
		 me.m_collideConnected = def.collideConnected
		 me.m_islandFlag = false
		 me.m_userData = def.userData
		' // 
		' //  initialize instance variables for references
		 me.m_groundAnchor1 = new b2Vec2()
		 me.m_groundAnchor2 = new b2Vec2()
		 me.m_localAnchor1 = new b2Vec2()
		 me.m_localAnchor2 = new b2Vec2()
		 me.m_u1 = new b2Vec2()
		 me.m_u2 = new b2Vec2()
		' // 
		' //  parent
		' // super(def)
dim 		tMat
 as variant
dim 		tX
 as variant
dim 		tY
 as variant
		 me.m_ground = me.m_body1.m_world.m_groundBody
		' // me.m_groundAnchor1 = def.groundPoint1 - me.m_ground.m_position
		 me.m_groundAnchor1.x = def.groundPoint1.x - me.m_ground.m_position.x
		 me.m_groundAnchor1.y = def.groundPoint1.y - me.m_ground.m_position.y
		' // me.m_groundAnchor2 = def.groundPoint2 - me.m_ground.m_position
		 me.m_groundAnchor2.x = def.groundPoint2.x - me.m_ground.m_position.x
		 me.m_groundAnchor2.y = def.groundPoint2.y - me.m_ground.m_position.y
		' // me.m_localAnchor1 = b2MulT( me.m_body1.m_R, def.anchorPoint1 - me.m_body1.m_position)
		tMat = me.m_body1.m_R
		tX = def.anchorPoint1.x - me.m_body1.m_position.x
		tY = def.anchorPoint1.y - me.m_body1.m_position.y
		 me.m_localAnchor1.x = tX*tMat.col1.x + tY*tMat.col1.y
		 me.m_localAnchor1.y = tX*tMat.col2.x + tY*tMat.col2.y
		' // me.m_localAnchor2 = b2MulT( me.m_body2.m_R, def.anchorPoint2 - me.m_body2.m_position)
		tMat = me.m_body2.m_R
		tX = def.anchorPoint2.x - me.m_body2.m_position.x
		tY = def.anchorPoint2.y - me.m_body2.m_position.y
		 me.m_localAnchor2.x = tX*tMat.col1.x + tY*tMat.col1.y
		 me.m_localAnchor2.y = tX*tMat.col2.x + tY*tMat.col2.y
		 me.m_ratio = def.ratio
		' // var d1 = def.groundPoint1 - def.anchorPoint1
		tX = def.groundPoint1.x - def.anchorPoint1.x
		tY = def.groundPoint1.y - def.anchorPoint1.y
dim 		 d1Len  as variant = Math.sqrt(tX*tX + tY*tY)

		' // var d2 = def.groundPoint2 - def.anchorPoint2
		tX = def.groundPoint2.x - def.anchorPoint2.x
		tY = def.groundPoint2.y - def.anchorPoint2.y
dim 		 d2Len  as variant = Math.sqrt(tX*tX + tY*tY)

dim 		 length1  as variant = b2Math.b2Max(0.5 * b2PulleyJoint.b2_minPulleyLength, d1Len)

dim 		 length2  as variant = b2Math.b2Max(0.5 * b2PulleyJoint.b2_minPulleyLength, d2Len)

		 me.m_constant = length1 + me.m_ratio * length2
		 me.m_maxLength1 = b2Math.b2Clamp(def.maxLength1, length1, me.m_constant - me.m_ratio * b2PulleyJoint.b2_minPulleyLength)
		 me.m_maxLength2 = b2Math.b2Clamp(def.maxLength2, length2, ( me.m_constant - b2PulleyJoint.b2_minPulleyLength) / me.m_ratio)
		 me.m_pulleyImpulse = 0.0
		 me.m_limitImpulse1 = 0.0
		 me.m_limitImpulse2 = 0.0
end

public  sub 	PrepareVelocitySolver()

dim 		 b1  as variant = me.m_body1

dim 		 b2  as variant = me.m_body2

dim 		tMat
 as variant
		' // b2Vec2 r1 = b2Mul(b1->m_R, me.m_localAnchor1)
		tMat = b1.m_R
dim 		 r1X  as variant = tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y

dim 		 r1Y  as variant = tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y

		' // b2Vec2 r2 = b2Mul(b2->m_R, me.m_localAnchor2)
		tMat = b2.m_R
dim 		 r2X  as variant = tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y

dim 		 r2Y  as variant = tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y

		' // b2Vec2 p1 = b1->m_position + r1
dim 		 p1X  as variant = b1.m_position.x + r1X

dim 		 p1Y  as variant = b1.m_position.y + r1Y

		' // b2Vec2 p2 = b2->m_position + r2
dim 		 p2X  as variant = b2.m_position.x + r2X

dim 		 p2Y  as variant = b2.m_position.y + r2Y

		' // b2Vec2 s1 = me.m_ground->m_position + me.m_groundAnchor1
dim 		 s1X  as variant = me.m_ground.m_position.x + me.m_groundAnchor1.x

dim 		 s1Y  as variant = me.m_ground.m_position.y + me.m_groundAnchor1.y

		' // b2Vec2 s2 = me.m_ground->m_position + me.m_groundAnchor2
dim 		 s2X  as variant = me.m_ground.m_position.x + me.m_groundAnchor2.x

dim 		 s2Y  as variant = me.m_ground.m_position.y + me.m_groundAnchor2.y

		' //  Get the pulley axes.
		' // me.m_u1 = p1 - s1
		 me.m_u1.Set(p1X - s1X, p1Y - s1Y)
		' // me.m_u2 = p2 - s2
		 me.m_u2.Set(p2X - s2X, p2Y - s2Y)
dim 		 length1  as variant = me.m_u1.Length()

dim 		 length2  as variant = me.m_u2.Length()

		if (length1 > b2Settings.b2_linearSlop)
			' // me.m_u1 *= 1.0f / length1
			 me.m_u1.Multiply(1.0 / length1)
		else
			 me.m_u1.SetZero()
		if (length2 > b2Settings.b2_linearSlop)
			' // me.m_u2 *= 1.0f / length2
			 me.m_u2.Multiply(1.0 / length2)
		else
			 me.m_u2.SetZero()
		if (length1 < me.m_maxLength1)
			 me.m_limitState1 = b2Joint.e_inactiveLimit
			 me.m_limitImpulse1 = 0.0
		else
			 me.m_limitState1 = b2Joint.e_atUpperLimit
			 me.m_limitPositionImpulse1 = 0.0
		if (length2 < me.m_maxLength2)
			 me.m_limitState2 = b2Joint.e_inactiveLimit
			 me.m_limitImpulse2 = 0.0
		else
			 me.m_limitState2 = b2Joint.e_atUpperLimit
			 me.m_limitPositionImpulse2 = 0.0
		' //  Compute effective mass.
		' // var cr1u1 = b2Cross(r1, me.m_u1)
dim 		 cr1u1  as variant = r1X * me.m_u1.y - r1Y * me.m_u1.x

		' // var cr2u2 = b2Cross(r2, me.m_u2)
dim 		 cr2u2  as variant = r2X * me.m_u2.y - r2Y * me.m_u2.x

		 me.m_limitMass1 = b1.m_invMass + b1.m_invI * cr1u1 * cr1u1
		 me.m_limitMass2 = b2.m_invMass + b2.m_invI * cr2u2 * cr2u2
		 me.m_pulleyMass = me.m_limitMass1 + me.m_ratio * me.m_ratio * me.m_limitMass2
		' // b2Settings.b2Assert( me.m_limitMass1 > Number.MIN_VALUE)
		' // b2Settings.b2Assert( me.m_limitMass2 > Number.MIN_VALUE)
		' // b2Settings.b2Assert( me.m_pulleyMass > Number.MIN_VALUE)
		 me.m_limitMass1 = 1.0 / me.m_limitMass1
		 me.m_limitMass2 = 1.0 / me.m_limitMass2
		 me.m_pulleyMass = 1.0 / me.m_pulleyMass
		' //  Warm starting.
		' // b2Vec2 P1 = (- me.m_pulleyImpulse - me.m_limitImpulse1) * me.m_u1
dim 		 P1X  as variant = (- me.m_pulleyImpulse - me.m_limitImpulse1) * me.m_u1.x

dim 		 P1Y  as variant = (- me.m_pulleyImpulse - me.m_limitImpulse1) * me.m_u1.y

		' // b2Vec2 P2 = (- me.m_ratio * me.m_pulleyImpulse - me.m_limitImpulse2) * me.m_u2
dim 		 P2X  as variant = (- me.m_ratio * me.m_pulleyImpulse - me.m_limitImpulse2) * me.m_u2.x

dim 		 P2Y  as variant = (- me.m_ratio * me.m_pulleyImpulse - me.m_limitImpulse2) * me.m_u2.y

		' // b1.m_linearVelocity += b1.m_invMass * P1
		b1.m_linearVelocity.x += b1.m_invMass * P1X
		b1.m_linearVelocity.y += b1.m_invMass * P1Y
		' // b1.m_angularVelocity += b1.m_invI * b2Cross(r1, P1)
		b1.m_angularVelocity += b1.m_invI * (r1X * P1Y - r1Y * P1X)
		' // b2.m_linearVelocity += b2.m_invMass * P2
		b2.m_linearVelocity.x += b2.m_invMass * P2X
		b2.m_linearVelocity.y += b2.m_invMass * P2Y
		' // b2.m_angularVelocity += b2.m_invI * b2Cross(r2, P2)
		b2.m_angularVelocity += b2.m_invI * (r2X * P2Y - r2Y * P2X)
end

public  sub 	SolveVelocityConstraints(step as variant)

dim 		 b1  as variant = me.m_body1

dim 		 b2  as variant = me.m_body2

dim 		tMat
 as variant
		' // var r1 = b2Mul(b1.m_R, me.m_localAnchor1)
		tMat = b1.m_R
dim 		 r1X  as variant = tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y

dim 		 r1Y  as variant = tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y

		' // var r2 = b2Mul(b2.m_R, me.m_localAnchor2)
		tMat = b2.m_R
dim 		 r2X  as variant = tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y

dim 		 r2Y  as variant = tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y

		' //  temp vars
dim 		v1X
 as variant
dim 		v1Y
 as variant
dim 		v2X
 as variant
dim 		v2Y
 as variant
dim 		P1X
 as variant
dim 		P1Y
 as variant
dim 		P2X
 as variant
dim 		P2Y
 as variant
dim 		Cdot
 as variant
dim 		impulse
 as variant
dim 		oldLimitImpulse
 as variant
		' // 
			' // b2Vec2 v1 = b1->m_linearVelocity + b2Cross(b1->m_angularVelocity, r1)
			v1X = b1.m_linearVelocity.x + (-b1.m_angularVelocity * r1Y)
			v1Y = b1.m_linearVelocity.y + (b1.m_angularVelocity * r1X)
			' // b2Vec2 v2 = b2->m_linearVelocity + b2Cross(b2->m_angularVelocity, r2)
			v2X = b2.m_linearVelocity.x + (-b2.m_angularVelocity * r2Y)
			v2Y = b2.m_linearVelocity.y + (b2.m_angularVelocity * r2X)
			' // Cdot = -b2Dot( me.m_u1, v1) - me.m_ratio * b2Dot( me.m_u2, v2)
			Cdot = -( me.m_u1.x * v1X + me.m_u1.y * v1Y) - me.m_ratio * ( me.m_u2.x * v2X + me.m_u2.y * v2Y)
			impulse = - me.m_pulleyMass * Cdot
			 me.m_pulleyImpulse += impulse
			' // b2Vec2 P1 = -impulse * me.m_u1
			P1X = -impulse * me.m_u1.x
			P1Y = -impulse * me.m_u1.y
			' // b2Vec2 P2 = - me.m_ratio * impulse * me.m_u2
			P2X = - me.m_ratio * impulse * me.m_u2.x
			P2Y = - me.m_ratio * impulse * me.m_u2.y
			' // b1.m_linearVelocity += b1.m_invMass * P1
			b1.m_linearVelocity.x += b1.m_invMass * P1X
			b1.m_linearVelocity.y += b1.m_invMass * P1Y
			' // b1.m_angularVelocity += b1.m_invI * b2Cross(r1, P1)
			b1.m_angularVelocity += b1.m_invI * (r1X * P1Y - r1Y * P1X)
			' // b2.m_linearVelocity += b2.m_invMass * P2
			b2.m_linearVelocity.x += b2.m_invMass * P2X
			b2.m_linearVelocity.y += b2.m_invMass * P2Y
			' // b2.m_angularVelocity += b2.m_invI * b2Cross(r2, P2)
			b2.m_angularVelocity += b2.m_invI * (r2X * P2Y - r2Y * P2X)
		' // 
		if ( me.m_limitState1 == b2Joint.e_atUpperLimit)
			' // b2Vec2 v1 = b1->m_linearVelocity + b2Cross(b1->m_angularVelocity, r1)
			v1X = b1.m_linearVelocity.x + (-b1.m_angularVelocity * r1Y)
			v1Y = b1.m_linearVelocity.y + (b1.m_angularVelocity * r1X)
			' // float32 Cdot = -b2Dot( me.m_u1, v1)
			Cdot = -( me.m_u1.x * v1X + me.m_u1.y * v1Y)
			impulse = - me.m_limitMass1 * Cdot
			oldLimitImpulse = me.m_limitImpulse1
			 me.m_limitImpulse1 = b2Math.b2Max(0.0, me.m_limitImpulse1 + impulse)
			impulse = me.m_limitImpulse1 - oldLimitImpulse
			' // b2Vec2 P1 = -impulse * me.m_u1
			P1X = -impulse * me.m_u1.x
			P1Y = -impulse * me.m_u1.y
			' // b1.m_linearVelocity += b1->m_invMass * P1
			b1.m_linearVelocity.x += b1.m_invMass * P1X
			b1.m_linearVelocity.y += b1.m_invMass * P1Y
			' // b1.m_angularVelocity += b1->m_invI * b2Cross(r1, P1)
			b1.m_angularVelocity += b1.m_invI * (r1X * P1Y - r1Y * P1X)
		if ( me.m_limitState2 == b2Joint.e_atUpperLimit)
			' // b2Vec2 v2 = b2->m_linearVelocity + b2Cross(b2->m_angularVelocity, r2)
			v2X = b2.m_linearVelocity.x + (-b2.m_angularVelocity * r2Y)
			v2Y = b2.m_linearVelocity.y + (b2.m_angularVelocity * r2X)
			' // float32 Cdot = -b2Dot( me.m_u2, v2)
			Cdot = -( me.m_u2.x * v2X + me.m_u2.y * v2Y)
			impulse = - me.m_limitMass2 * Cdot
			oldLimitImpulse = me.m_limitImpulse2
			 me.m_limitImpulse2 = b2Math.b2Max(0.0, me.m_limitImpulse2 + impulse)
			impulse = me.m_limitImpulse2 - oldLimitImpulse
			' // b2Vec2 P2 = -impulse * me.m_u2
			P2X = -impulse * me.m_u2.x
			P2Y = -impulse * me.m_u2.y
			' // b2->m_linearVelocity += b2->m_invMass * P2
			b2.m_linearVelocity.x += b2.m_invMass * P2X
			b2.m_linearVelocity.y += b2.m_invMass * P2Y
			' // b2->m_angularVelocity += b2->m_invI * b2Cross(r2, P2)
			b2.m_angularVelocity += b2.m_invI * (r2X * P2Y - r2Y * P2X)
end

public  sub 	SolvePositionConstraints() as variant ''funcion
dim 		 b1  as variant = me.m_body1

dim 		 b2  as variant = me.m_body2

dim 		tMat
 as variant
		' // b2Vec2 s1 = me.m_ground->m_position + me.m_groundAnchor1
dim 		 s1X  as variant = me.m_ground.m_position.x + me.m_groundAnchor1.x

dim 		 s1Y  as variant = me.m_ground.m_position.y + me.m_groundAnchor1.y

		' // b2Vec2 s2 = me.m_ground->m_position + me.m_groundAnchor2
dim 		 s2X  as variant = me.m_ground.m_position.x + me.m_groundAnchor2.x

dim 		 s2Y  as variant = me.m_ground.m_position.y + me.m_groundAnchor2.y

		' //  temp vars
dim 		r1X
 as variant
dim 		r1Y
 as variant
dim 		r2X
 as variant
dim 		r2Y
 as variant
dim 		p1X
 as variant
dim 		p1Y
 as variant
dim 		p2X
 as variant
dim 		p2Y
 as variant
dim 		length1
 as variant
dim 		length2
 as variant
dim 		C
 as variant
dim 		impulse
 as variant
dim 		oldLimitPositionImpulse
 as variant
dim 		 linearError  as variant = 0.0

			' // var r1 = b2Mul(b1.m_R, me.m_localAnchor1)
			tMat = b1.m_R
			r1X = tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y
			r1Y = tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y
			' // var r2 = b2Mul(b2.m_R, me.m_localAnchor2)
			tMat = b2.m_R
			r2X = tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y
			r2Y = tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y
			' // b2Vec2 p1 = b1->m_position + r1
			p1X = b1.m_position.x + r1X
			p1Y = b1.m_position.y + r1Y
			' // b2Vec2 p2 = b2->m_position + r2
			p2X = b2.m_position.x + r2X
			p2Y = b2.m_position.y + r2Y
			' //  Get the pulley axes.
			' // me.m_u1 = p1 - s1
			 me.m_u1.Set(p1X - s1X, p1Y - s1Y)
			' // me.m_u2 = p2 - s2
			 me.m_u2.Set(p2X - s2X, p2Y - s2Y)
			length1 = me.m_u1.Length()
			length2 = me.m_u2.Length()
			if (length1 > b2Settings.b2_linearSlop)
			
				' // me.m_u1 *= 1.0f / length1
				 me.m_u1.Multiply( 1.0 / length1 )
			
			else
			
				 me.m_u1.SetZero()
			
			if (length2 > b2Settings.b2_linearSlop)
			
				' // me.m_u2 *= 1.0f / length2
				 me.m_u2.Multiply( 1.0 / length2 )
			
			else
			
				 me.m_u2.SetZero()
			
			C = me.m_constant - length1 - me.m_ratio * length2
			linearError = b2Math.b2Max(linearError, Math.abs(C))
			C = b2Math.b2Clamp(C, -b2Settings.b2_maxLinearCorrection, b2Settings.b2_maxLinearCorrection)
			impulse = - me.m_pulleyMass * C
			p1X = -impulse * me.m_u1.x
			p1Y = -impulse * me.m_u1.y
			p2X = - me.m_ratio * impulse * me.m_u2.x
			p2Y = - me.m_ratio * impulse * me.m_u2.y
			b1.m_position.x += b1.m_invMass * p1X
			b1.m_position.y += b1.m_invMass * p1Y
			b1.m_rotation += b1.m_invI * (r1X * p1Y - r1Y * p1X)
			b2.m_position.x += b2.m_invMass * p2X
			b2.m_position.y += b2.m_invMass * p2Y
			b2.m_rotation += b2.m_invI * (r2X * p2Y - r2Y * p2X)
			b1.m_R.Set(b1.m_rotation)
			b2.m_R.Set(b2.m_rotation)
		if ( me.m_limitState1 == b2Joint.e_atUpperLimit)
			' // b2Vec2 r1 = b2Mul(b1->m_R, me.m_localAnchor1)
			tMat = b1.m_R
			r1X = tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y
			r1Y = tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y
			' // b2Vec2 p1 = b1->m_position + r1
			p1X = b1.m_position.x + r1X
			p1Y = b1.m_position.y + r1Y
			' // me.m_u1 = p1 - s1
			 me.m_u1.Set(p1X - s1X, p1Y - s1Y)
			length1 = me.m_u1.Length()
			if (length1 > b2Settings.b2_linearSlop)
			
				' // me.m_u1 *= 1.0 / length1
				 me.m_u1.x *= 1.0 / length1
				 me.m_u1.y *= 1.0 / length1
			
			else
			
				 me.m_u1.SetZero()
			
			C = me.m_maxLength1 - length1
			linearError = b2Math.b2Max(linearError, -C)
			C = b2Math.b2Clamp(C + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0.0)
			impulse = - me.m_limitMass1 * C
			oldLimitPositionImpulse = me.m_limitPositionImpulse1
			 me.m_limitPositionImpulse1 = b2Math.b2Max(0.0, me.m_limitPositionImpulse1 + impulse)
			impulse = me.m_limitPositionImpulse1 - oldLimitPositionImpulse
			' // P1 = -impulse * me.m_u1
			p1X = -impulse * me.m_u1.x
			p1Y = -impulse * me.m_u1.y
			b1.m_position.x += b1.m_invMass * p1X
			b1.m_position.y += b1.m_invMass * p1Y
			' // b1.m_rotation += b1.m_invI * b2Cross(r1, P1)
			b1.m_rotation += b1.m_invI * (r1X * p1Y - r1Y * p1X)
			b1.m_R.Set(b1.m_rotation)
		if ( me.m_limitState2 == b2Joint.e_atUpperLimit)
			' // b2Vec2 r2 = b2Mul(b2->m_R, me.m_localAnchor2)
			tMat = b2.m_R
			r2X = tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y
			r2Y = tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y
			' // b2Vec2 p2 = b2->m_position + r2
			p2X = b2.m_position.x + r2X
			p2Y = b2.m_position.y + r2Y
			' // me.m_u2 = p2 - s2
			 me.m_u2.Set(p2X - s2X, p2Y - s2Y)
			length2 = me.m_u2.Length()
			if (length2 > b2Settings.b2_linearSlop)
			
				' // me.m_u2 *= 1.0 / length2
				 me.m_u2.x *= 1.0 / length2
				 me.m_u2.y *= 1.0 / length2
			
			else
			
				 me.m_u2.SetZero()
			
			C = me.m_maxLength2 - length2
			linearError = b2Math.b2Max(linearError, -C)
			C = b2Math.b2Clamp(C + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0.0)
			impulse = - me.m_limitMass2 * C
			oldLimitPositionImpulse = me.m_limitPositionImpulse2
			 me.m_limitPositionImpulse2 = b2Math.b2Max(0.0, me.m_limitPositionImpulse2 + impulse)
			impulse = me.m_limitPositionImpulse2 - oldLimitPositionImpulse
			' // P2 = -impulse * me.m_u2
			p2X = -impulse * me.m_u2.x
			p2Y = -impulse * me.m_u2.y
			' // b2.m_position += b2.m_invMass * P2
			b2.m_position.x += b2.m_invMass * p2X
			b2.m_position.y += b2.m_invMass * p2Y
			' // b2.m_rotation += b2.m_invI * b2Cross(r2, P2)
			b2.m_rotation += b2.m_invI * (r2X * p2Y - r2Y * p2X)
			b2.m_R.Set(b2.m_rotation)
		return linearError < b2Settings.b2_linearSlop
 '' TODO: posible funcion (revisar)

	m_ground: null
Public 1: new b2Vec2(), as new 2Vec2(),
Public 2: new b2Vec2(), as new 2Vec2(),
Public 1: new b2Vec2(), as new 2Vec2(),
Public 2: new b2Vec2(), as new 2Vec2(),
Public 1: new b2Vec2(), as new 2Vec2(),
Public 2: new b2Vec2(), as new 2Vec2(),
	m_constant: null
	m_ratio: null
	m_maxLength1: null
	m_maxLength2: null
	' //  Effective masses
	m_pulleyMass: null
	m_limitMass1: null
	m_limitMass2: null
	' //  Impulses for accumulation/warm starting.
	m_pulleyImpulse: null
	m_limitImpulse1: null
	m_limitImpulse2: null
	' //  Position impulses for accumulation.
	m_limitPositionImpulse1: null
	m_limitPositionImpulse2: null
	m_limitState1: 0
	m_limitState2: 0
	' //  static
)
b2PulleyJoint.b2_minPulleyLength = b2Settings.b2_lengthUnitsPerMeter