
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 ' you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  Linear constraint (point-to-line)
' //  d = p2 - p1 = x2 + r2 - x1 - r1
' //  C = dot(ay1, d)
' //  Cdot = dot(d, cross(w1, ay1)) + dot(ay1, v2 + cross(w2, r2) - v1 - cross(w1, r1))
' //       = -dot(ay1, v1) - dot(cross(d + r1, ay1), w1) + dot(ay1, v2) + dot(cross(r2, ay1), v2)
' //  J = [-ay1 -cross(d+r1,ay1) ay1 cross(r2,ay1)]
' // 
' //  Angular constraint
' //  C = a2 - a1 + a_initial
' //  Cdot = w2 - w1
' //  J = [0 0 -1 0 0 1]
' //  Motor/Limit linear constraint
' //  C = dot(ax1, d)
' //  Cdot = = -dot(ax1, v1) - dot(cross(d + r1, ax1), w1) + dot(ax1, v2) + dot(cross(r2, ax1), v2)
' //  J = [-ax1 -cross(d+r1,ax1) ax1 cross(r2,ax1)]

inherits  b2Joint

public m_localAnchor1 as variant= new b2Vec2()
public m_localAnchor2 as variant= new b2Vec2()
public m_localXAxis1 as variant= new b2Vec2()
public m_localYAxis1 as variant= new b2Vec2()
public m_initialAngle as variant= null

public m_linearJacobian as variant= new b2Jacobian()
public m_linearMass as variant= null
public m_linearImpulse as variant= null

public m_angularMass as variant= null
public m_angularImpulse as variant= null

public m_motorJacobian as variant= new b2Jacobian()
public m_motorMass as variant= null
public m_motorImpulse as variant= null
public m_limitImpulse as variant= null
public m_limitPositionImpulse as variant= null

public m_lowerTranslation as variant= null
public m_upperTranslation as variant= null
public m_maxMotorForce as variant= null
public m_motorSpeed as variant= null

public m_enableLimit as variant= null
public m_enableMotor as variant= null
public m_limitState as variant= 0



public  sub 	GetAnchor1()  as variant''funcio as variant ''funcion
dim 		 b1  as variant = me.m_body1

		' // return b2Math.AddVV(b1.m_position, b2Math.b2MulMV(b1.m_R, me.m_localAnchor1))

dim 		 tVec  as variant = new b2Vec2()

		tVec.SetV( me.m_localAnchor1)
		tVec.MulM(b1.m_R)
		tVec.Add(b1.m_position)
		return tVec
end

public  sub 	GetAnchor2() as variant ''funcio as variant ''funcion
dim 		 b2  as variant = me.m_body2

		' // return b2Math.AddVV(b2.m_position, b2Math.b2MulMV(b2.m_R, me.m_localAnchor2))
 '' TODO: posible funcion (revisar)

dim 		 tVec  as variant = new b2Vec2()

		tVec.SetV( me.m_localAnchor2)
		tVec.MulM(b2.m_R)
		tVec.Add(b2.m_position)
		return tVec

end

public  sub 	GetJointTranslation() as variant ''funcion
dim 		 b1  as variant = me.m_body1

dim 		 b2  as variant = me.m_body2

dim 		tMat as variant

dim 		 r1X  as variant
dim 		 r1Y  as variant


dim 		 r2X  as variant 
dim 		 r2Y  as variant
dim 		 p1X  as variant
dim 		 p1Y  as variant
dim 		 p2X  as variant
dim 		 p2Y  as variant
dim 		 dX  as variant 
dim 		 dY  as variant

dim 		 ax1X  as variant 
dim 		 ax1Y  as variant
dim 		 translation  as variant
		' // var r1 = b2Math.b2MulMV(b1.m_R, me.m_localAnchor1)
		tMat = b1.m_R
 		 r1X  = tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y

 		 r1Y = tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y

		' // var r2 = b2Math.b2MulMV(b2.m_R, me.m_localAnchor2)
		tMat = b2.m_R
	 r2X  = tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y

	 r2Y  = tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y

		' // var p1 = b2Math.AddVV(b1.m_position , r1)
	 p1X  = b1.m_position.x + r1X

	 p1Y  = b1.m_position.y + r1Y

		' // var p2 = b2Math.AddVV(b2.m_position , r2)
	 p2X  = b2.m_position.x + r2X

	 p2Y  = b2.m_position.y + r2Y

		' // var d = b2Math.SubtractVV(p2, p1)
	 dX  = p2X - p1X

	 dY  = p2Y - p1Y

		' // var ax1 = b2Math.b2MulMV(b1.m_R, me.m_localXAxis1)
		tMat = b1.m_R
	 ax1X  = tMat.col1.x * me.m_localXAxis1.x + tMat.col2.x * me.m_localXAxis1.y

	 ax1Y  = tMat.col1.y * me.m_localXAxis1.x + tMat.col2.y * me.m_localXAxis1.y

		' // var translation = b2Math.b2Dot(ax1, d)
	 translation  = ax1X*dX + ax1Y*dY

		return translation
 
end

public  sub 	GetJointSpeed() as variant ''funcion
dim 		 b1  as variant = me.m_body1

dim 		 b2  as variant = me.m_body2

dim 		tMat  as variant

dim 		 r1X  as variant
dim 		 r1Y  as variant 
dim 		 r2X  as variant 
dim 		 r2Y  as variant
dim 		 p1X  as variant
dim 		 p1Y  as variant
dim 		 p2X  as variant
dim 		 p2Y  as variant
dim 		 dX  as variant 
dim 		 dY  as variant

dim 		 ax1X  as variant 
dim 		 ax1Y  as variant
dim 		 v1  as variant
dim 		 v2  as variant
dim 		 w1  as variant
dim 		 w2  as variant
dim 		 speed  as variant

		' // var r1 = b2Math.b2MulMV(b1.m_R, me.m_localAnchor1)
		tMat = b1.m_R
	 r1X  = tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y

	 r1Y  = tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y

		' // var r2 = b2Math.b2MulMV(b2.m_R, me.m_localAnchor2)
		tMat = b2.m_R
	 r2X  = tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y

	 r2Y  = tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y

		' // var p1 = b2Math.AddVV(b1.m_position , r1)
	 p1X  = b1.m_position.x + r1X

	 p1Y  = b1.m_position.y + r1Y

		' // var p2 = b2Math.AddVV(b2.m_position , r2)
	 p2X  = b2.m_position.x + r2X

	 p2Y  = b2.m_position.y + r2Y

		' // var d = b2Math.SubtractVV(p2, p1)
	 dX  = p2X - p1X

	 dY  = p2Y - p1Y

		' // var ax1 = b2Math.b2MulMV(b1.m_R, me.m_localXAxis1)
		tMat = b1.m_R
	 ax1X  = tMat.col1.x * me.m_localXAxis1.x + tMat.col2.x * me.m_localXAxis1.y

	 ax1Y  = tMat.col1.y * me.m_localXAxis1.x + tMat.col2.y * me.m_localXAxis1.y

	 v1  = b1.m_linearVelocity

	 v2  = b2.m_linearVelocity

	 w1  = b1.m_angularVelocity

	 w2  = b2.m_angularVelocity

		' // var speed = b2Math.b2Dot(d, b2Math.b2CrossFV(w1, ax1)) + b2Math.b2Dot(ax1, b2Math.SubtractVV( b2Math.SubtractVV( b2Math.AddVV( v2 , b2Math.b2CrossFV(w2, r2)) , v1) , b2Math.b2CrossFV(w1, r1)))
		' // var b2D = (dX*(-w1 * ax1Y) + dY*(w1 * ax1X))
		' // var b2D2 = (ax1X * ((( v2.x + (-w2 * r2Y)) - v1.x) - (-w1 * r1Y)) + ax1Y * ((( v2.y + (w2 * r2X)) - v1.y) - (w1 * r1X)))
	 speed  = (dX*(-w1 * ax1Y) + dY*(w1 * ax1X)) + (ax1X * ((( v2.x + (-w2 * r2Y)) - v1.x) - (-w1 * r1Y)) + ax1Y * ((( v2.y + (w2 * r2X)) - v1.y) - (w1 * r1X)))

		return speed
 '' TODO: posible funcion (revisar)

end

public  sub 	GetMotorForce(invTimeStep as variant) as variant ''funcion
		return invTimeStep * me.m_motorImpulse
 '' TODO: posible funcion (revisar)

end

public  sub 	SetMotorSpeed(speed as variant)

		 me.m_motorSpeed = speed
end

public  sub 	SetMotorForce(force as variant)

		 me.m_maxMotorForce = force
end

public  sub 	GetReactionForce(invTimeStep as variant) as variant ''funcio as variant ''funcion
dim 		 tImp  as variant = invTimeStep * me.m_limitImpulse

dim 		tMat  as variant


dim 		 ax1X  as variant 
dim 		 ax1Y  as variant

dim 		 ay1X  as variant 
dim 		 ay1Y  as variant

		' // var ax1 = b2Math.b2MulMV( me.m_body1.m_R, me.m_localXAxis1)
		tMat = me.m_body1.m_R
		 ax1X  = tImp * (tMat.col1.x * me.m_localXAxis1.x + tMat.col2.x * me.m_localXAxis1.y)

		 ax1Y  = tImp * (tMat.col1.y * me.m_localXAxis1.x + tMat.col2.y * me.m_localXAxis1.y)

		' // var ay1 = b2Math.b2MulMV( me.m_body1.m_R, me.m_localYAxis1)
		 ay1X  = tImp * (tMat.col1.x * me.m_localYAxis1.x + tMat.col2.x * me.m_localYAxis1.y)

		 ay1Y  = tImp * (tMat.col1.y * me.m_localYAxis1.x + tMat.col2.y * me.m_localYAxis1.y)

		' // return (invTimeStep * me.m_limitImpulse) * ax1 + (invTimeStep * me.m_linearImpulse) * ay1
 '' TODO: posible funcion (revisar)

		return new b2Vec2(ax1X+ay1X, ax1Y+ay1Y)
 '' TODO: posible funcion (revisar)

end

public  sub 	GetReactionTorque(invTimeStep as variant) as variant ''funcion
		return invTimeStep * me.m_angularImpulse

end

	' // --------------- Internals Below -------------------

public  sub _new (def as variant)
		' // super(def)
dim 		tMat  as variant
dim 		tX  as variant
dim 		tY  as variant


		' //  The constructor for b2Joint
		' //  initialize instance variables for references
		 me.m_node1 = new b2JointNode()
		 me.m_node2 = new b2JointNode()
		' // 
		 me.m_type = def.type
		 me.m_prev = null
		 me.m_next = null
		 me.m_body1 = def.body1
		 me.m_body2 = def.body2
		 me.m_collideConnected = def.collideConnected
		 me.m_islandFlag = false
		 me.m_userData = def.userData
		' // 
		' //  initialize instance variables for references
		 me.m_localAnchor1 = new b2Vec2()
		 me.m_localAnchor2 = new b2Vec2()
		 me.m_localXAxis1 = new b2Vec2()
		 me.m_localYAxis1 = new b2Vec2()
		 me.m_linearJacobian = new b2Jacobian()
		 me.m_motorJacobian = new b2Jacobian()
		' // 
		' // me.m_localAnchor1 = b2Math.b2MulTMV( me.m_body1.m_R, b2Math.SubtractVV(def.anchorPoint , me.m_body1.m_position))
		tMat = me.m_body1.m_R
		tX = (def.anchorPoint.x - me.m_body1.m_position.x)
		tY = (def.anchorPoint.y - me.m_body1.m_position.y)
		 me.m_localAnchor1.Set((tX*tMat.col1.x + tY*tMat.col1.y), (tX*tMat.col2.x + tY*tMat.col2.y))
		' // me.m_localAnchor2 = b2Math.b2MulTMV( me.m_body2.m_R, b2Math.SubtractVV(def.anchorPoint , me.m_body2.m_position))
		tMat = me.m_body2.m_R
		tX = (def.anchorPoint.x - me.m_body2.m_position.x)
		tY = (def.anchorPoint.y - me.m_body2.m_position.y)
		 me.m_localAnchor2.Set((tX*tMat.col1.x + tY*tMat.col1.y), (tX*tMat.col2.x + tY*tMat.col2.y))
		' // me.m_localXAxis1 = b2Math.b2MulTMV( me.m_body1.m_R, def.axis)
		tMat = me.m_body1.m_R
		tX = def.axis.x
		tY = def.axis.y
		 me.m_localXAxis1.Set((tX*tMat.col1.x + tY*tMat.col1.y), (tX*tMat.col2.x + tY*tMat.col2.y))
		' // me.m_localYAxis1 = b2Math.b2CrossFV(1.0, me.m_localXAxis1)
		 me.m_localYAxis1.x = - me.m_localXAxis1.y
		 me.m_localYAxis1.y = me.m_localXAxis1.x
		 me.m_initialAngle = me.m_body2.m_rotation - me.m_body1.m_rotation
		 me.m_linearJacobian.SetZero()
		 me.m_linearMass = 0.0
		 me.m_linearImpulse = 0.0
		 me.m_angularMass = 0.0
		 me.m_angularImpulse = 0.0
		 me.m_motorJacobian.SetZero()
		 me.m_motorMass = 0.0
		 me.m_motorImpulse = 0.0
		 me.m_limitImpulse = 0.0
		 me.m_limitPositionImpulse = 0.0
		 me.m_lowerTranslation = def.lowerTranslation
		 me.m_upperTranslation = def.upperTranslation
		 me.m_maxMotorForce = def.motorForce
		 me.m_motorSpeed = def.motorSpeed
		 me.m_enableLimit = def.enableLimit
		 me.m_enableMotor = def.enableMotor
end

public  sub 	PrepareVelocitySolver()

dim 		 b1  as variant = me.m_body1

dim 		 b2  as variant = me.m_body2

dim 		tMat  as variant


dim 		 r1X  as variant
dim 		 r1Y  as variant
dim 		 r2X  as variant
dim 		 r2Y  as variant
dim 		 invMass1  as variant

dim 		 invMass2  as variant
dim 		 invI1  as variant
dim 		 invI2  as variant 
dim 		 ay1X  as variant 
dim 		 ay1Y  as variant
dim 		 eX  as variant
dim 		 eY  as variant
dim 			 ax1X  as variant
dim 			 ax1Y  as variant
dim 				 dX  as variant
dim 				 dY  as variant
dim 				 jointTranslation  as variant
dim 			 P1X  as variant
dim 			 P1Y  as variant
dim 			 P2X  as varian
dim 			 P2Y  as variant
dim 			 L1  as variant
dim 			 L2  as variant 
		' //  Compute the effective masses.
		' // b2Vec2 r1 = b2Mul(b1->m_R, me.m_localAnchor1)
		tMat = b1.m_R
		 r1X   = tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y

		 r1Y   = tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y

		' // b2Vec2 r2 = b2Mul(b2->m_R, me.m_localAnchor2)
		tMat = b2.m_R
		 r2X   = tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y

		 r2Y   = tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y

		' // float32 invMass1 = b1->m_invMass, invMass2 = b2->m_invMass
		 invMass1   = b1.m_invMass

		 invMass2   = b2.m_invMass

		' // float32 invI1 = b1->m_invI, invI2 = b2->m_invI
		 invI1   = b1.m_invI

		 invI2   = b2.m_invI

		' //  Compute point to line constraint effective mass.
		' //  J = [-ay1 -cross(d+r1,ay1) ay1 cross(r2,ay1)]
		' // b2Vec2 ay1 = b2Mul(b1->m_R, me.m_localYAxis1)
		tMat = b1.m_R
		 ay1X   = tMat.col1.x * me.m_localYAxis1.x + tMat.col2.x * me.m_localYAxis1.y

		 ay1Y   = tMat.col1.y * me.m_localYAxis1.x + tMat.col2.y * me.m_localYAxis1.y

		' // b2Vec2 e = b2->m_position + r2 - b1->m_position
		 eX   = b2.m_position.x + r2X - b1.m_position.x

		 eY   = b2.m_position.y + r2Y - b1.m_position.y

		' // me.m_linearJacobian.Set(-ay1, -b2Math.b2Cross(e, ay1), ay1, b2Math.b2Cross(r2, ay1))
		 me.m_linearJacobian.linear1.x = -ay1X
		 me.m_linearJacobian.linear1.y = -ay1Y
		 me.m_linearJacobian.linear2.x = ay1X
		 me.m_linearJacobian.linear2.y = ay1Y
		 me.m_linearJacobian.angular1 = -(eX * ay1Y - eY * ay1X)
		 me.m_linearJacobian.angular2 = r2X * ay1Y - r2Y * ay1X
		 me.m_linearMass =	invMass1 + invI1 * me.m_linearJacobian.angular1 * me.m_linearJacobian.angular1 +
						invMass2 + invI2 * me.m_linearJacobian.angular2 * me.m_linearJacobian.angular2
		' // b2Settings.b2Assert( me.m_linearMass > Number.MIN_VALUE)
		 me.m_linearMass = 1.0 / me.m_linearMass
		' //  Compute angular constraint effective mass.
		 me.m_angularMass = 1.0 / (invI1 + invI2)
		' //  Compute motor and limit terms.
		if ( me.m_enableLimit or me.m_enableMotor) then 
			' //  The motor and limit share a Jacobian and effective mass.
			' // b2Vec2 ax1 = b2Mul(b1->m_R, me.m_localXAxis1)
			tMat = b1.m_R
			 ax1X   = tMat.col1.x * me.m_localXAxis1.x + tMat.col2.x * me.m_localXAxis1.y

			 ax1Y   = tMat.col1.y * me.m_localXAxis1.x + tMat.col2.y * me.m_localXAxis1.y

			' // me.m_motorJacobian.Set(-ax1, -b2Cross(e, ax1), ax1, b2Cross(r2, ax1))
				 me.m_motorJacobian.linear1.x = -ax1X
	 			me.m_motorJacobian.linear1.y = -ax1Y
			 	me.m_motorJacobian.linear2.x = ax1X
 				me.m_motorJacobian.linear2.y = ax1Y
			 me.m_motorJacobian.angular1 = -(eX * ax1Y - eY * ax1X)
			 me.m_motorJacobian.angular2 = r2X * ax1Y - r2Y * ax1X
			 me.m_motorMass =	invMass1 + invI1 * me.m_motorJacobian.angular1 * me.m_motorJacobian.angular1 +
							invMass2 + invI2 * me.m_motorJacobian.angular2 * me.m_motorJacobian.angular2
			' // b2Settings.b2Assert( me.m_motorMass > Number.MIN_VALUE)
			 me.m_motorMass = 1.0 / me.m_motorMass
			if ( me.m_enableLimit) then
			
				' // b2Vec2 d = e - r1
				 dX   = eX - r1X

				 dY   = eY - r1Y

				' // float32 jointTranslation = b2Dot(ax1, d)
				 jointTranslation   = ax1X * dX + ax1Y * dY

				if (b2Math.b2Abs( me.m_upperTranslation - me.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) then 
				
					 me.m_limitState = b2Joint.e_equalLimits
				
				else if (jointTranslation <= me.m_lowerTranslation) then 
				
					if ( me.m_limitState != b2Joint.e_atLowerLimit)
					
						 me.m_limitImpulse = 0.0
					endif
					
					 me.m_limitState = b2Joint.e_atLowerLimit
				
				else if (jointTranslation >= me.m_upperTranslation)
				
					if ( me.m_limitState != b2Joint.e_atUpperLimit)
					
						 me.m_limitImpulse = 0.0
					endif
					
					 me.m_limitState = b2Joint.e_atUpperLimit
				
				else
				
					 me.m_limitState = b2Joint.e_inactiveLimit
					 me.m_limitImpulse = 0.0
				endif
			endif
		endif
				
			
		if ( me.m_enableMotor = false) then 
			 me.m_motorImpulse = 0.0
		endif
		
		if ( me.m_enableLimit = false) then 
			 me.m_limitImpulse = 0.0
		endif
		
		if (b2World.s_enableWarmStarting) then 
			' // b2Vec2 P1 = me.m_linearImpulse * me.m_linearJacobian.linear1 + ( me.m_motorImpulse + me.m_limitImpulse) * me.m_motorJacobian.linear1
			 P1X   = me.m_linearImpulse * me.m_linearJacobian.linear1.x + ( me.m_motorImpulse + me.m_limitImpulse) * me.m_motorJacobian.linear1.x

			 P1Y   = me.m_linearImpulse * me.m_linearJacobian.linear1.y + ( me.m_motorImpulse + me.m_limitImpulse) * me.m_motorJacobian.linear1.y

			' // b2Vec2 P2 = me.m_linearImpulse * me.m_linearJacobian.linear2 + ( me.m_motorImpulse + me.m_limitImpulse) * me.m_motorJacobian.linear2
			 P2X   = me.m_linearImpulse * me.m_linearJacobian.linear2.x + ( me.m_motorImpulse + me.m_limitImpulse) * me.m_motorJacobian.linear2.x

			 P2Y   = me.m_linearImpulse * me.m_linearJacobian.linear2.y + ( me.m_motorImpulse + me.m_limitImpulse) * me.m_motorJacobian.linear2.y

			' // float32 L1 = me.m_linearImpulse * me.m_linearJacobian.angular1 - me.m_angularImpulse + ( me.m_motorImpulse + me.m_limitImpulse) * me.m_motorJacobian.angular1
			 L1   = me.m_linearImpulse * me.m_linearJacobian.angular1 - me.m_angularImpulse + ( me.m_motorImpulse + me.m_limitImpulse) * me.m_motorJacobian.angular1

			' // float32 L2 = me.m_linearImpulse * me.m_linearJacobian.angular2 + me.m_angularImpulse + ( me.m_motorImpulse + me.m_limitImpulse) * me.m_motorJacobian.angular2
			 L2   = me.m_linearImpulse * me.m_linearJacobian.angular2 + me.m_angularImpulse + ( me.m_motorImpulse + me.m_limitImpulse) * me.m_motorJacobian.angular2

			' // b1->m_linearVelocity += invMass1 * P1
			b1.m_linearVelocity.x += invMass1 * P1X
			b1.m_linearVelocity.y += invMass1 * P1Y
			' // b1->m_angularVelocity += invI1 * L1
			b1.m_angularVelocity += invI1 * L1
			' // b2->m_linearVelocity += invMass2 * P2
			b2.m_linearVelocity.x += invMass2 * P2X
			b2.m_linearVelocity.y += invMass2 * P2Y
			' // b2->m_angularVelocity += invI2 * L2
			b2.m_angularVelocity += invI2 * L2
		else
			 me.m_linearImpulse = 0.0
			 me.m_angularImpulse = 0.0
			 me.m_limitImpulse = 0.0
			 me.m_motorImpulse = 0.0
		endif
		
	 me.m_limitPositionImpulse = 0.0
		
end

public  sub 	SolveVelocityConstraints(step as variant)

dim 		 b1  as variant = me.m_body1

dim 		 b2  as variant = me.m_body2

dim 		 invMass1  as variant = b1.m_invMass

dim 		 invMass2  as variant = b2.m_invMass

dim 		 invI1  as variant = b1.m_invI

dim 		 invI2  as variant = b2.m_invI

dim 		oldLimitImpulse  as variant
		' //  Solve linear constraint.
dim 		 linearCdot  as variant = me.m_linearJacobian.Compute(b1.m_linearVelocity, b1.m_angularVelocity, b2.m_linearVelocity, b2.m_angularVelocity)

dim 		 linearImpulse  as variant = - me.m_linearMass * linearCdot

dim 		 angularCdot  as variant 
dim 		 angularImpulse  as variant
dim 			 motorCdot  as variant
dim 			 motorImpulse  as variant 
dim 			 oldMotorImpulse  as variant 
dim 			 limitCdot  as variant
dim 			 limitImpulse  as variant 


		 me.m_linearImpulse += linearImpulse
		' // b1->m_linearVelocity += (invMass1 * linearImpulse) * me.m_linearJacobian.linear1
		b1.m_linearVelocity.x += (invMass1 * linearImpulse) * me.m_linearJacobian.linear1.x
		b1.m_linearVelocity.y += (invMass1 * linearImpulse) * me.m_linearJacobian.linear1.y
		' // b1->m_angularVelocity += invI1 * linearImpulse * me.m_linearJacobian.angular1
		b1.m_angularVelocity += invI1 * linearImpulse * me.m_linearJacobian.angular1
		' // b2->m_linearVelocity += (invMass2 * linearImpulse) * me.m_linearJacobian.linear2
		b2.m_linearVelocity.x += (invMass2 * linearImpulse) * me.m_linearJacobian.linear2.x
		b2.m_linearVelocity.y += (invMass2 * linearImpulse) * me.m_linearJacobian.linear2.y
		' // b2.m_angularVelocity += invI2 * linearImpulse * me.m_linearJacobian.angular2
		b2.m_angularVelocity += invI2 * linearImpulse * me.m_linearJacobian.angular2
		' //  Solve angular constraint.
		 angularCdot  = b2.m_angularVelocity - b1.m_angularVelocity

		 angularImpulse  = - me.m_angularMass * angularCdot

		 me.m_angularImpulse += angularImpulse
		b1.m_angularVelocity -= invI1 * angularImpulse
		b2.m_angularVelocity += invI2 * angularImpulse
		' //  Solve linear motor constraint.
		if ( me.m_enableMotor and me.m_limitState <> b2Joint.e_equalLimits) then 
			 motorCdot  = me.m_motorJacobian.Compute(b1.m_linearVelocity, b1.m_angularVelocity, b2.m_linearVelocity, b2.m_angularVelocity) - me.m_motorSpeed

			 motorImpulse  = - me.m_motorMass * motorCdot

			 oldMotorImpulse  = me.m_motorImpulse

			 me.m_motorImpulse = b2Math.b2Clamp( me.m_motorImpulse + motorImpulse, -step.dt * me.m_maxMotorForce, step.dt * me.m_maxMotorForce)
			motorImpulse = me.m_motorImpulse - oldMotorImpulse
			' // b1.m_linearVelocity += (invMass1 * motorImpulse) * me.m_motorJacobian.linear1
			b1.m_linearVelocity.x += (invMass1 * motorImpulse) * me.m_motorJacobian.linear1.x
			b1.m_linearVelocity.y += (invMass1 * motorImpulse) * me.m_motorJacobian.linear1.y
			' // b1.m_angularVelocity += invI1 * motorImpulse * me.m_motorJacobian.angular1
			b1.m_angularVelocity += invI1 * motorImpulse * me.m_motorJacobian.angular1
			' // b2->m_linearVelocity += (invMass2 * motorImpulse) * me.m_motorJacobian.linear2
			b2.m_linearVelocity.x += (invMass2 * motorImpulse) * me.m_motorJacobian.linear2.x
			b2.m_linearVelocity.y += (invMass2 * motorImpulse) * me.m_motorJacobian.linear2.y
			' // b2->m_angularVelocity += invI2 * motorImpulse * me.m_motorJacobian.angular2
			b2.m_angularVelocity += invI2 * motorImpulse * me.m_motorJacobian.angular2
		endif
		
		' //  Solve linear limit constraint.
		if ( me.m_enableLimit and me.m_limitState <> b2Joint.e_inactiveLimit) then
			 limitCdot  = me.m_motorJacobian.Compute(b1.m_linearVelocity, b1.m_angularVelocity, b2.m_linearVelocity, b2.m_angularVelocity)
			 limitImpulse  = - me.m_motorMass * limitCdot

			if ( me.m_limitState = b2Joint.e_equalLimits) then 
			
				 me.m_limitImpulse += limitImpulse
			
			else if ( me.m_limitState = b2Joint.e_atLowerLimit) then 
			
				oldLimitImpulse = me.m_limitImpulse
				 me.m_limitImpulse = b2Math.b2Max( me.m_limitImpulse + limitImpulse, 0.0)
				limitImpulse = me.m_limitImpulse - oldLimitImpulse
			
			else if ( me.m_limitState = b2Joint.e_atUpperLimit) then 
			
				oldLimitImpulse = me.m_limitImpulse
				 me.m_limitImpulse = b2Math.b2Min( me.m_limitImpulse + limitImpulse, 0.0)
				limitImpulse = me.m_limitImpulse - oldLimitImpulse
			endif
			
			' // b1->m_linearVelocity += (invMass1 * limitImpulse) * me.m_motorJacobian.linear1
			b1.m_linearVelocity.x += (invMass1 * limitImpulse) * me.m_motorJacobian.linear1.x
			b1.m_linearVelocity.y += (invMass1 * limitImpulse) * me.m_motorJacobian.linear1.y
			' // b1->m_angularVelocity += invI1 * limitImpulse * me.m_motorJacobian.angular1
			b1.m_angularVelocity += invI1 * limitImpulse * me.m_motorJacobian.angular1
			' // b2->m_linearVelocity += (invMass2 * limitImpulse) * me.m_motorJacobian.linear2
			b2.m_linearVelocity.x += (invMass2 * limitImpulse) * me.m_motorJacobian.linear2.x
			b2.m_linearVelocity.y += (invMass2 * limitImpulse) * me.m_motorJacobian.linear2.y
			' // b2->m_angularVelocity += invI2 * limitImpulse * me.m_motorJacobian.angular2
			b2.m_angularVelocity += invI2 * limitImpulse * me.m_motorJacobian.angular2
		endif
			
end

public  sub 	SolvePositionConstraints() as variant ''funcion
dim 		limitC  as variant
dim 		oldLimitImpulse  as variant
dim 		 b1  as variant = me.m_body1

dim 		 b2  as variant = me.m_body2

dim 		 invMass1  as variant = b1.m_invMass

dim 		 invMass2  as variant = b2.m_invMass

dim 		 invI1  as variant = b1.m_invI

dim 		 invI2  as variant = b2.m_invI

dim 		tMat  as variant

dim 		 r1X  as variant 
dim 		 r1Y  as variant
dim 		 r2X  as variant
dim 		 r2Y  as variant 
dim 		 p1X  as variant 
dim 		 p1Y  as variant
dim 		 p2X  as variant
dim 		 p2Y  as variant 
dim 		 dX  as variant
dim 		 dY  as variant
dim 		 ay1X  as variant
dim 		 ay1Y  as variant
dim 		 linearC  as variant 
dim 		 linearImpulse  as variant
dim 		 positionError  as variant
dim 		 angularC  as variant
dim 		 angularImpulse  as variant
dim 		 angularError  as varian
dim 			 ax1X  as variant
dim 			 ax1Y  as variant 
dim 			 translation  as variant
dim 			 limitImpulse  as variant = 0.0
		' // b2Vec2 r1 = b2Mul(b1->m_R, me.m_localAnchor1)
		tMat = b1.m_R
	 r1X  = tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y

	 r1Y  = tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y

		' // b2Vec2 r2 = b2Mul(b2->m_R, me.m_localAnchor2)
		tMat = b2.m_R
	 r2X  = tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y

	 r2Y  = tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y

		' // b2Vec2 p1 = b1->m_position + r1
	 p1X  = b1.m_position.x + r1X

	 p1Y  = b1.m_position.y + r1Y

		' // b2Vec2 p2 = b2->m_position + r2
	 p2X  = b2.m_position.x + r2X

	 p2Y  = b2.m_position.y + r2Y

		' // b2Vec2 d = p2 - p1
	 dX  = p2X - p1X

	 dY  = p2Y - p1Y

		' // b2Vec2 ay1 = b2Mul(b1->m_R, me.m_localYAxis1)
		tMat = b1.m_R
	 ay1X  = tMat.col1.x * me.m_localYAxis1.x + tMat.col2.x * me.m_localYAxis1.y

	 ay1Y  = tMat.col1.y * me.m_localYAxis1.x + tMat.col2.y * me.m_localYAxis1.y

		' //  Solve linear (point-to-line) constraint.
		' // float32 linearC = b2Dot(ay1, d)
	 linearC  = ay1X*dX + ay1Y*dY

		' //  Prevent overly large corrections.
		linearC = b2Math.b2Clamp(linearC, -b2Settings.b2_maxLinearCorrection, b2Settings.b2_maxLinearCorrection)
	 linearImpulse  = - me.m_linearMass * linearC

		' // b1->m_position += (invMass1 * linearImpulse) * me.m_linearJacobian.linear1
		b1.m_position.x += (invMass1 * linearImpulse) * me.m_linearJacobian.linear1.x
		b1.m_position.y += (invMass1 * linearImpulse) * me.m_linearJacobian.linear1.y
		' // b1->m_rotation += invI1 * linearImpulse * me.m_linearJacobian.angular1
		b1.m_rotation += invI1 * linearImpulse * me.m_linearJacobian.angular1
		' // b1->m_R.Set(b1->m_rotation)
		' // b2->m_position += (invMass2 * linearImpulse) * me.m_linearJacobian.linear2
		b2.m_position.x += (invMass2 * linearImpulse) * me.m_linearJacobian.linear2.x
		b2.m_position.y += (invMass2 * linearImpulse) * me.m_linearJacobian.linear2.y
		b2.m_rotation += invI2 * linearImpulse * me.m_linearJacobian.angular2
		' // b2->m_R.Set(b2->m_rotation)
	 positionError  = b2Math.b2Abs(linearC)

		' //  Solve angular constraint.
	 angularC  = b2.m_rotation - b1.m_rotation - me.m_initialAngle

		' //  Prevent overly large corrections.
		angularC = b2Math.b2Clamp(angularC, -b2Settings.b2_maxAngularCorrection, b2Settings.b2_maxAngularCorrection)
	 angularImpulse  = - me.m_angularMass * angularC

		b1.m_rotation -= b1.m_invI * angularImpulse
		b1.m_R.Set(b1.m_rotation)
		b2.m_rotation += b2.m_invI * angularImpulse
		b2.m_R.Set(b2.m_rotation)
	 angularError  = b2Math.b2Abs(angularC)

		' //  Solve linear limit constraint.
		if ( me.m_enableLimit and  me.m_limitState <> b2Joint.e_inactiveLimit)
			' // b2Vec2 r1 = b2Mul(b1->m_R, me.m_localAnchor1)
			tMat = b1.m_R
			r1X = tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y
			r1Y = tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y
			' // b2Vec2 r2 = b2Mul(b2->m_R, me.m_localAnchor2)
			tMat = b2.m_R
			r2X = tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y
			r2Y = tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y
			' // b2Vec2 p1 = b1->m_position + r1
			p1X = b1.m_position.x + r1X
			p1Y = b1.m_position.y + r1Y
			' // b2Vec2 p2 = b2->m_position + r2
			p2X = b2.m_position.x + r2X
			p2Y = b2.m_position.y + r2Y
			' // b2Vec2 d = p2 - p1
			dX = p2X - p1X
			dY = p2Y - p1Y
			' // b2Vec2 ax1 = b2Mul(b1->m_R, me.m_localXAxis1)
			tMat = b1.m_R
		 ax1X  = tMat.col1.x * me.m_localXAxis1.x + tMat.col2.x * me.m_localXAxis1.y

		 ax1Y  = tMat.col1.y * me.m_localXAxis1.x + tMat.col2.y * me.m_localXAxis1.y

			' // float32 translation = b2Dot(ax1, d)
		 translation  = (ax1X*dX + ax1Y*dY)

		 limitImpulse  = 0.0

			if ( me.m_limitState = b2Joint.e_equalLimits) then 
			
				' //  Prevent large angular corrections
				limitC = b2Math.b2Clamp(translation, -b2Settings.b2_maxLinearCorrection, b2Settings.b2_maxLinearCorrection)
				limitImpulse = - me.m_motorMass * limitC
				positionError = b2Math.b2Max(positionError, b2Math.b2Abs(angularC))
			
			else if ( me.m_limitState = b2Joint.e_atLowerLimit) then 
			
				limitC = translation - me.m_lowerTranslation
				positionError = b2Math.b2Max(positionError, -limitC)
				' //  Prevent large linear corrections and allow some slop.
				limitC = b2Math.b2Clamp(limitC + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0.0)
				limitImpulse = - me.m_motorMass * limitC
				oldLimitImpulse = me.m_limitPositionImpulse
				 me.m_limitPositionImpulse = b2Math.b2Max( me.m_limitPositionImpulse + limitImpulse, 0.0)
				limitImpulse = me.m_limitPositionImpulse - oldLimitImpulse
			
			else if ( me.m_limitState = b2Joint.e_atUpperLimit) then 
			
				limitC = translation - me.m_upperTranslation
				positionError = b2Math.b2Max(positionError, limitC)
				' //  Prevent large linear corrections and allow some slop.
				limitC = b2Math.b2Clamp(limitC - b2Settings.b2_linearSlop, 0.0, b2Settings.b2_maxLinearCorrection)
				limitImpulse = - me.m_motorMass * limitC
				oldLimitImpulse = me.m_limitPositionImpulse
				 me.m_limitPositionImpulse = b2Math.b2Min( me.m_limitPositionImpulse + limitImpulse, 0.0)
				limitImpulse = me.m_limitPositionImpulse - oldLimitImpulse
			endif
			
			' // b1->m_position += (invMass1 * limitImpulse) * me.m_motorJacobian.linear1
			b1.m_position.x += (invMass1 * limitImpulse) * me.m_motorJacobian.linear1.x
			b1.m_position.y += (invMass1 * limitImpulse) * me.m_motorJacobian.linear1.y
			' // b1->m_rotation += invI1 * limitImpulse * me.m_motorJacobian.angular1
			b1.m_rotation += invI1 * limitImpulse * me.m_motorJacobian.angular1
			b1.m_R.Set(b1.m_rotation)
			' // b2->m_position += (invMass2 * limitImpulse) * me.m_motorJacobian.linear2
			b2.m_position.x += (invMass2 * limitImpulse) * me.m_motorJacobian.linear2.x
			b2.m_position.y += (invMass2 * limitImpulse) * me.m_motorJacobian.linear2.y
			' // b2->m_rotation += invI2 * limitImpulse * me.m_motorJacobian.angular2
			b2.m_rotation += invI2 * limitImpulse * me.m_motorJacobian.angular2
			b2.m_R.Set(b2.m_rotation)
		endif
		
	return positionError <= b2Settings.b2_linearSlop and angularError <= b2Settings.b2_angularSlop
end
