
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  Linear constraint (point-to-line)
' //  d = p2 - p1 = x2 + r2 - x1 - r1
' //  C = dot(ay1, d)
' //  Cdot = dot(d, cross(w1, ay1)) + dot(ay1, v2 + cross(w2, r2) - v1 - cross(w1, r1))
' //       = -dot(ay1, v1) - dot(cross(d + r1, ay1), w1) + dot(ay1, v2) + dot(cross(r2, ay1), v2)
' //  J = [-ay1 -cross(d+r1,ay1) ay1 cross(r2,ay1)]
' // 
' //  Angular constraint
' //  C = a2 - a1 + a_initial
' //  Cdot = w2 - w1
' //  J = [0 0 -1 0 0 1]
' //  Motor/Limit linear constraint
' //  C = dot(ax1, d)
' //  Cdot = = -dot(ax1, v1) - dot(cross(d + r1, ax1), w1) + dot(ax1, v2) + dot(cross(r2, ax1), v2)
' //  J = [-ax1 -cross(d+r1,ax1) ax1 cross(r2,ax1)]
dim  b2PrismaticJoint  as variant = Class.create()

inherits , b2Joint
inherits 
end

public  sub 	GetAnchor1() as variant ''funcio as variant ''funcion
dim 		 b1  as variant = me.m_body1

		' // return b2Math.AddVV(b1.m_position, b2Math.b2MulMV(b1.m_R, me.m_localAnchor1))
 '' TODO: posible funcion (revisar)

dim 		 tVec  as variant = new b2Vec2()

		tVec.SetV( me.m_localAnchor1)
		tVec.MulM(b1.m_R)
		tVec.Add(b1.m_position)
		return tVec
 '' TODO: posible funcion (revisar)

end

public  sub 	GetAnchor2() as variant ''funcio as variant ''funcion
dim 		 b2  as variant = me.m_body2

		' // return b2Math.AddVV(b2.m_position, b2Math.b2MulMV(b2.m_R, me.m_localAnchor2))
 '' TODO: posible funcion (revisar)

dim 		 tVec  as variant = new b2Vec2()

		tVec.SetV( me.m_localAnchor2)
		tVec.MulM(b2.m_R)
		tVec.Add(b2.m_position)
		return tVec
 '' TODO: posible funcion (revisar)

end

public  sub 	GetJointTranslation() as variant ''funcion
dim 		 b1  as variant = me.m_body1

dim 		 b2  as variant = me.m_body2

dim 		tMat
 as variant
		' // var r1 = b2Math.b2MulMV(b1.m_R, me.m_localAnchor1)
		tMat = b1.m_R
dim 		 r1X  as variant = tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y

dim 		 r1Y  as variant = tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y

		' // var r2 = b2Math.b2MulMV(b2.m_R, me.m_localAnchor2)
		tMat = b2.m_R
dim 		 r2X  as variant = tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y

dim 		 r2Y  as variant = tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y

		' // var p1 = b2Math.AddVV(b1.m_position , r1)
dim 		 p1X  as variant = b1.m_position.x + r1X

dim 		 p1Y  as variant = b1.m_position.y + r1Y

		' // var p2 = b2Math.AddVV(b2.m_position , r2)
dim 		 p2X  as variant = b2.m_position.x + r2X

dim 		 p2Y  as variant = b2.m_position.y + r2Y

		' // var d = b2Math.SubtractVV(p2, p1)
dim 		 dX  as variant = p2X - p1X

dim 		 dY  as variant = p2Y - p1Y

		' // var ax1 = b2Math.b2MulMV(b1.m_R, me.m_localXAxis1)
		tMat = b1.m_R
dim 		 ax1X  as variant = tMat.col1.x * me.m_localXAxis1.x + tMat.col2.x * me.m_localXAxis1.y

dim 		 ax1Y  as variant = tMat.col1.y * me.m_localXAxis1.x + tMat.col2.y * me.m_localXAxis1.y

		' // var translation = b2Math.b2Dot(ax1, d)
dim 		 translation  as variant = ax1X*dX + ax1Y*dY

		return translation
 '' TODO: posible funcion (revisar)

end

public  sub 	GetJointSpeed() as variant ''funcion
dim 		 b1  as variant = me.m_body1

dim 		 b2  as variant = me.m_body2

dim 		tMat
 as variant
		' // var r1 = b2Math.b2MulMV(b1.m_R, me.m_localAnchor1)
		tMat = b1.m_R
dim 		 r1X  as variant = tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y

dim 		 r1Y  as variant = tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y

		' // var r2 = b2Math.b2MulMV(b2.m_R, me.m_localAnchor2)
		tMat = b2.m_R
dim 		 r2X  as variant = tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y

dim 		 r2Y  as variant = tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y

		' // var p1 = b2Math.AddVV(b1.m_position , r1)
dim 		 p1X  as variant = b1.m_position.x + r1X

dim 		 p1Y  as variant = b1.m_position.y + r1Y

		' // var p2 = b2Math.AddVV(b2.m_position , r2)
dim 		 p2X  as variant = b2.m_position.x + r2X

dim 		 p2Y  as variant = b2.m_position.y + r2Y

		' // var d = b2Math.SubtractVV(p2, p1)
dim 		 dX  as variant = p2X - p1X

dim 		 dY  as variant = p2Y - p1Y

		' // var ax1 = b2Math.b2MulMV(b1.m_R, me.m_localXAxis1)
		tMat = b1.m_R
dim 		 ax1X  as variant = tMat.col1.x * me.m_localXAxis1.x + tMat.col2.x * me.m_localXAxis1.y

dim 		 ax1Y  as variant = tMat.col1.y * me.m_localXAxis1.x + tMat.col2.y * me.m_localXAxis1.y

dim 		 v1  as variant = b1.m_linearVelocity

dim 		 v2  as variant = b2.m_linearVelocity

dim 		 w1  as variant = b1.m_angularVelocity

dim 		 w2  as variant = b2.m_angularVelocity

		' // var speed = b2Math.b2Dot(d, b2Math.b2CrossFV(w1, ax1)) + b2Math.b2Dot(ax1, b2Math.SubtractVV( b2Math.SubtractVV( b2Math.AddVV( v2 , b2Math.b2CrossFV(w2, r2)) , v1) , b2Math.b2CrossFV(w1, r1)))
		' // var b2D = (dX*(-w1 * ax1Y) + dY*(w1 * ax1X))
		' // var b2D2 = (ax1X * ((( v2.x + (-w2 * r2Y)) - v1.x) - (-w1 * r1Y)) + ax1Y * ((( v2.y + (w2 * r2X)) - v1.y) - (w1 * r1X)))
dim 		 speed  as variant = (dX*(-w1 * ax1Y) + dY*(w1 * ax1X)) + (ax1X * ((( v2.x + (-w2 * r2Y)) - v1.x) - (-w1 * r1Y)) + ax1Y * ((( v2.y + (w2 * r2X)) - v1.y) - (w1 * r1X)))

		return speed
 '' TODO: posible funcion (revisar)

end

public  sub 	GetMotorForce(invTimeStep as variant) as variant ''funcion
		return invTimeStep * me.m_motorImpulse
 '' TODO: posible funcion (revisar)

end

public  sub 	SetMotorSpeed(speed as variant)

		 me.m_motorSpeed = speed
end

public  sub 	SetMotorForce(force as variant)

		 me.m_maxMotorForce = force
end

public  sub 	GetReactionForce(invTimeStep as variant) as variant ''funcio as variant ''funcion
dim 		 tImp  as variant = invTimeStep * me.m_limitImpulse

dim 		tMat
 as variant
		' // var ax1 = b2Math.b2MulMV( me.m_body1.m_R, me.m_localXAxis1)
		tMat = me.m_body1.m_R
dim 		 ax1X  as variant = tImp * (tMat.col1.x * me.m_localXAxis1.x + tMat.col2.x * me.m_localXAxis1.y)

dim 		 ax1Y  as variant = tImp * (tMat.col1.y * me.m_localXAxis1.x + tMat.col2.y * me.m_localXAxis1.y)

		' // var ay1 = b2Math.b2MulMV( me.m_body1.m_R, me.m_localYAxis1)
dim 		 ay1X  as variant = tImp * (tMat.col1.x * me.m_localYAxis1.x + tMat.col2.x * me.m_localYAxis1.y)

dim 		 ay1Y  as variant = tImp * (tMat.col1.y * me.m_localYAxis1.x + tMat.col2.y * me.m_localYAxis1.y)

		' // return (invTimeStep * me.m_limitImpulse) * ax1 + (invTimeStep * me.m_linearImpulse) * ay1
 '' TODO: posible funcion (revisar)

		return new b2Vec2(ax1X+ay1X, ax1Y+ay1Y)
 '' TODO: posible funcion (revisar)

end

public  sub 	GetReactionTorque(invTimeStep as variant) as variant ''funcion
		return invTimeStep * me.m_angularImpulse
 '' TODO: posible funcion (revisar)

	' // --------------- Internals Below -------------------
end

public  sub 	initialize(def as variant)

		' //  The constructor for b2Joint
		' //  initialize instance variables for references
		 me.m_node1 = new b2JointNode()
		 me.m_node2 = new b2JointNode()
		' // 
		 me.m_type = def.type
		 me.m_prev = null
		 me.m_next = null
		 me.m_body1 = def.body1
		 me.m_body2 = def.body2
		 me.m_collideConnected = def.collideConnected
		 me.m_islandFlag = false
		 me.m_userData = def.userData
		' // 
		' //  initialize instance variables for references
		 me.m_localAnchor1 = new b2Vec2()
		 me.m_localAnchor2 = new b2Vec2()
		 me.m_localXAxis1 = new b2Vec2()
		 me.m_localYAxis1 = new b2Vec2()
		 me.m_linearJacobian = new b2Jacobian()
		 me.m_motorJacobian = new b2Jacobian()
		' // 
		' // super(def)
dim 		tMat
 as variant
dim 		tX
 as variant
dim 		tY
 as variant
		' // me.m_localAnchor1 = b2Math.b2MulTMV( me.m_body1.m_R, b2Math.SubtractVV(def.anchorPoint , me.m_body1.m_position))
		tMat = me.m_body1.m_R
		tX = (def.anchorPoint.x - me.m_body1.m_position.x)
		tY = (def.anchorPoint.y - me.m_body1.m_position.y)
		 me.m_localAnchor1.Set((tX*tMat.col1.x + tY*tMat.col1.y), (tX*tMat.col2.x + tY*tMat.col2.y))
		' // me.m_localAnchor2 = b2Math.b2MulTMV( me.m_body2.m_R, b2Math.SubtractVV(def.anchorPoint , me.m_body2.m_position))
		tMat = me.m_body2.m_R
		tX = (def.anchorPoint.x - me.m_body2.m_position.x)
		tY = (def.anchorPoint.y - me.m_body2.m_position.y)
		 me.m_localAnchor2.Set((tX*tMat.col1.x + tY*tMat.col1.y), (tX*tMat.col2.x + tY*tMat.col2.y))
		' // me.m_localXAxis1 = b2Math.b2MulTMV( me.m_body1.m_R, def.axis)
		tMat = me.m_body1.m_R
		tX = def.axis.x
		tY = def.axis.y
		 me.m_localXAxis1.Set((tX*tMat.col1.x + tY*tMat.col1.y), (tX*tMat.col2.x + tY*tMat.col2.y))
		' // me.m_localYAxis1 = b2Math.b2CrossFV(1.0, me.m_localXAxis1)
		 me.m_localYAxis1.x = - me.m_localXAxis1.y
		 me.m_localYAxis1.y = me.m_localXAxis1.x
		 me.m_initialAngle = me.m_body2.m_rotation - me.m_body1.m_rotation
		 me.m_linearJacobian.SetZero()
		 me.m_linearMass = 0.0
		 me.m_linearImpulse = 0.0
		 me.m_angularMass = 0.0
		 me.m_angularImpulse = 0.0
		 me.m_motorJacobian.SetZero()
		 me.m_motorMass = 0.0
		 me.m_motorImpulse = 0.0
		 me.m_limitImpulse = 0.0
		 me.m_limitPositionImpulse = 0.0
		 me.m_lowerTranslation = def.lowerTranslation
		 me.m_upperTranslation = def.upperTranslation
		 me.m_maxMotorForce = def.motorForce
		 me.m_motorSpeed = def.motorSpeed
		 me.m_enableLimit = def.enableLimit
		 me.m_enableMotor = def.enableMotor
end

public  sub 	PrepareVelocitySolver()

dim 		 b1  as variant = me.m_body1

dim 		 b2  as variant = me.m_body2

dim 		tMat
 as variant
		' //  Compute the effective masses.
		' // b2Vec2 r1 = b2Mul(b1->m_R, me.m_localAnchor1)
		tMat = b1.m_R
dim 		 r1X  as variant = tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y

dim 		 r1Y  as variant = tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y

		' // b2Vec2 r2 = b2Mul(b2->m_R, me.m_localAnchor2)
		tMat = b2.m_R
dim 		 r2X  as variant = tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y

dim 		 r2Y  as variant = tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y

		' // float32 invMass1 = b1->m_invMass, invMass2 = b2->m_invMass
dim 		 invMass1  as variant = b1.m_invMass

dim 		 invMass2  as variant = b2.m_invMass

		' // float32 invI1 = b1->m_invI, invI2 = b2->m_invI
dim 		 invI1  as variant = b1.m_invI

dim 		 invI2  as variant = b2.m_invI

		' //  Compute point to line constraint effective mass.
		' //  J = [-ay1 -cross(d+r1,ay1) ay1 cross(r2,ay1)]
		' // b2Vec2 ay1 = b2Mul(b1->m_R, me.m_localYAxis1)
		tMat = b1.m_R
dim 		 ay1X  as variant = tMat.col1.x * me.m_localYAxis1.x + tMat.col2.x * me.m_localYAxis1.y

dim 		 ay1Y  as variant = tMat.col1.y * me.m_localYAxis1.x + tMat.col2.y * me.m_localYAxis1.y

		' // b2Vec2 e = b2->m_position + r2 - b1->m_position
dim 		 eX  as variant = b2.m_position.x + r2X - b1.m_position.x

dim 		 eY  as variant = b2.m_position.y + r2Y - b1.m_position.y

		' // me.m_linearJacobian.Set(-ay1, -b2Math.b2Cross(e, ay1), ay1, b2Math.b2Cross(r2, ay1))
		 me.m_linearJacobian.linear1.x = -ay1X
		 me.m_linearJacobian.linear1.y = -ay1Y
		 me.m_linearJacobian.linear2.x = ay1X
		 me.m_linearJacobian.linear2.y = ay1Y
		 me.m_linearJacobian.angular1 = -(eX * ay1Y - eY * ay1X)
		 me.m_linearJacobian.angular2 = r2X * ay1Y - r2Y * ay1X
		 me.m_linearMass =	invMass1 + invI1 * me.m_linearJacobian.angular1 * me.m_linearJacobian.angular1 +
						invMass2 + invI2 * me.m_linearJacobian.angular2 * me.m_linearJacobian.angular2
		' // b2Settings.b2Assert( me.m_linearMass > Number.MIN_VALUE)
		 me.m_linearMass = 1.0 / me.m_linearMass
		' //  Compute angular constraint effective mass.
		 me.m_angularMass = 1.0 / (invI1 + invI2)
		' //  Compute motor and limit terms.
		if ( me.m_enableLimit || me.m_enableMotor)
			' //  The motor and limit share a Jacobian and effective mass.
			' // b2Vec2 ax1 = b2Mul(b1->m_R, me.m_localXAxis1)
			tMat = b1.m_R
dim 			 ax1X  as variant = tMat.col1.x * me.m_localXAxis1.x + tMat.col2.x * me.m_localXAxis1.y

dim 			 ax1Y  as variant = tMat.col1.y * me.m_localXAxis1.x + tMat.col2.y * me.m_localXAxis1.y

			' // me.m_motorJacobian.Set(-ax1, -b2Cross(e, ax1), ax1, b2Cross(r2, ax1))
			 me.m_motorJacobian.linear1.x = -ax1X
 me.m_motorJacobian.linear1.y = -ax1Y
			 me.m_motorJacobian.linear2.x = ax1X
 me.m_motorJacobian.linear2.y = ax1Y
			 me.m_motorJacobian.angular1 = -(eX * ax1Y - eY * ax1X)
			 me.m_motorJacobian.angular2 = r2X * ax1Y - r2Y * ax1X
			 me.m_motorMass =	invMass1 + invI1 * me.m_motorJacobian.angular1 * me.m_motorJacobian.angular1 +
							invMass2 + invI2 * me.m_motorJacobian.angular2 * me.m_motorJacobian.angular2
			' // b2Settings.b2Assert( me.m_motorMass > Number.MIN_VALUE)
			 me.m_motorMass = 1.0 / me.m_motorMass
			if ( me.m_enableLimit)
			
				' // b2Vec2 d = e - r1
dim 				 dX  as variant = eX - r1X

dim 				 dY  as variant = eY - r1Y

				' // float32 jointTranslation = b2Dot(ax1, d)
dim 				 jointTranslation  as variant = ax1X * dX + ax1Y * dY

				if (b2Math.b2Abs( me.m_upperTranslation - me.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop)
				
					 me.m_limitState = b2Joint.e_equalLimits
				
				else if (jointTranslation <= me.m_lowerTranslation)
				
					if ( me.m_limitState != b2Joint.e_atLowerLimit)
					
						 me.m_limitImpulse = 0.0
					
					 me.m_limitState = b2Joint.e_atLowerLimit
				
				else if (jointTranslation >= me.m_upperTranslation)
				
					if ( me.m_limitState != b2Joint.e_atUpperLimit)
					
						 me.m_limitImpulse = 0.0
					
					 me.m_limitState = b2Joint.e_atUpperLimit
				
				else
				
					 me.m_limitState = b2Joint.e_inactiveLimit
					 me.m_limitImpulse = 0.0
				
			
		if ( me.m_enableMotor == false)
			 me.m_motorImpulse = 0.0
		if ( me.m_enableLimit == false)
			 me.m_limitImpulse = 0.0
		if (b2World.s_enableWarmStarting)
			' // b2Vec2 P1 = me.m_linearImpulse * me.m_linearJacobian.linear1 + ( me.m_motorImpulse + me.m_limitImpulse) * me.m_motorJacobian.linear1
dim 			 P1X  as variant = me.m_linearImpulse * me.m_linearJacobian.linear1.x + ( me.m_motorImpulse + me.m_limitImpulse) * me.m_motorJacobian.linear1.x

dim 			 P1Y  as variant = me.m_linearImpulse * me.m_linearJacobian.linear1.y + ( me.m_motorImpulse + me.m_limitImpulse) * me.m_motorJacobian.linear1.y

			' // b2Vec2 P2 = me.m_linearImpulse * me.m_linearJacobian.linear2 + ( me.m_motorImpulse + me.m_limitImpulse) * me.m_motorJacobian.linear2
dim 			 P2X  as variant = me.m_linearImpulse * me.m_linearJacobian.linear2.x + ( me.m_motorImpulse + me.m_limitImpulse) * me.m_motorJacobian.linear2.x

dim 			 P2Y  as variant = me.m_linearImpulse * me.m_linearJacobian.linear2.y + ( me.m_motorImpulse + me.m_limitImpulse) * me.m_motorJacobian.linear2.y

			' // float32 L1 = me.m_linearImpulse * me.m_linearJacobian.angular1 - me.m_angularImpulse + ( me.m_motorImpulse + me.m_limitImpulse) * me.m_motorJacobian.angular1
dim 			 L1  as variant = me.m_linearImpulse * me.m_linearJacobian.angular1 - me.m_angularImpulse + ( me.m_motorImpulse + me.m_limitImpulse) * me.m_motorJacobian.angular1

			' // float32 L2 = me.m_linearImpulse * me.m_linearJacobian.angular2 + me.m_angularImpulse + ( me.m_motorImpulse + me.m_limitImpulse) * me.m_motorJacobian.angular2
dim 			 L2  as variant = me.m_linearImpulse * me.m_linearJacobian.angular2 + me.m_angularImpulse + ( me.m_motorImpulse + me.m_limitImpulse) * me.m_motorJacobian.angular2

			' // b1->m_linearVelocity += invMass1 * P1
			b1.m_linearVelocity.x += invMass1 * P1X
			b1.m_linearVelocity.y += invMass1 * P1Y
			' // b1->m_angularVelocity += invI1 * L1
			b1.m_angularVelocity += invI1 * L1
			' // b2->m_linearVelocity += invMass2 * P2
			b2.m_linearVelocity.x += invMass2 * P2X
			b2.m_linearVelocity.y += invMass2 * P2Y
			' // b2->m_angularVelocity += invI2 * L2
			b2.m_angularVelocity += invI2 * L2
		else
			 me.m_linearImpulse = 0.0
			 me.m_angularImpulse = 0.0
			 me.m_limitImpulse = 0.0
			 me.m_motorImpulse = 0.0
		 me.m_limitPositionImpulse = 0.0
end

public  sub 	SolveVelocityConstraints(step as variant)

dim 		 b1  as variant = me.m_body1

dim 		 b2  as variant = me.m_body2

dim 		 invMass1  as variant = b1.m_invMass

dim 		 invMass2  as variant = b2.m_invMass

dim 		 invI1  as variant = b1.m_invI

dim 		 invI2  as variant = b2.m_invI

dim 		oldLimitImpulse
 as variant
		' //  Solve linear constraint.
dim 		 linearCdot  as variant = me.m_linearJacobian.Compute(b1.m_linearVelocity, b1.m_angularVelocity, b2.m_linearVelocity, b2.m_angularVelocity)

dim 		 linearImpulse  as variant = - me.m_linearMass * linearCdot

		 me.m_linearImpulse += linearImpulse
		' // b1->m_linearVelocity += (invMass1 * linearImpulse) * me.m_linearJacobian.linear1
		b1.m_linearVelocity.x += (invMass1 * linearImpulse) * me.m_linearJacobian.linear1.x
		b1.m_linearVelocity.y += (invMass1 * linearImpulse) * me.m_linearJacobian.linear1.y
		' // b1->m_angularVelocity += invI1 * linearImpulse * me.m_linearJacobian.angular1
		b1.m_angularVelocity += invI1 * linearImpulse * me.m_linearJacobian.angular1
		' // b2->m_linearVelocity += (invMass2 * linearImpulse) * me.m_linearJacobian.linear2
		b2.m_linearVelocity.x += (invMass2 * linearImpulse) * me.m_linearJacobian.linear2.x
		b2.m_linearVelocity.y += (invMass2 * linearImpulse) * me.m_linearJacobian.linear2.y
		' // b2.m_angularVelocity += invI2 * linearImpulse * me.m_linearJacobian.angular2
		b2.m_angularVelocity += invI2 * linearImpulse * me.m_linearJacobian.angular2
		' //  Solve angular constraint.
dim 		 angularCdot  as variant = b2.m_angularVelocity - b1.m_angularVelocity

dim 		 angularImpulse  as variant = - me.m_angularMass * angularCdot

		 me.m_angularImpulse += angularImpulse
		b1.m_angularVelocity -= invI1 * angularImpulse
		b2.m_angularVelocity += invI2 * angularImpulse
		' //  Solve linear motor constraint.
		if ( me.m_enableMotor && me.m_limitState != b2Joint.e_equalLimits)
dim 			 motorCdot  as variant = me.m_motorJacobian.Compute(b1.m_linearVelocity, b1.m_angularVelocity, b2.m_linearVelocity, b2.m_angularVelocity) - me.m_motorSpeed

dim 			 motorImpulse  as variant = - me.m_motorMass * motorCdot

dim 			 oldMotorImpulse  as variant = me.m_motorImpulse

			 me.m_motorImpulse = b2Math.b2Clamp( me.m_motorImpulse + motorImpulse, -step.dt * me.m_maxMotorForce, step.dt * me.m_maxMotorForce)
			motorImpulse = me.m_motorImpulse - oldMotorImpulse
			' // b1.m_linearVelocity += (invMass1 * motorImpulse) * me.m_motorJacobian.linear1
			b1.m_linearVelocity.x += (invMass1 * motorImpulse) * me.m_motorJacobian.linear1.x
			b1.m_linearVelocity.y += (invMass1 * motorImpulse) * me.m_motorJacobian.linear1.y
			' // b1.m_angularVelocity += invI1 * motorImpulse * me.m_motorJacobian.angular1
			b1.m_angularVelocity += invI1 * motorImpulse * me.m_motorJacobian.angular1
			' // b2->m_linearVelocity += (invMass2 * motorImpulse) * me.m_motorJacobian.linear2
			b2.m_linearVelocity.x += (invMass2 * motorImpulse) * me.m_motorJacobian.linear2.x
			b2.m_linearVelocity.y += (invMass2 * motorImpulse) * me.m_motorJacobian.linear2.y
			' // b2->m_angularVelocity += invI2 * motorImpulse * me.m_motorJacobian.angular2
			b2.m_angularVelocity += invI2 * motorImpulse * me.m_motorJacobian.angular2
		' //  Solve linear limit constraint.
		if ( me.m_enableLimit && me.m_limitState != b2Joint.e_inactiveLimit)
dim 			 limitCdot  as variant = me.m_motorJacobian.Compute(b1.m_linearVelocity, b1.m_angularVelocity, b2.m_linearVelocity, b2.m_angularVelocity)

dim 			 limitImpulse  as variant = - me.m_motorMass * limitCdot

			if ( me.m_limitState == b2Joint.e_equalLimits)
			
				 me.m_limitImpulse += limitImpulse
			
			else if ( me.m_limitState == b2Joint.e_atLowerLimit)
			
				oldLimitImpulse = me.m_limitImpulse
				 me.m_limitImpulse = b2Math.b2Max( me.m_limitImpulse + limitImpulse, 0.0)
				limitImpulse = me.m_limitImpulse - oldLimitImpulse
			
			else if ( me.m_limitState == b2Joint.e_atUpperLimit)
			
				oldLimitImpulse = me.m_limitImpulse
				 me.m_limitImpulse = b2Math.b2Min( me.m_limitImpulse + limitImpulse, 0.0)
				limitImpulse = me.m_limitImpulse - oldLimitImpulse
			
			' // b1->m_linearVelocity += (invMass1 * limitImpulse) * me.m_motorJacobian.linear1
			b1.m_linearVelocity.x += (invMass1 * limitImpulse) * me.m_motorJacobian.linear1.x
			b1.m_linearVelocity.y += (invMass1 * limitImpulse) * me.m_motorJacobian.linear1.y
			' // b1->m_angularVelocity += invI1 * limitImpulse * me.m_motorJacobian.angular1
			b1.m_angularVelocity += invI1 * limitImpulse * me.m_motorJacobian.angular1
			' // b2->m_linearVelocity += (invMass2 * limitImpulse) * me.m_motorJacobian.linear2
			b2.m_linearVelocity.x += (invMass2 * limitImpulse) * me.m_motorJacobian.linear2.x
			b2.m_linearVelocity.y += (invMass2 * limitImpulse) * me.m_motorJacobian.linear2.y
			' // b2->m_angularVelocity += invI2 * limitImpulse * me.m_motorJacobian.angular2
			b2.m_angularVelocity += invI2 * limitImpulse * me.m_motorJacobian.angular2
end

public  sub 	SolvePositionConstraints() as variant ''funcion
dim 		limitC
 as variant
dim 		oldLimitImpulse
 as variant
dim 		 b1  as variant = me.m_body1

dim 		 b2  as variant = me.m_body2

dim 		 invMass1  as variant = b1.m_invMass

dim 		 invMass2  as variant = b2.m_invMass

dim 		 invI1  as variant = b1.m_invI

dim 		 invI2  as variant = b2.m_invI

dim 		tMat
 as variant
		' // b2Vec2 r1 = b2Mul(b1->m_R, me.m_localAnchor1)
		tMat = b1.m_R
dim 		 r1X  as variant = tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y

dim 		 r1Y  as variant = tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y

		' // b2Vec2 r2 = b2Mul(b2->m_R, me.m_localAnchor2)
		tMat = b2.m_R
dim 		 r2X  as variant = tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y

dim 		 r2Y  as variant = tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y

		' // b2Vec2 p1 = b1->m_position + r1
dim 		 p1X  as variant = b1.m_position.x + r1X

dim 		 p1Y  as variant = b1.m_position.y + r1Y

		' // b2Vec2 p2 = b2->m_position + r2
dim 		 p2X  as variant = b2.m_position.x + r2X

dim 		 p2Y  as variant = b2.m_position.y + r2Y

		' // b2Vec2 d = p2 - p1
dim 		 dX  as variant = p2X - p1X

dim 		 dY  as variant = p2Y - p1Y

		' // b2Vec2 ay1 = b2Mul(b1->m_R, me.m_localYAxis1)
		tMat = b1.m_R
dim 		 ay1X  as variant = tMat.col1.x * me.m_localYAxis1.x + tMat.col2.x * me.m_localYAxis1.y

dim 		 ay1Y  as variant = tMat.col1.y * me.m_localYAxis1.x + tMat.col2.y * me.m_localYAxis1.y

		' //  Solve linear (point-to-line) constraint.
		' // float32 linearC = b2Dot(ay1, d)
dim 		 linearC  as variant = ay1X*dX + ay1Y*dY

		' //  Prevent overly large corrections.
		linearC = b2Math.b2Clamp(linearC, -b2Settings.b2_maxLinearCorrection, b2Settings.b2_maxLinearCorrection)
dim 		 linearImpulse  as variant = - me.m_linearMass * linearC

		' // b1->m_position += (invMass1 * linearImpulse) * me.m_linearJacobian.linear1
		b1.m_position.x += (invMass1 * linearImpulse) * me.m_linearJacobian.linear1.x
		b1.m_position.y += (invMass1 * linearImpulse) * me.m_linearJacobian.linear1.y
		' // b1->m_rotation += invI1 * linearImpulse * me.m_linearJacobian.angular1
		b1.m_rotation += invI1 * linearImpulse * me.m_linearJacobian.angular1
		' // b1->m_R.Set(b1->m_rotation)
		' // b2->m_position += (invMass2 * linearImpulse) * me.m_linearJacobian.linear2
		b2.m_position.x += (invMass2 * linearImpulse) * me.m_linearJacobian.linear2.x
		b2.m_position.y += (invMass2 * linearImpulse) * me.m_linearJacobian.linear2.y
		b2.m_rotation += invI2 * linearImpulse * me.m_linearJacobian.angular2
		' // b2->m_R.Set(b2->m_rotation)
dim 		 positionError  as variant = b2Math.b2Abs(linearC)

		' //  Solve angular constraint.
dim 		 angularC  as variant = b2.m_rotation - b1.m_rotation - me.m_initialAngle

		' //  Prevent overly large corrections.
		angularC = b2Math.b2Clamp(angularC, -b2Settings.b2_maxAngularCorrection, b2Settings.b2_maxAngularCorrection)
dim 		 angularImpulse  as variant = - me.m_angularMass * angularC

		b1.m_rotation -= b1.m_invI * angularImpulse
		b1.m_R.Set(b1.m_rotation)
		b2.m_rotation += b2.m_invI * angularImpulse
		b2.m_R.Set(b2.m_rotation)
dim 		 angularError  as variant = b2Math.b2Abs(angularC)

		' //  Solve linear limit constraint.
		if ( me.m_enableLimit && me.m_limitState != b2Joint.e_inactiveLimit)
			' // b2Vec2 r1 = b2Mul(b1->m_R, me.m_localAnchor1)
			tMat = b1.m_R
			r1X = tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y
			r1Y = tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y
			' // b2Vec2 r2 = b2Mul(b2->m_R, me.m_localAnchor2)
			tMat = b2.m_R
			r2X = tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y
			r2Y = tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y
			' // b2Vec2 p1 = b1->m_position + r1
			p1X = b1.m_position.x + r1X
			p1Y = b1.m_position.y + r1Y
			' // b2Vec2 p2 = b2->m_position + r2
			p2X = b2.m_position.x + r2X
			p2Y = b2.m_position.y + r2Y
			' // b2Vec2 d = p2 - p1
			dX = p2X - p1X
			dY = p2Y - p1Y
			' // b2Vec2 ax1 = b2Mul(b1->m_R, me.m_localXAxis1)
			tMat = b1.m_R
dim 			 ax1X  as variant = tMat.col1.x * me.m_localXAxis1.x + tMat.col2.x * me.m_localXAxis1.y

dim 			 ax1Y  as variant = tMat.col1.y * me.m_localXAxis1.x + tMat.col2.y * me.m_localXAxis1.y

			' // float32 translation = b2Dot(ax1, d)
dim 			 translation  as variant = (ax1X*dX + ax1Y*dY)

dim 			 limitImpulse  as variant = 0.0

			if ( me.m_limitState == b2Joint.e_equalLimits)
			
				' //  Prevent large angular corrections
				limitC = b2Math.b2Clamp(translation, -b2Settings.b2_maxLinearCorrection, b2Settings.b2_maxLinearCorrection)
				limitImpulse = - me.m_motorMass * limitC
				positionError = b2Math.b2Max(positionError, b2Math.b2Abs(angularC))
			
			else if ( me.m_limitState == b2Joint.e_atLowerLimit)
			
				limitC = translation - me.m_lowerTranslation
				positionError = b2Math.b2Max(positionError, -limitC)
				' //  Prevent large linear corrections and allow some slop.
				limitC = b2Math.b2Clamp(limitC + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0.0)
				limitImpulse = - me.m_motorMass * limitC
				oldLimitImpulse = me.m_limitPositionImpulse
				 me.m_limitPositionImpulse = b2Math.b2Max( me.m_limitPositionImpulse + limitImpulse, 0.0)
				limitImpulse = me.m_limitPositionImpulse - oldLimitImpulse
			
			else if ( me.m_limitState == b2Joint.e_atUpperLimit)
			
				limitC = translation - me.m_upperTranslation
				positionError = b2Math.b2Max(positionError, limitC)
				' //  Prevent large linear corrections and allow some slop.
				limitC = b2Math.b2Clamp(limitC - b2Settings.b2_linearSlop, 0.0, b2Settings.b2_maxLinearCorrection)
				limitImpulse = - me.m_motorMass * limitC
				oldLimitImpulse = me.m_limitPositionImpulse
				 me.m_limitPositionImpulse = b2Math.b2Min( me.m_limitPositionImpulse + limitImpulse, 0.0)
				limitImpulse = me.m_limitPositionImpulse - oldLimitImpulse
			
			' // b1->m_position += (invMass1 * limitImpulse) * me.m_motorJacobian.linear1
			b1.m_position.x += (invMass1 * limitImpulse) * me.m_motorJacobian.linear1.x
			b1.m_position.y += (invMass1 * limitImpulse) * me.m_motorJacobian.linear1.y
			' // b1->m_rotation += invI1 * limitImpulse * me.m_motorJacobian.angular1
			b1.m_rotation += invI1 * limitImpulse * me.m_motorJacobian.angular1
			b1.m_R.Set(b1.m_rotation)
			' // b2->m_position += (invMass2 * limitImpulse) * me.m_motorJacobian.linear2
			b2.m_position.x += (invMass2 * limitImpulse) * me.m_motorJacobian.linear2.x
			b2.m_position.y += (invMass2 * limitImpulse) * me.m_motorJacobian.linear2.y
			' // b2->m_rotation += invI2 * limitImpulse * me.m_motorJacobian.angular2
			b2.m_rotation += invI2 * limitImpulse * me.m_motorJacobian.angular2
			b2.m_R.Set(b2.m_rotation)
		return positionError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop
 '' TODO: posible funcion (revisar)

Public 1: new b2Vec2(), as new 2Vec2(),
Public 2: new b2Vec2(), as new 2Vec2(),
Public 1: new b2Vec2(), as new 2Vec2(),
Public 1: new b2Vec2(), as new 2Vec2(),
	m_initialAngle: null
Public n: new b2Jacobian(), as new 2Jacobian(),
	m_linearMass: null
	m_linearImpulse: null
	m_angularMass: null
	m_angularImpulse: null
Public n: new b2Jacobian(), as new 2Jacobian(),
	m_motorMass: null
	m_motorImpulse: null
	m_limitImpulse: null
	m_limitPositionImpulse: null
	m_lowerTranslation: null
	m_upperTranslation: null
	m_maxMotorForce: null
	m_motorSpeed: null
	m_enableLimit: null
	m_enableMotor: null
	m_limitState: 0)