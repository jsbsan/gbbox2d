' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2Math  as variant = Class.create()

b2Math.prototype = 
	' /* static public function b2InvSqrt(x)
		float32 xhalf = 0.5f * x
		int32 i = *(int32*)&x
		i = 0x5f3759df - (i >> 1)
		x = *(float32*)&i
		x = x * (1.5f - xhalf * x * x)
		return x
 '' TODO: posible funcion (revisar)

	*/
	' //  A * B
	' //  A^T * B
	' //  b2Math.b2Random number in range [-1,1]
	' /* inline float32 b2Math.b2Random(float32 lo, float32 hi)
		float32 r = (float32)rand()
		r /= RAND_MAX
		r = (hi - lo) * r + lo
		return r
 '' TODO: posible funcion (revisar)

	*/
	' //  "Next Largest Power of 2
	' //  Given a binary integer value x, the next largest power of 2 can be computed by a SWAR algorithm
	' //  that recursively "folds" the upper bits into the lower bits. This process yields a bit vector with
	' //  the same most significant 1, but all 1's below it. Adding 1 to that value yields the next
	' //  largest power of 2. For a 32-bit value:"
	' //  Temp vector functions to reduce calls to 'new'
	' /* static public var tempVec = new b2Vec2()
	static public var tempAABB = new b2AABB()
	*/
public  sub 	initialize()
 
public  sub b2IsValid (x as variant) as variant ''funcion
		return isFinite(x)
 '' TODO: posible funcion (revisar)

end

public  sub b2Dot (a as variant, b as variant) as variant ''funcion
		return a.x * b.x + a.y * b.y
 '' TODO: posible funcion (revisar)

end

public  sub b2CrossVV (a as variant, b as variant) as variant ''funcion
		return a.x * b.y - a.y * b.x
 '' TODO: posible funcion (revisar)

end

public  sub b2CrossVF (a as variant, s as variant) as variant ''funcion
dim 		 v  as variant = new b2Vec2(s * a.y, -s * a.x)

		return v
 '' TODO: posible funcion (revisar)

end

public  sub b2CrossFV (s as variant, a as variant) as variant ''funcion
dim 		 v  as variant = new b2Vec2(-s * a.y, s * a.x)

		return v
 '' TODO: posible funcion (revisar)

end

public  sub b2MulMV (A as variant, v as variant) as variant ''funcion
dim 		 u  as variant = new b2Vec2(A.col1.x * v.x + A.col2.x * v.y, A.col1.y * v.x + A.col2.y * v.y)

		return u
 '' TODO: posible funcion (revisar)

end

public  sub b2MulTMV (A as variant, v as variant) as variant ''funcion
dim 		 u  as variant = new b2Vec2(b2Math.b2Dot(v, A.col1), b2Math.b2Dot(v, A.col2))

		return u
 '' TODO: posible funcion (revisar)

end

public  sub AddVV (a as variant, b as variant) as variant ''funcion
dim 		 v  as variant = new b2Vec2(a.x + b.x, a.y + b.y)

		return v
 '' TODO: posible funcion (revisar)

end

public  sub SubtractVV (a as variant, b as variant) as variant ''funcion
dim 		 v  as variant = new b2Vec2(a.x - b.x, a.y - b.y)

		return v
 '' TODO: posible funcion (revisar)

end

public  sub MulFV (s as variant, a as variant) as variant ''funcion
dim 		 v  as variant = new b2Vec2(s * a.x, s * a.y)

		return v
 '' TODO: posible funcion (revisar)

end

public  sub AddMM (A as variant, B as variant) as variant ''funcion
dim 		 C  as variant = new b2Mat22(0, b2Math.AddVV(A.col1, B.col1), b2Math.AddVV(A.col2, B.col2))

		return C
 '' TODO: posible funcion (revisar)

end

public  sub b2MulMM (A as variant, B as variant) as variant ''funcion
dim 		 C  as variant = new b2Mat22(0, b2Math.b2MulMV(A, B.col1), b2Math.b2MulMV(A, B.col2))

		return C
 '' TODO: posible funcion (revisar)

end

public  sub b2MulTMM (A as variant, B as variant) as variant ''funcion
dim 		 c1  as variant = new b2Vec2(b2Math.b2Dot(A.col1, B.col1), b2Math.b2Dot(A.col2, B.col1))

dim 		 c2  as variant = new b2Vec2(b2Math.b2Dot(A.col1, B.col2), b2Math.b2Dot(A.col2, B.col2))

dim 		 C  as variant = new b2Mat22(0, c1, c2)

		return C
 '' TODO: posible funcion (revisar)

end

public  sub b2Abs (a as variant) as variant ''funcion
		return a > 0.0 ? a : -a
 '' TODO: posible funcion (revisar)

end

public  sub b2AbsV (a as variant) as variant ''funcion
dim 		 b  as variant = new b2Vec2(b2Math.b2Abs(a.x), b2Math.b2Abs(a.y))

		return b
 '' TODO: posible funcion (revisar)

end

public  sub b2AbsM (A as variant) as variant ''funcion
dim 		 B  as variant = new b2Mat22(0, b2Math.b2AbsV(A.col1), b2Math.b2AbsV(A.col2))

		return B
 '' TODO: posible funcion (revisar)

end

public  sub b2Min (a as variant, b as variant) as variant ''funcion
		return a < b ? a : b
 '' TODO: posible funcion (revisar)

end

public  sub b2MinV (a as variant, b as variant) as variant ''funcion
dim 		 c  as variant = new b2Vec2(b2Math.b2Min(a.x, b.x), b2Math.b2Min(a.y, b.y))

		return c
 '' TODO: posible funcion (revisar)

end

public  sub b2Max (a as variant, b as variant) as variant ''funcion
		return a > b ? a : b
 '' TODO: posible funcion (revisar)

end

public  sub b2MaxV (a as variant, b as variant) as variant ''funcion
dim 		 c  as variant = new b2Vec2(b2Math.b2Max(a.x, b.x), b2Math.b2Max(a.y, b.y))

		return c
 '' TODO: posible funcion (revisar)

end

public  sub b2Clamp (a as variant, low as variant, high as variant) as variant ''funcion
		return b2Math.b2Max(low, b2Math.b2Min(a, high))
 '' TODO: posible funcion (revisar)

end

public  sub b2ClampV (a as variant, low as variant, high as variant) as variant ''funcion
		return b2Math.b2MaxV(low, b2Math.b2MinV(a, high))
 '' TODO: posible funcion (revisar)

end

public  sub b2Swap (a as variant, b as variant)

dim 		 tmp  as variant = a[0]

		a[0] = b[0]
		b[0] = tmp
end

public  sub b2Random () as variant ''funcion
		return Math.random() * 2 - 1
 '' TODO: posible funcion (revisar)

end

public  sub b2NextPowerOfTwo (x as variant) as variant ''funcion
		x |= (x >> 1) & 0x7FFFFFFF
		x |= (x >> 2) & 0x3FFFFFFF
		x |= (x >> 4) & 0x0FFFFFFF
		x |= (x >> 8) & 0x00FFFFFF
		x |= (x >> 16)& 0x0000FFFF
		return x + 1
 '' TODO: posible funcion (revisar)

end

public  sub b2IsPowerOfTwo (x as variant) as variant ''funcion
dim 		 result  as variant = x > 0 && (x & (x - 1)) == 0

		return result
 '' TODO: posible funcion (revisar)

b2Math.tempVec2 = new b2Vec2()
b2Math.tempVec3 = new b2Vec2()
b2Math.tempVec4 = new b2Vec2()
b2Math.tempVec5 = new b2Vec2()
b2Math.tempMat = new b2Mat22()
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2Mat22  as variant = Class.create()

b2Mat22.prototype = 
end

public  sub 	initialize(angle as variant, c1 as variant, c2 as variant)

		if (angle==null) angle = 0
		' //  initialize instance variables for references
		 me.col1 = new b2Vec2()
		 me.col2 = new b2Vec2()
		' // 
		if (c1!=null && c2!=null)
			 me.col1.SetV(c1)
			 me.col2.SetV(c2)
		else
dim 			 c  as variant = Math.cos(angle)

dim 			 s  as variant = Math.sin(angle)

			 me.col1.x = c
 me.col2.x = -s
			 me.col1.y = s
 me.col2.y = c
end

public  sub 	Set(angle as variant)

dim 		 c  as variant = Math.cos(angle)

dim 		 s  as variant = Math.sin(angle)

		 me.col1.x = c
 me.col2.x = -s
		 me.col1.y = s
 me.col2.y = c
end

public  sub 	SetVV(c1 as variant, c2 as variant)

		 me.col1.SetV(c1)
		 me.col2.SetV(c2)
end

public  sub 	Copy() as variant ''funcion
		return new b2Mat22(0, me.col1, me.col2)
 '' TODO: posible funcion (revisar)

end

public  sub 	SetM(m as variant)

		 me.col1.SetV(m.col1)
		 me.col2.SetV(m.col2)
end

public  sub 	AddM(m as variant)

		 me.col1.x += m.col1.x
		 me.col1.y += m.col1.y
		 me.col2.x += m.col2.x
		 me.col2.y += m.col2.y
end

public  sub 	SetIdentity()

		 me.col1.x = 1.0
 me.col2.x = 0.0
		 me.col1.y = 0.0
 me.col2.y = 1.0
end

public  sub 	SetZero()

		 me.col1.x = 0.0
 me.col2.x = 0.0
		 me.col1.y = 0.0
 me.col2.y = 0.0
end

public  sub 	Invert(out as variant) as variant ''funcion
dim 		 a  as variant = me.col1.x

dim 		 b  as variant = me.col2.x

dim 		 c  as variant = me.col1.y

dim 		 d  as variant = me.col2.y

		' // var B = new b2Mat22()
dim 		 det  as variant = a * d - b * c

		' // b2Settings.b2Assert(det != 0.0)
		det = 1.0 / det
		out.col1.x =  det * d
	out.col2.x = -det * b
		out.col1.y = -det * c
	out.col2.y =  det * a
		return out
 '' TODO: posible funcion (revisar)

	' //  me.Solve A * x = b
end

public  sub 	Solve(out as variant, bX as variant, bY as variant) as variant ''funcion
		' // float32 a11 = me.col1.x, a12 = me.col2.x, a21 = me.col1.y, a22 = me.col2.y
dim 		 a11  as variant = me.col1.x

dim 		 a12  as variant = me.col2.x

dim 		 a21  as variant = me.col1.y

dim 		 a22  as variant = me.col2.y

		' // float32 det = a11 * a22 - a12 * a21
dim 		 det  as variant = a11 * a22 - a12 * a21

		' // b2Settings.b2Assert(det != 0.0)
		det = 1.0 / det
		out.x = det * (a22 * bX - a12 * bY)
		out.y = det * (a11 * bY - a21 * bX)
		return out
 '' TODO: posible funcion (revisar)

end

public  sub 	Abs()

		 me.col1.Abs()
		 me.col2.Abs()
Public 1: new b2Vec2(), as new 2Vec2(),
Public 2: new b2Vec2()
 as new 2Vec2()

﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  b2Vec2 has no constructor so that it
' //  can be placed in a union.
dim  b2Vec2  as variant = Class.create()

b2Vec2.prototype = 
end

public  sub 	initialize(x_ as variant, y_ as variant)
  me.x=x_
 me.y=y_
end

public  sub 	SetZero()
  me.x = 0.0
 me.y = 0.0
 
end

public  sub 	Set(x_ as variant, y_ as variant)
  me.x=x_
 me.y=y_
end

public  sub 	SetV(v as variant)
  me.x=v.x
 me.y=v.y
end

public  sub 	Negative()
 return new b2Vec2(- me.x, - me.y)
  '' TODO: posible funcion (revisar)

end

public  sub 	Copy() as variant ''funcion
		return new b2Vec2( me.x, me.y)
 '' TODO: posible funcion (revisar)

end

public  sub 	Add(v as variant)

		 me.x += v.x
 me.y += v.y
end

public  sub 	Subtract(v as variant)

		 me.x -= v.x
 me.y -= v.y
end

public  sub 	Multiply(a as variant)

		 me.x *= a
 me.y *= a
end

public  sub 	MulM(A as variant)

dim 		 tX  as variant = me.x

		 me.x = A.col1.x * tX + A.col2.x * me.y
		 me.y = A.col1.y * tX + A.col2.y * me.y
end

public  sub 	MulTM(A as variant)

dim 		 tX  as variant = b2Math.b2Dot(this, A.col1)

		 me.y = b2Math.b2Dot(this, A.col2)
		 me.x = tX
end

public  sub 	CrossVF(s as variant)

dim 		 tX  as variant = me.x

		 me.x = s * me.y
		 me.y = -s * tX
end

public  sub 	CrossFV(s as variant)

dim 		 tX  as variant = me.x

		 me.x = -s * me.y
		 me.y = s * tX
end

public  sub 	MinV(b as variant)

		 me.x = me.x < b.x ? me.x : b.x
		 me.y = me.y < b.y ? me.y : b.y
end

public  sub 	MaxV(b as variant)

		 me.x = me.x > b.x ? me.x : b.x
		 me.y = me.y > b.y ? me.y : b.y
end

public  sub 	Abs()

		 me.x = Math.abs( me.x)
		 me.y = Math.abs( me.y)
end

public  sub 	Length() as variant ''funcion
		return Math.sqrt( me.x * me.x + me.y * me.y)
 '' TODO: posible funcion (revisar)

end

public  sub 	Normalize() as variant ''funcio as variant ''funcion
dim 		 length  as variant = me.Length()

		if (length < Number.MIN_VALUE)
			return 0.0
 '' TODO: posible funcion (revisar)

dim 		 invLength  as variant = 1.0 / length

		 me.x *= invLength
		 me.y *= invLength
		return length
 '' TODO: posible funcion (revisar)

end

public  sub 	IsValid() as variant ''funcion
		return b2Math.b2IsValid( me.x) && b2Math.b2IsValid( me.y)
 '' TODO: posible funcion (revisar)

	x: null
	y: null
end

public  sub Make (x_ as variant, y_ as variant) as variant ''funcion
		return new b2Vec2(x_, y_)
 '' TODO: posible funcion (revisar)

﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2Settings  as variant = Class.create()

b2Settings.prototype = 
	' //  Define your unit system here. The default system is
	' //  meters-kilograms-seconds. For the tuning to work well
	' //  your dynamic objects should be bigger than a pebble and smaller
	' //  than a house.
	' // static public const b2Settings.b2_lengthUnitsPerMeter = 1.0
	' //  Use this for pixels:
	' //  Global tuning constants based on MKS units.
	' //  Collision
	' //  Dynamics
	' //  Sleep
	' //  assert
end

public  sub 	initialize()
 
b2Settings.USHRT_MAX = 0x0000ffff
b2Settings.b2_pi = Math.PI
b2Settings.b2_massUnitsPerKilogram = 1.0
b2Settings.b2_timeUnitsPerSecond = 1.0
b2Settings.b2_lengthUnitsPerMeter = 30.0
b2Settings.b2_maxManifoldPoints = 2
b2Settings.b2_maxShapesPerBody = 64
b2Settings.b2_maxPolyVertices = 8
b2Settings.b2_maxProxies = 1024
b2Settings.b2_maxPairs = 8 * b2Settings.b2_maxProxies
b2Settings.b2_linearSlop = 0.005 * b2Settings.b2_lengthUnitsPerMeter
b2Settings.b2_angularSlop = 2.0 / 180.0 * b2Settings.b2_pi
b2Settings.b2_velocityThreshold = 1.0 * b2Settings.b2_lengthUnitsPerMeter / b2Settings.b2_timeUnitsPerSecond
b2Settings.b2_maxLinearCorrection = 0.2 * b2Settings.b2_lengthUnitsPerMeter
b2Settings.b2_maxAngularCorrection = 8.0 / 180.0 * b2Settings.b2_pi
b2Settings.b2_contactBaumgarte = 0.2
b2Settings.b2_timeToSleep = 0.5 * b2Settings.b2_timeUnitsPerSecond
b2Settings.b2_linearSleepTolerance = 0.01 * b2Settings.b2_lengthUnitsPerMeter / b2Settings.b2_timeUnitsPerSecond
b2Settings.b2_angularSleepTolerance = 2.0 / 180.0 / b2Settings.b2_timeUnitsPerSecond
end

public  sub b2Assert (a as variant)

		if (!a)
dim 			nullVec
 as variant
			nullVec.x++
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2CircleDef  as variant = Class.create()

inherits , b2ShapeDef
inherits 
end

public  sub 	initialize()

		' //  The constructor for b2ShapeDef
		 me.type = b2Shape.e_unknownShape
		 me.userData = null
		 me.localPosition = new b2Vec2(0.0, 0.0)
		 me.localRotation = 0.0
		 me.friction = 0.2
		 me.restitution = 0.0
		 me.density = 0.0
		 me.categoryBits = 0x0001
		 me.maskBits = 0xFFFF
		 me.groupIndex = 0
	
		' // 
		 me.type = b2Shape.e_circleShape
		 me.radius = 1.0
	radius: null)
' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  A convex polygon. The position of the polygon (m_position) is the
' //  position of the centroid. The vertices of the incoming polygon are pre-rotated
' //  according to the local rotation. The vertices are also shifted to be centered
' //  on the centroid. Since the local rotation is absorbed into the vertex
' //  coordinates, the polygon rotation is equal to the body rotation. However
' //  the polygon position is centered on the polygon centroid. This simplifies
' //  some collision algorithms.
dim  b2PolyShape  as variant = Class.create()

inherits , b2Shape
inherits 
end

public  sub 	TestPoint(p as variant) as variant ''funcio as variant ''funcion
		' // var pLocal = b2Math.b2MulTMV( me.m_R, b2Math.SubtractVV(p, me.m_position))
dim 		 pLocal  as variant = new b2Vec2()

		pLocal.SetV(p)
		pLocal.Subtract( me.m_position)
		pLocal.MulTM( me.m_R)
		for (var i = 0; i < me.m_vertexCount; ++i)
			' // var dot = b2Math.b2Dot( me.m_normals[i], b2Math.SubtractVV(pLocal, me.m_vertices[i]))
dim 			 tVec  as variant = new b2Vec2()

			tVec.SetV(pLocal)
			tVec.Subtract( me.m_vertices[i])
dim 			 dot  as variant = b2Math.b2Dot( me.m_normals[i], tVec)

			if (dot > 0.0)
			
				return false
 '' TODO: posible funcion (revisar)

			
		return true
 '' TODO: posible funcion (revisar)

	' // --------------- Internals Below -------------------
	' //  Temp vec for b2Shape.PolyCentroid
end

public  sub 	initialize(def as variant, body as variant, newOrigin as variant)

		' //  initialize instance variables for references
		 me.m_R = new b2Mat22()
		 me.m_position = new b2Vec2()
		' // 
		' //  The constructor for b2Shape
		 me.m_userData = def.userData
		 me.m_friction = def.friction
		 me.m_restitution = def.restitution
		 me.m_body = body
		 me.m_proxyId = b2Pair.b2_nullProxy
		 me.m_maxRadius = 0.0
		 me.m_categoryBits = def.categoryBits
		 me.m_maskBits = def.maskBits
		 me.m_groupIndex = def.groupIndex
		' // 
		' //  initialize instance variables for references
		 me.syncAABB = new b2AABB()
		 me.syncMat = new b2Mat22()
		 me.m_localCentroid = new b2Vec2()
		 me.m_localOBB = new b2OBB()
		' // 
		' // super(def, body)
dim 		 i  as variant = 0

dim 		hX
 as variant
dim 		hY
 as variant
dim 		tVec
 as variant
dim 		 aabb  as variant = new b2AABB()

		' //  Vertices
		 me.m_vertices = new Array(b2Settings.b2_maxPolyVertices)
		 me.m_coreVertices = new Array(b2Settings.b2_maxPolyVertices)
		' // for (i = 0; i < b2Settings.b2_maxPolyVertices; i++)
		' // 	 me.m_vertices[i] = new b2Vec2()
		' //  Normals
		 me.m_normals = new Array(b2Settings.b2_maxPolyVertices)
		' // for (i = 0; i < b2Settings.b2_maxPolyVertices; i++)
		' // 	 me.m_normals[i] = new b2Vec2()
		' // b2Settings.b2Assert(def.type == b2Shape.e_boxShape || def.type == b2Shape.e_polyShape)
		 me.m_type = b2Shape.e_polyShape
dim 		 localR  as variant = new b2Mat22(def.localRotation)

		' //  Get the vertices transformed into the body frame.
		if (def.type == b2Shape.e_boxShape)
			' // me.m_localCentroid = def.localPosition - newOrigin
			 me.m_localCentroid.x = def.localPosition.x - newOrigin.x
			 me.m_localCentroid.y = def.localPosition.y - newOrigin.y
dim 			 box  as variant = def

			 me.m_vertexCount = 4
			hX = box.extents.x
			hY = box.extents.y
			' // hc.x = b2Max(0.0f, h.x - 2.0f * b2_linearSlop)
dim 			 hcX  as variant = Math.max(0.0, hX - 2.0 * b2Settings.b2_linearSlop)

			' // hc.y = b2Max(0.0f, h.y - 2.0f * b2_linearSlop)
dim 			 hcY  as variant = Math.max(0.0, hY - 2.0 * b2Settings.b2_linearSlop)

			' // me.m_vertices[0] = b2Mul(localR, b2Vec2(h.x, h.y))
			tVec = me.m_vertices[0] = new b2Vec2()
			tVec.x = localR.col1.x * hX + localR.col2.x * hY
			tVec.y = localR.col1.y * hX + localR.col2.y * hY
			' // me.m_vertices[1] = b2Mul(localR, b2Vec2(-h.x, h.y))
			tVec = me.m_vertices[1] = new b2Vec2()
			tVec.x = localR.col1.x * -hX + localR.col2.x * hY
			tVec.y = localR.col1.y * -hX + localR.col2.y * hY
			' // me.m_vertices[2] = b2Mul(localR, b2Vec2(-h.x, -h.y))
			tVec = me.m_vertices[2] = new b2Vec2()
			tVec.x = localR.col1.x * -hX + localR.col2.x * -hY
			tVec.y = localR.col1.y * -hX + localR.col2.y * -hY
			' // me.m_vertices[3] = b2Mul(localR, b2Vec2(h.x, -h.y))
			tVec = me.m_vertices[3] = new b2Vec2()
			tVec.x = localR.col1.x * hX + localR.col2.x * -hY
			tVec.y = localR.col1.y * hX + localR.col2.y * -hY
			' // me.m_coreVertices[0] = b2Mul(localR, b2Vec2(hc.x, hc.y))
			tVec = me.m_coreVertices[0] = new b2Vec2()
			tVec.x = localR.col1.x * hcX + localR.col2.x * hcY
			tVec.y = localR.col1.y * hcX + localR.col2.y * hcY
			' // me.m_coreVertices[1] = b2Mul(localR, b2Vec2(-hc.x, hc.y))
			tVec = me.m_coreVertices[1] = new b2Vec2()
			tVec.x = localR.col1.x * -hcX + localR.col2.x * hcY
			tVec.y = localR.col1.y * -hcX + localR.col2.y * hcY
			' // me.m_coreVertices[2] = b2Mul(localR, b2Vec2(-hc.x, -hc.y))
			tVec = me.m_coreVertices[2] = new b2Vec2()
			tVec.x = localR.col1.x * -hcX + localR.col2.x * -hcY
			tVec.y = localR.col1.y * -hcX + localR.col2.y * -hcY
			' // me.m_coreVertices[3] = b2Mul(localR, b2Vec2(hc.x, -hc.y))
			tVec = me.m_coreVertices[3] = new b2Vec2()
			tVec.x = localR.col1.x * hcX + localR.col2.x * -hcY
			tVec.y = localR.col1.y * hcX + localR.col2.y * -hcY
		else
dim 			 poly  as variant = def

			 me.m_vertexCount = poly.vertexCount
			' // b2Settings.b2Assert(3 <= me.m_vertexCount && me.m_vertexCount <= b2Settings.b2_maxPolyVertices)
			' // b2Vec2 centroid = b2Shape.PolyCentroid(poly->vertices, poly->vertexCount)
			b2Shape.PolyCentroid(poly.vertices, poly.vertexCount, b2PolyShape.tempVec)
dim 			 centroidX  as variant = b2PolyShape.tempVec.x

dim 			 centroidY  as variant = b2PolyShape.tempVec.y

			' // me.m_localCentroid = def->localPosition + b2Mul(localR, centroid) - newOrigin
			 me.m_localCentroid.x = def.localPosition.x + (localR.col1.x * centroidX + localR.col2.x * centroidY) - newOrigin.x
			 me.m_localCentroid.y = def.localPosition.y + (localR.col1.y * centroidX + localR.col2.y * centroidY) - newOrigin.y
			for (i = 0; i < me.m_vertexCount; ++i)
			
				 me.m_vertices[i] = new b2Vec2()
				 me.m_coreVertices[i] = new b2Vec2()
				' // me.m_vertices[i] = b2Mul(localR, poly->vertices[i] - centroid)
				hX = poly.vertices[i].x - centroidX
				hY = poly.vertices[i].y - centroidY
				 me.m_vertices[i].x = localR.col1.x * hX + localR.col2.x * hY
				 me.m_vertices[i].y = localR.col1.y * hX + localR.col2.y * hY
				' // b2Vec2 u = me.m_vertices[i]
dim 				 uX  as variant = me.m_vertices[i].x

dim 				 uY  as variant = me.m_vertices[i].y

				' // float32 length = u.Length()
dim 				 length  as variant = Math.sqrt(uX*uX + uY*uY)

				if (length > Number.MIN_VALUE)
				
					uX *= 1.0 / length
					uY *= 1.0 / length
				
				' // me.m_coreVertices[i] = me.m_vertices[i] - 2.0f * b2_linearSlop * u
				 me.m_coreVertices[i].x = me.m_vertices[i].x - 2.0 * b2Settings.b2_linearSlop * uX
				 me.m_coreVertices[i].y = me.m_vertices[i].y - 2.0 * b2Settings.b2_linearSlop * uY
			
		' //  Compute bounding box. TODO_ERIN optimize OBB
		' // var minVertex = new b2Vec2(Number.MAX_VALUE, Number.MAX_VALUE)
dim 		 minVertexX  as variant = Number.MAX_VALUE

dim 		 minVertexY  as variant = Number.MAX_VALUE

dim 		 maxVertexX  as variant = -Number.MAX_VALUE

dim 		 maxVertexY  as variant = -Number.MAX_VALUE

		 me.m_maxRadius = 0.0
		for (i = 0; i < me.m_vertexCount; ++i)
dim 			 v  as variant = me.m_vertices[i]

			' // minVertex = b2Math.b2MinV(minVertex, me.m_vertices[i])
			minVertexX = Math.min(minVertexX, v.x)
			minVertexY = Math.min(minVertexY, v.y)
			' // maxVertex = b2Math.b2MaxV(maxVertex, me.m_vertices[i])
			maxVertexX = Math.max(maxVertexX, v.x)
			maxVertexY = Math.max(maxVertexY, v.y)
			' // me.m_maxRadius = b2Max( me.m_maxRadius, v.Length())
			 me.m_maxRadius = Math.max( me.m_maxRadius, v.Length())
		 me.m_localOBB.R.SetIdentity()
		' // me.m_localOBB.center = 0.5 * (minVertex + maxVertex)
		 me.m_localOBB.center.Set((minVertexX + maxVertexX) * 0.5, (minVertexY + maxVertexY) * 0.5)
		' // me.m_localOBB.extents = 0.5 * (maxVertex - minVertex)
		 me.m_localOBB.extents.Set((maxVertexX - minVertexX) * 0.5, (maxVertexY - minVertexY) * 0.5)
		' //  Compute the edge normals and next index map.
dim 		 i1  as variant = 0

dim 		 i2  as variant = 0

		for (i = 0; i < me.m_vertexCount; ++i)
			 me.m_normals[i] =  new b2Vec2()
			i1 = i
			i2 = i + 1 < me.m_vertexCount ? i + 1 : 0
			' // b2Vec2 edge = me.m_vertices[i2] - me.m_vertices[i1]
			' // var edgeX = me.m_vertices[i2].x - me.m_vertices[i1].x
			' // var edgeY = me.m_vertices[i2].y - me.m_vertices[i1].y
			' // me.m_normals[i] = b2Cross(edge, 1.0f)
			 me.m_normals[i].x = me.m_vertices[i2].y - me.m_vertices[i1].y
			 me.m_normals[i].y = -( me.m_vertices[i2].x - me.m_vertices[i1].x)
			 me.m_normals[i].Normalize()
		' //  Ensure the polygon in convex. TODO_ERIN compute convex hull.
		for (i = 0; i < me.m_vertexCount; ++i)
			i1 = i
			i2 = i + 1 < me.m_vertexCount ? i + 1 : 0
			' // b2Settings.b2Assert(b2Math.b2CrossVV( me.m_normals[i1], me.m_normals[i2]) > Number.MIN_VALUE)
		 me.m_R.SetM( me.m_body.m_R)
		' // me.m_position.SetV( me.m_body.m_position  + b2Mul( me.m_body-> me.m_R, me.m_localCentroid) )
		 me.m_position.x = me.m_body.m_position.x + ( me.m_R.col1.x * me.m_localCentroid.x + me.m_R.col2.x * me.m_localCentroid.y)
		 me.m_position.y = me.m_body.m_position.y + ( me.m_R.col1.y * me.m_localCentroid.x + me.m_R.col2.y * me.m_localCentroid.y)
		' // var R = b2Math.b2MulMM( me.m_R, me.m_localOBB.R)
			' // R.col1 = b2MulMV( me.m_R, me.m_localOBB.R.col1)
			b2PolyShape.tAbsR.col1.x = me.m_R.col1.x * me.m_localOBB.R.col1.x + me.m_R.col2.x * me.m_localOBB.R.col1.y
			b2PolyShape.tAbsR.col1.y = me.m_R.col1.y * me.m_localOBB.R.col1.x + me.m_R.col2.y * me.m_localOBB.R.col1.y
			' // R.col2 = b2MulMV( me.m_R, me.m_localOBB.R.col2)
			b2PolyShape.tAbsR.col2.x = me.m_R.col1.x * me.m_localOBB.R.col2.x + me.m_R.col2.x * me.m_localOBB.R.col2.y
			b2PolyShape.tAbsR.col2.y = me.m_R.col1.y * me.m_localOBB.R.col2.x + me.m_R.col2.y * me.m_localOBB.R.col2.y
		' // var absR = b2Math.b2AbsM(R)
		b2PolyShape.tAbsR.Abs()
		' // h = b2Math.b2MulMV(b2PolyShape.tAbsR, me.m_localOBB.extents)
		hX = b2PolyShape.tAbsR.col1.x * me.m_localOBB.extents.x + b2PolyShape.tAbsR.col2.x * me.m_localOBB.extents.y
		hY = b2PolyShape.tAbsR.col1.y * me.m_localOBB.extents.x + b2PolyShape.tAbsR.col2.y * me.m_localOBB.extents.y
		' // var position = me.m_position + b2Mul( me.m_R, me.m_localOBB.center)
dim 		 positionX  as variant = me.m_position.x + ( me.m_R.col1.x * me.m_localOBB.center.x + me.m_R.col2.x * me.m_localOBB.center.y)

dim 		 positionY  as variant = me.m_position.y + ( me.m_R.col1.y * me.m_localOBB.center.x + me.m_R.col2.y * me.m_localOBB.center.y)

		' // aabb.minVertex = b2Math.SubtractVV( me.m_position, h)
		aabb.minVertex.x = positionX - hX
		aabb.minVertex.y = positionY - hY
		' // aabb.maxVertex = b2Math.AddVV( me.m_position, h)
		aabb.maxVertex.x = positionX + hX
		aabb.maxVertex.y = positionY + hY
dim 		 broadPhase  as variant = me.m_body.m_world.m_broadPhase

		if (broadPhase.InRange(aabb))
			 me.m_proxyId = broadPhase.CreateProxy(aabb, this)
		else
			 me.m_proxyId = b2Pair.b2_nullProxy
		if ( me.m_proxyId == b2Pair.b2_nullProxy)
			 me.m_body.Freeze()
	' //  Temp AABB for Synch function
Public B: new b2AABB(), as new 2AABB(),
Public t: new b2Mat22(), as new 2Mat22(),
end

public  sub 	Synchronize(position1 as variant, R1 as variant, position2 as variant, R2 as variant) as variant ''funcion
		' //  The body transform is copied for convenience.
		 me.m_R.SetM(R2)
		' // me.m_position = me.m_body-> me.m_position + b2Mul( me.m_body-> me.m_R, me.m_localCentroid)
		 me.m_position.x = me.m_body.m_position.x + (R2.col1.x * me.m_localCentroid.x + R2.col2.x * me.m_localCentroid.y)
		 me.m_position.y = me.m_body.m_position.y + (R2.col1.y * me.m_localCentroid.x + R2.col2.y * me.m_localCentroid.y)
		if ( me.m_proxyId == b2Pair.b2_nullProxy)
			return
 '' TODO: posible funcion (revisar)

		' // b2AABB aabb1, aabb2
dim 		hX
 as variant
dim 		hY
 as variant
		' // b2Mat22 obbR = b2Mul(R1, me.m_localOBB.R)
dim 			 v1  as variant = R1.col1

dim 			 v2  as variant = R1.col2

dim 			 v3  as variant = me.m_localOBB.R.col1

dim 			 v4  as variant = me.m_localOBB.R.col2

			' // me.syncMat.col1 = b2MulMV(R1, me.m_localOBB.R.col1)
			 me.syncMat.col1.x = v1.x * v3.x + v2.x * v3.y
			 me.syncMat.col1.y = v1.y * v3.x + v2.y * v3.y
			' // me.syncMat.col2 = b2MulMV(R1, me.m_localOBB.R.col2)
			 me.syncMat.col2.x = v1.x * v4.x + v2.x * v4.y
			 me.syncMat.col2.y = v1.y * v4.x + v2.y * v4.y
		' // b2Mat22 absR = b2Abs(obbR)
		 me.syncMat.Abs()
		' // b2Vec2 center = position1 + b2Mul(R1, me.m_localCentroid + me.m_localOBB.center)
		hX = me.m_localCentroid.x + me.m_localOBB.center.x
		hY = me.m_localCentroid.y + me.m_localOBB.center.y
dim 		 centerX  as variant = position1.x + (R1.col1.x * hX + R1.col2.x * hY)

dim 		 centerY  as variant = position1.y + (R1.col1.y * hX + R1.col2.y * hY)

		' // b2Vec2 h = b2Mul( me.syncMat, me.m_localOBB.extents)
		hX = me.syncMat.col1.x * me.m_localOBB.extents.x + me.syncMat.col2.x * me.m_localOBB.extents.y
		hY = me.syncMat.col1.y * me.m_localOBB.extents.x + me.syncMat.col2.y * me.m_localOBB.extents.y
		' // aabb1.minVertex = center - h
		 me.syncAABB.minVertex.x = centerX - hX
		 me.syncAABB.minVertex.y = centerY - hY
		' // aabb1.maxVertex = center + h
		 me.syncAABB.maxVertex.x = centerX + hX
		 me.syncAABB.maxVertex.y = centerY + hY
		' // b2Mat22 obbR = b2Mul(R2, me.m_localOBB.R)
			v1 = R2.col1
			v2 = R2.col2
			v3 = me.m_localOBB.R.col1
			v4 = me.m_localOBB.R.col2
			' // me.syncMat.col1 = b2MulMV(R1, me.m_localOBB.R.col1)
			 me.syncMat.col1.x = v1.x * v3.x + v2.x * v3.y
			 me.syncMat.col1.y = v1.y * v3.x + v2.y * v3.y
			' // me.syncMat.col2 = b2MulMV(R1, me.m_localOBB.R.col2)
			 me.syncMat.col2.x = v1.x * v4.x + v2.x * v4.y
			 me.syncMat.col2.y = v1.y * v4.x + v2.y * v4.y
		' // b2Mat22 absR = b2Abs(obbR)
		 me.syncMat.Abs()
		' // b2Vec2 center = position2 + b2Mul(R2, me.m_localCentroid + me.m_localOBB.center)
		hX = me.m_localCentroid.x + me.m_localOBB.center.x
		hY = me.m_localCentroid.y + me.m_localOBB.center.y
		centerX = position2.x + (R2.col1.x * hX + R2.col2.x * hY)
		centerY = position2.y + (R2.col1.y * hX + R2.col2.y * hY)
		' // b2Vec2 h = b2Mul(absR, me.m_localOBB.extents)
		hX = me.syncMat.col1.x * me.m_localOBB.extents.x + me.syncMat.col2.x * me.m_localOBB.extents.y
		hY = me.syncMat.col1.y * me.m_localOBB.extents.x + me.syncMat.col2.y * me.m_localOBB.extents.y
		' // aabb2.minVertex = center - h
		' // aabb2.maxVertex = center + h
		' // aabb.minVertex = b2Min(aabb1.minVertex, aabb2.minVertex)
		 me.syncAABB.minVertex.x = Math.min( me.syncAABB.minVertex.x, centerX - hX)
		 me.syncAABB.minVertex.y = Math.min( me.syncAABB.minVertex.y, centerY - hY)
		' // aabb.maxVertex = b2Max(aabb1.maxVertex, aabb2.maxVertex)
		 me.syncAABB.maxVertex.x = Math.max( me.syncAABB.maxVertex.x, centerX + hX)
		 me.syncAABB.maxVertex.y = Math.max( me.syncAABB.maxVertex.y, centerY + hY)
dim 		 broadPhase  as variant = me.m_body.m_world.m_broadPhase

		if (broadPhase.InRange( me.syncAABB))
			broadPhase.MoveProxy( me.m_proxyId, me.syncAABB)
		else
			 me.m_body.Freeze()
end

public  sub 	QuickSync(position as variant, R as variant)

		' // me.m_R = R
		 me.m_R.SetM(R)
		' // me.m_position = position + b2Mul(R, me.m_localCentroid)
		 me.m_position.x = position.x + (R.col1.x * me.m_localCentroid.x + R.col2.x * me.m_localCentroid.y)
		 me.m_position.y = position.y + (R.col1.y * me.m_localCentroid.x + R.col2.y * me.m_localCentroid.y)
end

public  sub 	ResetProxy(broadPhase as variant) as variant ''funcion
		if ( me.m_proxyId == b2Pair.b2_nullProxy)
			return
 '' TODO: posible funcion (revisar)

dim 		 proxy  as variant = broadPhase.GetProxy( me.m_proxyId)

		broadPhase.DestroyProxy( me.m_proxyId)
		proxy = null
dim 		 R  as variant = b2Math.b2MulMM( me.m_R, me.m_localOBB.R)

dim 		 absR  as variant = b2Math.b2AbsM(R)

dim 		 h  as variant = b2Math.b2MulMV(absR, me.m_localOBB.extents)

		' // var position = me.m_position + b2Mul( me.m_R, me.m_localOBB.center)
dim 		 position  as variant = b2Math.b2MulMV( me.m_R, me.m_localOBB.center)

		position.Add( me.m_position)
dim 		 aabb  as variant = new b2AABB()

		' // aabb.minVertex = position - h
		aabb.minVertex.SetV(position)
		aabb.minVertex.Subtract(h)
		' // aabb.maxVertex = position + h
		aabb.maxVertex.SetV(position)
		aabb.maxVertex.Add(h)
		if (broadPhase.InRange(aabb))
			 me.m_proxyId = broadPhase.CreateProxy(aabb, this)
		else
			 me.m_proxyId = b2Pair.b2_nullProxy
		if ( me.m_proxyId == b2Pair.b2_nullProxy)
			 me.m_body.Freeze()
end

public  sub 	Support(dX as variant, dY as variant, out as variant) as variant ''funcion
		' // b2Vec2 dLocal = b2MulT( me.m_R, d)
dim 		 dLocalX  as variant = (dX* me.m_R.col1.x + dY* me.m_R.col1.y)

dim 		 dLocalY  as variant = (dX* me.m_R.col2.x + dY* me.m_R.col2.y)

dim 		 bestIndex  as variant = 0

		' // float32 bestValue = b2Dot( me.m_vertices[0], dLocal)
dim 		 bestValue  as variant = ( me.m_coreVertices[0].x * dLocalX + me.m_coreVertices[0].y * dLocalY)

		for (var i = 1; i < me.m_vertexCount; ++i)
			' // float32 value = b2Dot( me.m_vertices[i], dLocal)
dim 			 value  as variant = ( me.m_coreVertices[i].x * dLocalX + me.m_coreVertices[i].y * dLocalY)

			if (value > bestValue)
			
				bestIndex = i
				bestValue = value
			
		' // return me.m_position + b2Mul( me.m_R, me.m_vertices[bestIndex])
 '' TODO: posible funcion (revisar)

		out.Set(	 me.m_position.x + ( me.m_R.col1.x * me.m_coreVertices[bestIndex].x + me.m_R.col2.x * me.m_coreVertices[bestIndex].y)
					 me.m_position.y + ( me.m_R.col1.y * me.m_coreVertices[bestIndex].x + me.m_R.col2.y * me.m_coreVertices[bestIndex].y))
	' //  Local position of the shape centroid in parent body frame.
Public d: new b2Vec2(), as new 2Vec2(),
	' //  Local position oriented bounding box. The OBB center is relative to
	' //  shape centroid.
Public B: new b2OBB(), as new 2OBB(),
	m_vertices: null
	m_coreVertices: null
	m_vertexCount: 0
	m_normals: null)
b2PolyShape.tempVec = new b2Vec2()
b2PolyShape.tAbsR = new b2Mat22()
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2PolyDef  as variant = Class.create()

inherits , b2ShapeDef
inherits 
end

public  sub 	initialize()

		' //  The constructor for b2ShapeDef
		 me.type = b2Shape.e_unknownShape
		 me.userData = null
		 me.localPosition = new b2Vec2(0.0, 0.0)
		 me.localRotation = 0.0
		 me.friction = 0.2
		 me.restitution = 0.0
		 me.density = 0.0
		 me.categoryBits = 0x0001
		 me.maskBits = 0xFFFF
		 me.groupIndex = 0
	
		' // 
		' //  initialize instance variables for references
		 me.vertices = new Array(b2Settings.b2_maxPolyVertices)
		' // 
		 me.type = b2Shape.e_polyShape
		 me.vertexCount = 0
		for (var i = 0; i < b2Settings.b2_maxPolyVertices; i++)
			 me.vertices[i] = new b2Vec2()
Public s: new Array(b2Settings.b2_maxPolyVertices), as new rray(b2Settings.b2_maxPolyVertices),
	vertexCount: 0)
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2BoxDef  as variant = Class.create()

inherits , b2ShapeDef
inherits 
end

public  sub 	initialize()

		' //  The constructor for b2ShapeDef
		 me.type = b2Shape.e_unknownShape
		 me.userData = null
		 me.localPosition = new b2Vec2(0.0, 0.0)
		 me.localRotation = 0.0
		 me.friction = 0.2
		 me.restitution = 0.0
		 me.density = 0.0
		 me.categoryBits = 0x0001
		 me.maskBits = 0xFFFF
		 me.groupIndex = 0
	
		' // 
		 me.type = b2Shape.e_boxShape
		 me.extents = new b2Vec2(1.0, 1.0)
	extents: null)
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2ShapeDef  as variant = Class.create()

b2ShapeDef.prototype = 
end

public  sub 	initialize()

		 me.type = b2Shape.e_unknownShape
		 me.userData = null
		 me.localPosition = new b2Vec2(0.0, 0.0)
		 me.localRotation = 0.0
		 me.friction = 0.2
		 me.restitution = 0.0
		 me.density = 0.0
		 me.categoryBits = 0x0001
		 me.maskBits = 0xFFFF
		 me.groupIndex = 0
	' // virtual ~b2ShapeDef() 
end

public  sub 	ComputeMass(massData as variant)

		massData.center = new b2Vec2(0.0, 0.0)
		if ( me.density == 0.0)
			massData.mass = 0.0
			massData.center.Set(0.0, 0.0)
			massData.I = 0.0
		switch ( me.type)
		case b2Shape.e_circleShape:
			
dim 				 circle  as variant = this

				massData.mass = me.density * b2Settings.b2_pi * circle.radius * circle.radius
				massData.center.Set(0.0, 0.0)
				massData.I = 0.5 * (massData.mass) * circle.radius * circle.radius
			
			break
		case b2Shape.e_boxShape:
			
dim 				 box  as variant = this

				massData.mass = 4.0 * me.density * box.extents.x * box.extents.y
				massData.center.Set(0.0, 0.0)
				massData.I = massData.mass / 3.0 * b2Math.b2Dot(box.extents, box.extents)
			
			break
		case b2Shape.e_polyShape:
			
dim 				 poly  as variant = this

				b2Shape.PolyMass(massData, poly.vertices, poly.vertexCount, me.density)
			
			break
		default:
			massData.mass = 0.0
			massData.center.Set(0.0, 0.0)
			massData.I = 0.0
			break
	type: 0
	userData: null
	localPosition: null
	localRotation: null
	friction: null
	restitution: null
	density: null
	' //  The collision category bits. Normally you would just set one bit.
	categoryBits: 0
	' //  The collision mask bits. This states the categories that this
	' //  shape would accept for collision.
	maskBits: 0
	' //  Collision groups allow a certain group of objects to never collide (negative)
	' //  or always collide (positive). Zero means no collision group. Non-zero group
	' //  filtering always wins against the mask bits.
	groupIndex: 0
' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  Shapes are created automatically when a body is created.
' //  Client code does not normally interact with shapes.
dim  b2Shape  as variant = Class.create()

b2Shape.prototype = 
end

public  sub 	TestPoint(p as variant)
return false '' TODO: posible funcion (revisar)

end

public  sub 	GetUserData()
return me.m_userData
 '' TODO: posible funcion (revisar)

end

public  sub 	GetType() as variant ''funcion
		return me.m_type
 '' TODO: posible funcion (revisar)

	' //  Get the parent body of this shape.
end

public  sub 	GetBody() as variant ''funcion
		return me.m_body
 '' TODO: posible funcion (revisar)

end

public  sub 	GetPosition() as variant ''funcion
		return me.m_position
 '' TODO: posible funcion (revisar)

end

public  sub 	GetRotationMatrix() as variant ''funcion
		return me.m_R
 '' TODO: posible funcion (revisar)

	' //  Remove and then add proxy from the broad-phase.
	' //  This is used to refresh the collision filters.
end

public  sub 	ResetProxy(broadPhase as variant)

	' //  Get the next shape in the parent body's shape list.
end

public  sub 	GetNext() as variant ''funcion
		return me.m_next
 '' TODO: posible funcion (revisar)

	' // --------------- Internals Below -------------------
end

public  sub 	initialize(def as variant, body as variant)

		' //  initialize instance variables for references
		 me.m_R = new b2Mat22()
		 me.m_position = new b2Vec2()
		' // 
		 me.m_userData = def.userData
		 me.m_friction = def.friction
		 me.m_restitution = def.restitution
		 me.m_body = body
		 me.m_proxyId = b2Pair.b2_nullProxy
		 me.m_maxRadius = 0.0
		 me.m_categoryBits = def.categoryBits
		 me.m_maskBits = def.maskBits
		 me.m_groupIndex = def.groupIndex
	' //  Internal use only. Do not call.
	' // b2Shape::~b2Shape()
	' // 
	' // 	 me.m_body->m_world->m_broadPhase-> me.DestroyProxy( me.m_proxyId)
	' // 
end

public  sub 	DestroyProxy()

		if ( me.m_proxyId != b2Pair.b2_nullProxy)
			 me.m_body.m_world.m_broadPhase.DestroyProxy( me.m_proxyId)
			 me.m_proxyId = b2Pair.b2_nullProxy
	' //  Internal use only. Do not call.
end

public  sub 	Synchronize(position1 as variant, R1 as variant, position2 as variant, R2 as variant)

end

public  sub 	QuickSync(position as variant, R as variant)

end

public  sub 	Support(dX as variant, dY as variant, out as variant)

end

public  sub 	GetMaxRadius() as variant ''funcion
		return me.m_maxRadius
 '' TODO: posible funcion (revisar)

	m_next: null
Public R: new b2Mat22(), as new 2Mat22(),
Public n: new b2Vec2(), as new 2Vec2(),
	m_type: 0
	m_userData: null
	m_body: null
	m_friction: null
	m_restitution: null
	m_maxRadius: null
	m_proxyId: 0
	m_categoryBits: 0
	m_maskBits: 0
	m_groupIndex: 0
	' //  b2ShapeType
end

public  sub Create (def as variant, body as variant, center as variant) as variant ''funcio as variant ''funcio as variant ''funcion
		switch (def.type)
		case b2Shape.e_circleShape:
			
				' // void* mem = body->m_world->m_blockAllocator.Allocate(sizeof(b2CircleShape))
				return new b2CircleShape(def, body, center)
 '' TODO: posible funcion (revisar)

			
		case b2Shape.e_boxShape:
		case b2Shape.e_polyShape:
			
				' // void* mem = body->m_world->m_blockAllocator.Allocate(sizeof(b2PolyShape))
				return new b2PolyShape(def, body, center)
 '' TODO: posible funcion (revisar)

			
		' // b2Settings.b2Assert(false)
		return null
 '' TODO: posible funcion (revisar)

end

public  sub Destroy (shape as variant)

		' /* b2BlockAllocator& allocator = shape->m_body->m_world->m_blockAllocator
		switch (shape.m_type)
		case b2Shape.e_circleShape:
			shape->~b2Shape()
			allocator.Free(shape, sizeof(b2CircleShape))
			break
		case b2Shape.e_polyShape:
			shape->~b2Shape()
			allocator.Free(shape, sizeof(b2PolyShape))
			break
		default:
			b2Assert(false)
		shape = NULL
*/
		' //  FROM DESTRUCTOR
		if (shape.m_proxyId != b2Pair.b2_nullProxy)
			shape.m_body.m_world.m_broadPhase.DestroyProxy(shape.m_proxyId)
b2Shape.e_unknownShape = -1
b2Shape.e_circleShape = 0
b2Shape.e_boxShape = 1
b2Shape.e_polyShape = 2
b2Shape.e_meshShape = 3
b2Shape.e_shapeTypeCount = 4
end

public  sub PolyMass (massData as variant, vs as variant, count as variant, rho as variant)

		' // b2Settings.b2Assert(count >= 3)
		' // var center = new b2Vec2(0.0, 0.0)
dim 		 center  as variant = new b2Vec2()

		center.SetZero()
dim 		 area  as variant = 0.0

dim 		 I  as variant = 0.0

		' //  pRef is the reference point for forming triangles.
		' //  It's location doesn't change the result (except for rounding error).
dim 		 pRef  as variant = new b2Vec2(0.0, 0.0)

dim 		 inv3  as variant = 1.0 / 3.0

		for (var i = 0; i < count; ++i)
			' //  Triangle vertices.
dim 			 p1  as variant = pRef

dim 			 p2  as variant = vs[i]

dim 			 p3  as variant = i + 1 < count ? vs[i+1] : vs[0]

dim 			 e1  as variant = b2Math.SubtractVV(p2, p1)

dim 			 e2  as variant = b2Math.SubtractVV(p3, p1)

dim 			 D  as variant = b2Math.b2CrossVV(e1, e2)

dim 			 triangleArea  as variant = 0.5 * D

			area += triangleArea
			' //  Area weighted centroid
			' //  center += triangleArea * inv3 * (p1 + p2 + p3)
dim 			 tVec  as variant = new b2Vec2()

			tVec.SetV(p1)
			tVec.Add(p2)
			tVec.Add(p3)
			tVec.Multiply(inv3*triangleArea)
			center.Add(tVec)
dim 			 px  as variant = p1.x

dim 			 py  as variant = p1.y

dim 			 ex1  as variant = e1.x

dim 			 ey1  as variant = e1.y

dim 			 ex2  as variant = e2.x

dim 			 ey2  as variant = e2.y

dim 			 intx2  as variant = inv3 * (0.25 * (ex1*ex1 + ex2*ex1 + ex2*ex2) + (px*ex1 + px*ex2)) + 0.5*px*px

dim 			 inty2  as variant = inv3 * (0.25 * (ey1*ey1 + ey2*ey1 + ey2*ey2) + (py*ey1 + py*ey2)) + 0.5*py*py

			I += D * (intx2 + inty2)
		' //  Total mass
		massData.mass = rho * area
		' //  Center of mass
		' // b2Settings.b2Assert(area > Number.MIN_VALUE)
		center.Multiply( 1.0 / area )
		massData.center = center
		' //  Inertia tensor relative to the center.
		I = rho * (I - area * b2Math.b2Dot(center, center))
		massData.I = I
end

public  sub PolyCentroid (vs as variant, count as variant, out as variant) as variant ''funcio as variant ''funcion
		' // b2Settings.b2Assert(count >= 3)
		' // b2Vec2 c
 c.Set(0.0f, 0.0f)
dim 		 cX  as variant = 0.0

dim 		 cY  as variant = 0.0

		' // float32 area = 0.0f
dim 		 area  as variant = 0.0

		' //  pRef is the reference point for forming triangles.
		' //  It's location doesn't change the result (except for rounding error).
		' // b2Vec2 pRef(0.0f, 0.0f)
dim 		 pRefX  as variant = 0.0

dim 		 pRefY  as variant = 0.0

	' /* 
		' //  This code would put the reference point inside the polygon.
		for (var i = 0; i < count; ++i)
			' // pRef += vs[i]
			pRef.x += vs[i].x
			pRef.y += vs[i].y
		pRef.x *= 1.0 / count
		pRef.y *= 1.0 / count
' 	*/
		' // const float32 inv3 = 1.0f / 3.0f
dim 		 inv3  as variant = 1.0 / 3.0

		for (var i = 0; i < count; ++i)
			' //  Triangle vertices.
			' // b2Vec2 p1 = pRef
dim 			 p1X  as variant = pRefX

dim 			 p1Y  as variant = pRefY

			' // b2Vec2 p2 = vs[i]
dim 			 p2X  as variant = vs[i].x

dim 			 p2Y  as variant = vs[i].y

			' // b2Vec2 p3 = i + 1 < count ? vs[i+1] : vs[0]
dim 			 p3X  as variant = i + 1 < count ? vs[i+1].x : vs[0].x

dim 			 p3Y  as variant = i + 1 < count ? vs[i+1].y : vs[0].y

			' // b2Vec2 e1 = p2 - p1
dim 			 e1X  as variant = p2X - p1X

dim 			 e1Y  as variant = p2Y - p1Y

			' // b2Vec2 e2 = p3 - p1
dim 			 e2X  as variant = p3X - p1X

dim 			 e2Y  as variant = p3Y - p1Y

			' // float32 D = b2Cross(e1, e2)
dim 			 D  as variant = (e1X * e2Y - e1Y * e2X)

			' // float32 triangleArea = 0.5f * D
dim 			 triangleArea  as variant = 0.5 * D

			area += triangleArea
			' //  Area weighted centroid
			' // c += triangleArea * inv3 * (p1 + p2 + p3)
			cX += triangleArea * inv3 * (p1X + p2X + p3X)
			cY += triangleArea * inv3 * (p1Y + p2Y + p3Y)
		' //  Centroid
		' // b2Settings.b2Assert(area > Number.MIN_VALUE)
		cX *= 1.0 / area
		cY *= 1.0 / area
		' //  Replace return with 'out' vector '' TODO: posible funcion (revisar)

		' // return c
 '' TODO: posible funcion (revisar)

		out.Set(cX, cY)
' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2CircleShape  as variant = Class.create()

inherits , b2Shape
inherits 
end

public  sub 	TestPoint(p as variant) as variant ''funcion
		' // var d = b2Math.SubtractVV(p, me.m_position)
dim 		 d  as variant = new b2Vec2()

		d.SetV(p)
		d.Subtract( me.m_position)
		return b2Math.b2Dot(d, d) <= me.m_radius * me.m_radius
 '' TODO: posible funcion (revisar)

	' // --------------- Internals Below -------------------
end

public  sub 	initialize(def as variant, body as variant, localCenter as variant)

		' //  initialize instance variables for references
		 me.m_R = new b2Mat22()
		 me.m_position = new b2Vec2()
		' // 
		' //  The constructor for b2Shape
		 me.m_userData = def.userData
		 me.m_friction = def.friction
		 me.m_restitution = def.restitution
		 me.m_body = body
		 me.m_proxyId = b2Pair.b2_nullProxy
		 me.m_maxRadius = 0.0
		 me.m_categoryBits = def.categoryBits
		 me.m_maskBits = def.maskBits
		 me.m_groupIndex = def.groupIndex
		' // 
		' //  initialize instance variables for references
		 me.m_localPosition = new b2Vec2()
		' // 
		' // super(def, body)
		' // b2Settings.b2Assert(def.type == b2Shape.e_circleShape)
dim 		 circle  as variant = def

		' // me.m_localPosition = def.localPosition - localCenter
		 me.m_localPosition.Set(def.localPosition.x - localCenter.x, def.localPosition.y - localCenter.y)
		 me.m_type = b2Shape.e_circleShape
		 me.m_radius = circle.radius
		 me.m_R.SetM( me.m_body.m_R)
		' // b2Vec2 r = b2Mul( me.m_body-> me.m_R, me.m_localPosition)
dim 		 rX  as variant = me.m_R.col1.x * me.m_localPosition.x + me.m_R.col2.x * me.m_localPosition.y

dim 		 rY  as variant = me.m_R.col1.y * me.m_localPosition.x + me.m_R.col2.y * me.m_localPosition.y

		' // me.m_position = me.m_body-> me.m_position + r
		 me.m_position.x = me.m_body.m_position.x + rX
		 me.m_position.y = me.m_body.m_position.y + rY
		' // me.m_maxRadius = r.Length() + me.m_radius
		 me.m_maxRadius = Math.sqrt(rX*rX+rY*rY) + me.m_radius
dim 		 aabb  as variant = new b2AABB()

		aabb.minVertex.Set( me.m_position.x - me.m_radius, me.m_position.y - me.m_radius)
		aabb.maxVertex.Set( me.m_position.x + me.m_radius, me.m_position.y + me.m_radius)
dim 		 broadPhase  as variant = me.m_body.m_world.m_broadPhase

		if (broadPhase.InRange(aabb))
			 me.m_proxyId = broadPhase.CreateProxy(aabb, this)
		else
			 me.m_proxyId = b2Pair.b2_nullProxy
		if ( me.m_proxyId == b2Pair.b2_nullProxy)
			 me.m_body.Freeze()
end

public  sub 	Synchronize(position1 as variant, R1 as variant, position2 as variant, R2 as variant) as variant ''funcion
		 me.m_R.SetM(R2)
		' // me.m_position = position2 + b2Mul(R2, me.m_localPosition)
		 me.m_position.x = (R2.col1.x * me.m_localPosition.x + R2.col2.x * me.m_localPosition.y) + position2.x
		 me.m_position.y = (R2.col1.y * me.m_localPosition.x + R2.col2.y * me.m_localPosition.y) + position2.y
		if ( me.m_proxyId == b2Pair.b2_nullProxy)
			return
 '' TODO: posible funcion (revisar)

		' //  Compute an AABB that covers the swept shape (may miss some rotation effect).
		' // b2Vec2 p1 = position1 + b2Mul(R1, me.m_localPosition)
dim 		 p1X  as variant = position1.x + (R1.col1.x * me.m_localPosition.x + R1.col2.x * me.m_localPosition.y)

dim 		 p1Y  as variant = position1.y + (R1.col1.y * me.m_localPosition.x + R1.col2.y * me.m_localPosition.y)

		' // b2Vec2 lower = b2Min(p1, me.m_position)
dim 		 lowerX  as variant = Math.min(p1X, me.m_position.x)

dim 		 lowerY  as variant = Math.min(p1Y, me.m_position.y)

		' // b2Vec2 upper = b2Max(p1, me.m_position)
dim 		 upperX  as variant = Math.max(p1X, me.m_position.x)

dim 		 upperY  as variant = Math.max(p1Y, me.m_position.y)

dim 		 aabb  as variant = new b2AABB()

		aabb.minVertex.Set(lowerX - me.m_radius, lowerY - me.m_radius)
		aabb.maxVertex.Set(upperX + me.m_radius, upperY + me.m_radius)
dim 		 broadPhase  as variant = me.m_body.m_world.m_broadPhase

		if (broadPhase.InRange(aabb))
			broadPhase.MoveProxy( me.m_proxyId, aabb)
		else
			 me.m_body.Freeze()
end

public  sub 	QuickSync(position as variant, R as variant)

		 me.m_R.SetM(R)
		' // me.m_position = position + b2Mul(R, me.m_localPosition)
		 me.m_position.x = (R.col1.x * me.m_localPosition.x + R.col2.x * me.m_localPosition.y) + position.x
		 me.m_position.y = (R.col1.y * me.m_localPosition.x + R.col2.y * me.m_localPosition.y) + position.y
end

public  sub 	ResetProxy(broadPhase as variant) as variant ''funcion
		if ( me.m_proxyId == b2Pair.b2_nullProxy)
			return
 '' TODO: posible funcion (revisar)

dim 		 proxy  as variant = broadPhase.GetProxy( me.m_proxyId)

		broadPhase.DestroyProxy( me.m_proxyId)
		proxy = null
dim 		 aabb  as variant = new b2AABB()

		aabb.minVertex.Set( me.m_position.x - me.m_radius, me.m_position.y - me.m_radius)
		aabb.maxVertex.Set( me.m_position.x + me.m_radius, me.m_position.y + me.m_radius)
		if (broadPhase.InRange(aabb))
			 me.m_proxyId = broadPhase.CreateProxy(aabb, this)
		else
			 me.m_proxyId = b2Pair.b2_nullProxy
		if ( me.m_proxyId == b2Pair.b2_nullProxy)
			 me.m_body.Freeze()
end

public  sub 	Support(dX as variant, dY as variant, out as variant) as variant ''funcion
		' // b2Vec2 u = d
		' // u.Normalize()
dim 		 len  as variant = Math.sqrt(dX*dX + dY*dY)

		dX /= len
		dY /= len
		' // return me.m_position + me.m_radius * u
 '' TODO: posible funcion (revisar)

		out.Set(	 me.m_position.x + me.m_radius*dX
					 me.m_position.y + me.m_radius*dY)
	' //  Local position in parent body
Public n: new b2Vec2(), as new 2Vec2(),
	m_radius: null)
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2MassData  as variant = Class.create()

b2MassData.prototype = 
	mass: 0.0
Public r: new b2Vec2(0,0), as new 2Vec2(0,0),
	I: 0.0
end

public  sub 	initialize()
 
		' //  initialize instance variables for references
		 me.center = new b2Vec2(0,0)
		' // 
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  The pair manager is used by the broad-phase to quickly add/remove/find pairs
' //  of overlapping proxies. It is based closely on code provided by Pierre Terdiman.
' //  http:
dim  b2Pair  as variant = Class.create()

b2Pair.prototype = 
end

public  sub 	SetBuffered()
	 me.status |= b2Pair.e_pairBuffered
 
end

public  sub 	ClearBuffered()
	 me.status &= ~b2Pair.e_pairBuffered
 
end

public  sub 	IsBuffered()
 return ( me.status & b2Pair.e_pairBuffered) == b2Pair.e_pairBuffered
  '' TODO: posible funcion (revisar)

end

public  sub 	SetRemoved()
		 me.status |= b2Pair.e_pairRemoved
 
end

public  sub 	ClearRemoved()
	 me.status &= ~b2Pair.e_pairRemoved
 
end

public  sub 	IsRemoved()
 return ( me.status & b2Pair.e_pairRemoved) == b2Pair.e_pairRemoved
  '' TODO: posible funcion (revisar)

end

public  sub 	SetFinal()
		 me.status |= b2Pair.e_pairFinal
 
end

public  sub 	IsFinal()
 return ( me.status & b2Pair.e_pairFinal) == b2Pair.e_pairFinal
  '' TODO: posible funcion (revisar)

	userData: null
	proxyId1: 0
	proxyId2: 0
	next: 0
	status: 0
	' //  STATIC
	' //  enum
end

public  sub 	initialize()
 
b2Pair.b2_nullPair = b2Settings.USHRT_MAX
b2Pair.b2_nullProxy = b2Settings.USHRT_MAX
b2Pair.b2_tableCapacity = b2Settings.b2_maxPairs
b2Pair.b2_tableMask = b2Pair.b2_tableCapacity - 1
b2Pair.e_pairBuffered = 0x0001
b2Pair.e_pairRemoved = 0x0002
b2Pair.e_pairFinal = 0x0004
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2BoundValues  as variant = Class.create()

b2BoundValues.prototype = 
	lowerValues: [0,0]
	upperValues: [0,0]
end

public  sub 	initialize()
 
		' //  initialize instance variables for references
		 me.lowerValues = [0,0]
		 me.upperValues = [0,0]
		' // 
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2BufferedPair  as variant = Class.create()

b2BufferedPair.prototype = 
	proxyId1: 0
	proxyId2: 0
end

public  sub 	initialize()
 
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  ClipVertex  as variant = Class.create()

ClipVertex.prototype = 
Public v: new b2Vec2(), as new 2Vec2(),
Public d: new b2ContactID(), as new 2ContactID(),
end

public  sub 	initialize()
 
		' //  initialize instance variables for references
		 me.v = new b2Vec2()
		 me.id = new b2ContactID()
		' // 
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  We use contact ids to facilitate warm starting.
dim  b2ContactPoint  as variant = Class.create()

b2ContactPoint.prototype = 
Public n: new b2Vec2(), as new 2Vec2(),
	separation: null
	normalImpulse: null
	tangentImpulse: null
Public d: new b2ContactID(), as new 2ContactID(),
end

public  sub 	initialize()
 
		' //  initialize instance variables for references
		 me.position = new b2Vec2()
		 me.id = new b2ContactID()
		' // 
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  A manifold for two touching convex shapes.
dim  b2AABB  as variant = Class.create()

b2AABB.prototype = 
end

public  sub 	IsValid() as variant ''funcion
		' // var d = b2Math.SubtractVV( me.maxVertex, me.minVertex)
dim 		 dX  as variant = me.maxVertex.x

dim 		 dY  as variant = me.maxVertex.y

		dX = me.maxVertex.x
		dY = me.maxVertex.y
		dX -= me.minVertex.x
		dY -= me.minVertex.y
dim 		 valid  as variant = dX >= 0.0 && dY >= 0.0

		valid = valid && me.minVertex.IsValid() && me.maxVertex.IsValid()
		return valid
 '' TODO: posible funcion (revisar)

Public x: new b2Vec2(), as new 2Vec2(),
Public x: new b2Vec2(), as new 2Vec2(),
end

public  sub 	initialize()
 
		' //  initialize instance variables for references
		 me.minVertex = new b2Vec2()
		 me.maxVertex = new b2Vec2()
		' // 
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2Proxy  as variant = Class.create()

b2Proxy.prototype = 
end

public  sub 	GetNext()
 return me.lowerBounds[0]
  '' TODO: posible funcion (revisar)

end

public  sub 	SetNext(next as variant)
  me.lowerBounds[0] = next ' /* & 0x0000ffff*/
 
end

public  sub 	IsValid()
 return me.overlapCount != b2BroadPhase.b2_invalid
  '' TODO: posible funcion (revisar)

	lowerBounds: [' /* uint*/(0), ' /* uint*/(0)]
	upperBounds: [' /* uint*/(0), ' /* uint*/(0)]
	overlapCount: 0
	timeStamp: 0
	userData: null
end

public  sub 	initialize()
 
		' //  initialize instance variables for references
		 me.lowerBounds = [' /* uint*/(0), ' /* uint*/(0)]
		 me.upperBounds = [' /* uint*/(0), ' /* uint*/(0)]
		' // 
' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2Distance  as variant = Class.create()

b2Distance.prototype = 
	' //  GJK using Voronoi regions (Christer Ericson) and region selection
	' //  optimizations (Casey Muratori).
	' //  The origin is either in the region of points[1] or in the edge region. The origin is
	' //  not in region of points[0] because that is the old point.
	' //  Possible regions:
	' //  - points[2]
	' //  - edge points[0]-points[2]
	' //  - edge points[1]-points[2]
	' //  - inside the triangle
end

public  sub 	initialize()
 
end

public  sub ProcessTwo (p1Out as variant, p2Out as variant, p1s as variant, p2s as variant, points as variant) as variant ''funcio as variant ''funcion
		' //  If in point[1] region
		' // b2Vec2 r = -points[1]
dim 		 rX  as variant = -points[1].x

dim 		 rY  as variant = -points[1].y

		' // b2Vec2 d = points[1] - points[0]
dim 		 dX  as variant = points[0].x - points[1].x

dim 		 dY  as variant = points[0].y - points[1].y

		' // float32 length = d.Normalize()
dim 		 length  as variant = Math.sqrt(dX*dX + dY*dY)

		dX /= length
		dY /= length
		' // float32 lambda = b2Dot(r, d)
dim 		 lambda  as variant = rX * dX + rY * dY

		if (lambda <= 0.0 || length < Number.MIN_VALUE)
			' //  The simplex is reduced to a point.
			' // *p1Out = p1s[1]
			p1Out.SetV(p1s[1])
			' // *p2Out = p2s[1]
			p2Out.SetV(p2s[1])
			' // p1s[0] = p1s[1]
			p1s[0].SetV(p1s[1])
			' // p2s[0] = p2s[1]
			p2s[0].SetV(p2s[1])
			points[0].SetV(points[1])
			return 1
 '' TODO: posible funcion (revisar)

		' //  Else in edge region
		lambda /= length
		' // *p1Out = p1s[1] + lambda * (p1s[0] - p1s[1])
		p1Out.x = p1s[1].x + lambda * (p1s[0].x - p1s[1].x)
		p1Out.y = p1s[1].y + lambda * (p1s[0].y - p1s[1].y)
		' // *p2Out = p2s[1] + lambda * (p2s[0] - p2s[1])
		p2Out.x = p2s[1].x + lambda * (p2s[0].x - p2s[1].x)
		p2Out.y = p2s[1].y + lambda * (p2s[0].y - p2s[1].y)
		return 2
 '' TODO: posible funcion (revisar)

end

public  sub ProcessThree (p1Out as variant, p2Out as variant, p1s as variant, p2s as variant, points as variant) as variant ''funcio as variant ''funcio as variant ''funcio as variant ''funcion
		' // b2Vec2 a = points[0]
dim 		 aX  as variant = points[0].x

dim 		 aY  as variant = points[0].y

		' // b2Vec2 b = points[1]
dim 		 bX  as variant = points[1].x

dim 		 bY  as variant = points[1].y

		' // b2Vec2 c = points[2]
dim 		 cX  as variant = points[2].x

dim 		 cY  as variant = points[2].y

		' // b2Vec2 ab = b - a
dim 		 abX  as variant = bX - aX

dim 		 abY  as variant = bY - aY

		' // b2Vec2 ac = c - a
dim 		 acX  as variant = cX - aX

dim 		 acY  as variant = cY - aY

		' // b2Vec2 bc = c - b
dim 		 bcX  as variant = cX - bX

dim 		 bcY  as variant = cY - bY

		' // float32 sn = -b2Dot(a, ab), sd = b2Dot(b, ab)
dim 		 sn  as variant = -(aX * abX + aY * abY)

dim 		 sd  as variant = (bX * abX + bY * abY)

		' // float32 tn = -b2Dot(a, ac), td = b2Dot(c, ac)
dim 		 tn  as variant = -(aX * acX + aY * acY)

dim 		 td  as variant = (cX * acX + cY * acY)

		' // float32 un = -b2Dot(b, bc), ud = b2Dot(c, bc)
dim 		 un  as variant = -(bX * bcX + bY * bcY)

dim 		 ud  as variant = (cX * bcX + cY * bcY)

		' //  In vertex c region?
		if (td <= 0.0 && ud <= 0.0)
			' //  Single point
			' // *p1Out = p1s[2]
			p1Out.SetV(p1s[2])
			' // *p2Out = p2s[2]
			p2Out.SetV(p2s[2])
			' // p1s[0] = p1s[2]
			p1s[0].SetV(p1s[2])
			' // p2s[0] = p2s[2]
			p2s[0].SetV(p2s[2])
			points[0].SetV(points[2])
			return 1
 '' TODO: posible funcion (revisar)

		' //  Should not be in vertex a or b region.
		' // b2Settings.b2Assert(sn > 0.0 || tn > 0.0)
		' // b2Settings.b2Assert(sd > 0.0 || un > 0.0)
		' // float32 n = b2Cross(ab, ac)
dim 		 n  as variant = abX * acY - abY * acX

		' //  Should not be in edge ab region.
		' // float32 vc = n * b2Cross(a, b)
dim 		 vc  as variant = n * (aX * bY - aY * bX)

		' // b2Settings.b2Assert(vc > 0.0 || sn > 0.0 || sd > 0.0)
		' //  In edge bc region?
		' // float32 va = n * b2Cross(b, c)
dim 		 va  as variant = n * (bX * cY - bY * cX)

		if (va <= 0.0 && un >= 0.0 && ud >= 0.0)
			' // b2Settings.b2Assert(un + ud > 0.0)
			' // float32 lambda = un / (un + ud)
dim 			 lambda  as variant = un / (un + ud)

			' // *p1Out = p1s[1] + lambda * (p1s[2] - p1s[1])
			p1Out.x = p1s[1].x + lambda * (p1s[2].x - p1s[1].x)
			p1Out.y = p1s[1].y + lambda * (p1s[2].y - p1s[1].y)
			' // *p2Out = p2s[1] + lambda * (p2s[2] - p2s[1])
			p2Out.x = p2s[1].x + lambda * (p2s[2].x - p2s[1].x)
			p2Out.y = p2s[1].y + lambda * (p2s[2].y - p2s[1].y)
			' // p1s[0] = p1s[2]
			p1s[0].SetV(p1s[2])
			' // p2s[0] = p2s[2]
			p2s[0].SetV(p2s[2])
			' // points[0] = points[2]
			points[0].SetV(points[2])
			return 2
 '' TODO: posible funcion (revisar)

		' //  In edge ac region?
		' // float32 vb = n * b2Cross(c, a)
dim 		 vb  as variant = n * (cX * aY - cY * aX)

		if (vb <= 0.0 && tn >= 0.0 && td >= 0.0)
			' // b2Settings.b2Assert(tn + td > 0.0)
			' // float32 lambda = tn / (tn + td)
dim 			 lambda  as variant = tn / (tn + td)

			' // *p1Out = p1s[0] + lambda * (p1s[2] - p1s[0])
			p1Out.x = p1s[0].x + lambda * (p1s[2].x - p1s[0].x)
			p1Out.y = p1s[0].y + lambda * (p1s[2].y - p1s[0].y)
			' // *p2Out = p2s[0] + lambda * (p2s[2] - p2s[0])
			p2Out.x = p2s[0].x + lambda * (p2s[2].x - p2s[0].x)
			p2Out.y = p2s[0].y + lambda * (p2s[2].y - p2s[0].y)
			' // p1s[1] = p1s[2]
			p1s[1].SetV(p1s[2])
			' // p2s[1] = p2s[2]
			p2s[1].SetV(p2s[2])
			' // points[1] = points[2]
			points[1].SetV(points[2])
			return 2
 '' TODO: posible funcion (revisar)

		' //  Inside the triangle, compute barycentric coordinates
		' // float32 denom = va + vb + vc
dim 		 denom  as variant = va + vb + vc

		' // b2Settings.b2Assert(denom > 0.0)
		denom = 1.0 / denom
		' // float32 u = va * denom
dim 		 u  as variant = va * denom

		' // float32 v = vb * denom
dim 		 v  as variant = vb * denom

		' // float32 w = 1.0f - u - v
dim 		 w  as variant = 1.0 - u - v

		' // *p1Out = u * p1s[0] + v * p1s[1] + w * p1s[2]
		p1Out.x = u * p1s[0].x + v * p1s[1].x + w * p1s[2].x
		p1Out.y = u * p1s[0].y + v * p1s[1].y + w * p1s[2].y
		' // *p2Out = u * p2s[0] + v * p2s[1] + w * p2s[2]
		p2Out.x = u * p2s[0].x + v * p2s[1].x + w * p2s[2].x
		p2Out.y = u * p2s[0].y + v * p2s[1].y + w * p2s[2].y
		return 3
 '' TODO: posible funcion (revisar)

end

public  sub InPoinsts (w as variant, points as variant, pointCount as variant) as variant ''funcio as variant ''funcion
		for (var i = 0; i < pointCount; ++i)
			if (w.x == points[i].x && w.y == points[i].y)
			
				return true
 '' TODO: posible funcion (revisar)

			
		return false
 '' TODO: posible funcion (revisar)

end

public  sub Distance (p1Out as variant, p2Out as variant, shape1 as variant, shape2 as variant) as variant ''funcio as variant ''funcio as variant ''funcio as variant ''funcio as variant ''funcion
		' // b2Vec2 p1s[3], p2s[3]
dim 		 p1s  as variant = new Array(3)

dim 		 p2s  as variant = new Array(3)

		' // b2Vec2 points[3]
dim 		 points  as variant = new Array(3)

		' // int32 pointCount = 0
dim 		 pointCount  as variant = 0

		' // *p1Out = shape1->m_position
		p1Out.SetV(shape1.m_position)
		' // *p2Out = shape2->m_position
		p2Out.SetV(shape2.m_position)
dim 		 vSqr  as variant = 0.0

dim 		 maxIterations  as variant = 20

		for (var iter = 0; iter < maxIterations; ++iter)
			' // b2Vec2 v = *p2Out - *p1Out
dim 			 vX  as variant = p2Out.x - p1Out.x

dim 			 vY  as variant = p2Out.y - p1Out.y

			' // b2Vec2 w1 = shape1->Support(v)
dim 			 w1  as variant = shape1.Support(vX, vY)

			' // b2Vec2 w2 = shape2->Support(-v)
dim 			 w2  as variant = shape2.Support(-vX, -vY)

			' // float32 vSqr = b2Dot(v, v)
			vSqr = (vX*vX + vY*vY)
			' // b2Vec2 w = w2 - w1
dim 			 wX  as variant = w2.x - w1.x

dim 			 wY  as variant = w2.y - w1.y

			' // float32 vw = b2Dot(v, w)
dim 			 vw  as variant = (vX*wX + vY*wY)

			' // if (vSqr - b2Dot(v, w) <= 0.01f * vSqr)
			if (vSqr - b2Dot(vX * wX + vY * wY) <= 0.01 * vSqr)
			
				if (pointCount == 0)
				
					' // *p1Out = w1
					p1Out.SetV(w1)
					' // *p2Out = w2
					p2Out.SetV(w2)
				
				b2Distance.g_GJK_Iterations = iter
				return Math.sqrt(vSqr)
 '' TODO: posible funcion (revisar)

			
			switch (pointCount)
			
			case 0:
				' // p1s[0] = w1
				p1s[0].SetV(w1)
				' // p2s[0] = w2
				p2s[0].SetV(w2)
				points[0] = w
				' // *p1Out = p1s[0]
				p1Out.SetV(p1s[0])
				' // *p2Out = p2s[0]
				p2Out.SetV(p2s[0])
				++pointCount
				break
			case 1:
				' // p1s[1] = w1
				p1s[1].SetV(w1)
				' // p2s[1] = w2
				p2s[1].SetV(w2)
				' // points[1] = w
				points[1].x = wX
				points[1].y = wY
				pointCount = b2Distance.ProcessTwo(p1Out, p2Out, p1s, p2s, points)
				break
			case 2:
				' // p1s[2] = w1
				p1s[2].SetV(w1)
				' // p2s[2] = w2
				p2s[2].SetV(w2)
				' // points[2] = w
				points[2].x = wX
				points[2].y = wY
				pointCount = b2Distance.ProcessThree(p1Out, p2Out, p1s, p2s, points)
				break
			
			' //  If we have three points, then the origin is in the corresponding triangle.
			if (pointCount == 3)
			
				b2Distance.g_GJK_Iterations = iter
				return 0.0
 '' TODO: posible funcion (revisar)

			
			' // float32 maxSqr = -FLT_MAX
dim 			 maxSqr  as variant = -Number.MAX_VALUE

			for (var i = 0; i < pointCount; ++i)
			
				' // maxSqr = b2Math.b2Max(maxSqr, b2Dot(points[i], points[i]))
				maxSqr = b2Math.b2Max(maxSqr, (points[i].x*points[i].x + points[i].y*points[i].y))
			
			if (pointCount == 3 || vSqr <= 100.0 * Number.MIN_VALUE * maxSqr)
			
				b2Distance.g_GJK_Iterations = iter
				return Math.sqrt(vSqr)
 '' TODO: posible funcion (revisar)

			
		b2Distance.g_GJK_Iterations = maxIterations
		return Math.sqrt(vSqr)
 '' TODO: posible funcion (revisar)

b2Distance.g_GJK_Iterations = 0
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2PairCallback  as variant = Class.create()

b2PairCallback.prototype = 
	' // virtual ~b2PairCallback() 
	' //  This returns the new pair user data. '' TODO: posible funcion (revisar)

end

public  sub 	PairAdded(proxyUserData1 as variant, proxyUserData2 as variant)
return null '' TODO: posible funcion (revisar)

	' //  This should free the pair's user data. In extreme circumstances, it is possible
	' //  this will be called with null pairUserData because the pair never existed.
end

public  sub 	PairRemoved(proxyUserData1 as variant, proxyUserData2 as variant, pairUserData as variant)

end

public  sub 	initialize()
 
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  A manifold for two touching convex shapes.
dim  b2OBB  as variant = Class.create()

b2OBB.prototype = 
Public R: new b2Mat22(), as new 2Mat22(),
Public r: new b2Vec2(), as new 2Vec2(),
Public s: new b2Vec2(), as new 2Vec2(),
end

public  sub 	initialize()
 
		' //  initialize instance variables for references
		 me.R = new b2Mat22()
		 me.center = new b2Vec2()
		 me.extents = new b2Vec2()
		' // 
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2Bound  as variant = Class.create()

b2Bound.prototype = 
end

public  sub 	IsLower()
 return ( me.value & 1) == 0
  '' TODO: posible funcion (revisar)

end

public  sub 	IsUpper()
 return ( me.value & 1) == 1
  '' TODO: posible funcion (revisar)

end

public  sub 	Swap(b as variant)

dim 		 tempValue  as variant = me.value

dim 		 tempProxyId  as variant = me.proxyId

dim 		 tempStabbingCount  as variant = me.stabbingCount

		 me.value = b.value
		 me.proxyId = b.proxyId
		 me.stabbingCount = b.stabbingCount
		b.value = tempValue
		b.proxyId = tempProxyId
		b.stabbingCount = tempStabbingCount
	value: 0
	proxyId: 0
	stabbingCount: 0
end

public  sub 	initialize()
 
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  A manifold for two touching convex shapes.
dim  b2Manifold  as variant = Class.create()

b2Manifold.prototype = 
end

public  sub 	initialize()

		 me.points = new Array(b2Settings.b2_maxManifoldPoints)
		for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++)
			 me.points[i] = new b2ContactPoint()
		 me.normal = new b2Vec2()
	points: null
	normal: null
	pointCount: 0
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  The pair manager is used by the broad-phase to quickly add/remove/find pairs
' //  of overlapping proxies. It is based closely on code provided by Pierre Terdiman.
' //  http:
dim  b2PairManager  as variant = Class.create()

b2PairManager.prototype = 
' // public:
end

public  sub 	initialize()

dim 		 i  as variant = 0

		' // b2Settings.b2Assert(b2Math.b2IsPowerOfTwo(b2Pair.b2_tableCapacity) == true)
		' // b2Settings.b2Assert(b2Pair.b2_tableCapacity >= b2Settings.b2_maxPairs)
		 me.m_hashTable = new Array(b2Pair.b2_tableCapacity)
		for (i = 0; i < b2Pair.b2_tableCapacity; ++i)
			 me.m_hashTable[i] = b2Pair.b2_nullPair
		 me.m_pairs = new Array(b2Settings.b2_maxPairs)
		for (i = 0; i < b2Settings.b2_maxPairs; ++i)
			 me.m_pairs[i] = new b2Pair()
		 me.m_pairBuffer = new Array(b2Settings.b2_maxPairs)
		for (i = 0; i < b2Settings.b2_maxPairs; ++i)
			 me.m_pairBuffer[i] = new b2BufferedPair()
		for (i = 0; i < b2Settings.b2_maxPairs; ++i)
			 me.m_pairs[i].proxyId1 = b2Pair.b2_nullProxy
			 me.m_pairs[i].proxyId2 = b2Pair.b2_nullProxy
			 me.m_pairs[i].userData = null
			 me.m_pairs[i].status = 0
			 me.m_pairs[i].next = (i + 1)
		 me.m_pairs[b2Settings.b2_maxPairs-1].next = b2Pair.b2_nullPair
		 me.m_pairCount = 0
	' // ~b2PairManager()
end

public  sub 	Initialize(broadPhase as variant, callback as variant)

		 me.m_broadPhase = broadPhase
		 me.m_callback = callback
	' /* 
	As proxies are created and moved, many pairs are created and destroyed. Even worse, the same
	pair may be added and removed multiple times in a single time step of the physics engine. To reduce
	traffic in the pair manager, we try to avoid destroying pairs in the pair manager until the
	end of the physics step. This is done by buffering all the me.RemovePair requests. me.AddPair
	requests are processed immediately because we need the hash table entry for quick lookup.
	All user user callbacks are delayed until the buffered pairs are confirmed in me.Commit.
	This is very important because the user callbacks may be very expensive and client logic
	may be harmed if pairs are added and removed within the same time step.
	Buffer a pair for addition.
	We may add a pair that is not in the pair manager or pair buffer.
	We may add a pair that is already in the pair manager and pair buffer.
	If the added pair is not a new pair, then it must be in the pair buffer (because me.RemovePair was called).
' 	*/
end

public  sub 	AddBufferedPair(proxyId1 as variant, proxyId2 as variant)

		' // b2Settings.b2Assert(id1 != b2_nullProxy && id2 != b2_nullProxy)
		' // b2Settings.b2Assert( me.m_pairBufferCount < b2_maxPairs)
dim 		 pair  as variant = me.AddPair(proxyId1, proxyId2)

		' //  If this pair is not in the pair buffer ...
		if (pair.IsBuffered() == false)
			' //  This must be a newly added pair.
			' // b2Settings.b2Assert(pair.IsFinal() == false)
			' //  Add it to the pair buffer.
			pair.SetBuffered()
			 me.m_pairBuffer[ me.m_pairBufferCount].proxyId1 = pair.proxyId1
			 me.m_pairBuffer[ me.m_pairBufferCount].proxyId2 = pair.proxyId2
			++ me.m_pairBufferCount
			' // b2Settings.b2Assert( me.m_pairBufferCount <= me.m_pairCount)
		' //  Confirm this pair for the subsequent call to me.Commit.
		pair.ClearRemoved()
		if (b2BroadPhase.s_validate)
			 me.ValidateBuffer()
	' //  Buffer a pair for removal.
end

public  sub 	RemoveBufferedPair(proxyId1 as variant, proxyId2 as variant) as variant ''funcion
		' // b2Settings.b2Assert(id1 != b2_nullProxy && id2 != b2_nullProxy)
		' // b2Settings.b2Assert( me.m_pairBufferCount < b2_maxPairs)
dim 		 pair  as variant = me.Find(proxyId1, proxyId2)

		if (pair == null)
			' //  The pair never existed. This is legal (due to collision filtering).
			return
 '' TODO: posible funcion (revisar)

		' //  If this pair is not in the pair buffer ...
		if (pair.IsBuffered() == false)
			' //  This must be an old pair.
			' // b2Settings.b2Assert(pair.IsFinal() == true)
			pair.SetBuffered()
			 me.m_pairBuffer[ me.m_pairBufferCount].proxyId1 = pair.proxyId1
			 me.m_pairBuffer[ me.m_pairBufferCount].proxyId2 = pair.proxyId2
			++ me.m_pairBufferCount
			' // b2Settings.b2Assert( me.m_pairBufferCount <= me.m_pairCount)
		pair.SetRemoved()
		if (b2BroadPhase.s_validate)
			 me.ValidateBuffer()
end

public  sub 	Commit() as variant ''funcio as variant ''funcion
dim 		 i  as variant = 0

dim 		 removeCount  as variant = 0

dim 		 proxies  as variant = me.m_broadPhase.m_proxyPool

		for (i = 0; i < me.m_pairBufferCount; ++i)
dim 			 pair  as variant = me.Find( me.m_pairBuffer[i].proxyId1, me.m_pairBuffer[i].proxyId2)

			' // b2Settings.b2Assert(pair.IsBuffered())
			pair.ClearBuffered()
			' // b2Settings.b2Assert(pair.proxyId1 < b2Settings.b2_maxProxies && pair.proxyId2 < b2Settings.b2_maxProxies)
dim 			 proxy1  as variant = proxies[ pair.proxyId1 ]

dim 			 proxy2  as variant = proxies[ pair.proxyId2 ]

			' // b2Settings.b2Assert(proxy1.IsValid())
			' // b2Settings.b2Assert(proxy2.IsValid())
			if (pair.IsRemoved())
			
				' //  It is possible a pair was added then removed before a commit. Therefore
				' //  we should be careful not to tell the user the pair was removed when the
				' //  the user didn't receive a matching add.
				if (pair.IsFinal() == true)
				
					 me.m_callback.PairRemoved(proxy1.userData, proxy2.userData, pair.userData)
				
				' //  Store the ids so we can actually remove the pair below.
				 me.m_pairBuffer[removeCount].proxyId1 = pair.proxyId1
				 me.m_pairBuffer[removeCount].proxyId2 = pair.proxyId2
				++removeCount
			
			else
			
				' // b2Settings.b2Assert( me.m_broadPhase.TestOverlap(proxy1, proxy2) == true)
				if (pair.IsFinal() == false)
				
					pair.userData = me.m_callback.PairAdded(proxy1.userData, proxy2.userData)
					pair.SetFinal()
				
			
		for (i = 0; i < removeCount; ++i)
			 me.RemovePair( me.m_pairBuffer[i].proxyId1, me.m_pairBuffer[i].proxyId2)
		 me.m_pairBufferCount = 0
		if (b2BroadPhase.s_validate)
			 me.ValidateTable()
' // private:
	' //  Add a pair and return the new pair. If the pair already exists, '' TODO: posible funcion (revisar)

	' //  no new pair is created and the old one is returned. '' TODO: posible funcion (revisar)

end

public  sub 	AddPair(proxyId1 as variant, proxyId2 as variant) as variant ''funcio as variant ''funcio as variant ''funcion
		if (proxyId1 > proxyId2)
dim 			 temp  as variant = proxyId1

			proxyId1 = proxyId2
			proxyId2 = temp
			' // b2Math.b2Swap(p1, p2)
dim 		 hash  as variant = b2PairManager.Hash(proxyId1, proxyId2) & b2Pair.b2_tableMask

		' // var pairIndex = me.FindHash(proxyId1, proxyId2, hash)
dim 		 pair  as variant = pair = me.FindHash(proxyId1, proxyId2, hash)

		if (pair != null)
			return pair
 '' TODO: posible funcion (revisar)

		' // b2Settings.b2Assert( me.m_pairCount < b2Settings.b2_maxPairs && me.m_freePair != b2_nullPair)
dim 		 pIndex  as variant = me.m_freePair

		pair = me.m_pairs[pIndex]
		 me.m_freePair = pair.next
		pair.proxyId1 = proxyId1
		pair.proxyId2 = proxyId2
		pair.status = 0
		pair.userData = null
		pair.next = me.m_hashTable[hash]
		 me.m_hashTable[hash] = pIndex
		++ me.m_pairCount
		return pair
 '' TODO: posible funcion (revisar)

	' //  Remove a pair, return the pair's userData. '' TODO: posible funcion (revisar)

end

public  sub 	RemovePair(proxyId1 as variant, proxyId2 as variant) as variant ''funcio as variant ''funcion
		' // b2Settings.b2Assert( me.m_pairCount > 0)
		if (proxyId1 > proxyId2)
dim 			 temp  as variant = proxyId1

			proxyId1 = proxyId2
			proxyId2 = temp
			' // b2Math.b2Swap(proxyId1, proxyId2)
dim 		 hash  as variant = b2PairManager.Hash(proxyId1, proxyId2) & b2Pair.b2_tableMask

dim 		 node  as variant = me.m_hashTable[hash]

dim 		 pNode  as variant = null

		while (node != b2Pair.b2_nullPair)
			if (b2PairManager.Equals( me.m_pairs[node], proxyId1, proxyId2))
			
dim 				 index  as variant = node

				' // *node = me.m_pairs[*node].next
				if (pNode)
					pNode.next = me.m_pairs[node].next
				
				else
					 me.m_hashTable[hash] = me.m_pairs[node].next
				
dim 				 pair  as variant = me.m_pairs[ index ]

dim 				 userData  as variant = pair.userData

				' //  Scrub
				pair.next = me.m_freePair
				pair.proxyId1 = b2Pair.b2_nullProxy
				pair.proxyId2 = b2Pair.b2_nullProxy
				pair.userData = null
				pair.status = 0
				 me.m_freePair = index
				-- me.m_pairCount
				return userData
 '' TODO: posible funcion (revisar)

			
			else
			
				' // node = & me.m_pairs[*node].next
				pNode = me.m_pairs[node]
				node = pNode.next
			
		' // b2Settings.b2Assert(false)
		return null
 '' TODO: posible funcion (revisar)

end

public  sub 	Find(proxyId1 as variant, proxyId2 as variant) as variant ''funcion
		if (proxyId1 > proxyId2)
dim 			 temp  as variant = proxyId1

			proxyId1 = proxyId2
			proxyId2 = temp
			' // b2Math.b2Swap(proxyId1, proxyId2)
dim 		 hash  as variant = b2PairManager.Hash(proxyId1, proxyId2) & b2Pair.b2_tableMask

		return me.FindHash(proxyId1, proxyId2, hash)
 '' TODO: posible funcion (revisar)

end

public  sub 	FindHash(proxyId1 as variant, proxyId2 as variant, hash as variant) as variant ''funcio as variant ''funcion
dim 		 index  as variant = me.m_hashTable[hash]

		while( index != b2Pair.b2_nullPair && b2PairManager.Equals( me.m_pairs[index], proxyId1, proxyId2) == false)
			index = me.m_pairs[index].next
		if ( index == b2Pair.b2_nullPair )
			return null
 '' TODO: posible funcion (revisar)

		' // b2Settings.b2Assert(index < b2_maxPairs)
		return me.m_pairs[ index ]
 '' TODO: posible funcion (revisar)

end

public  sub 	ValidateBuffer()

		' //  DEBUG
end

public  sub 	ValidateTable()

		' //  DEBUG
' // public:
	m_broadPhase: null
	m_callback: null
	m_pairs: null
	m_freePair: 0
	m_pairCount: 0
	m_pairBuffer: null
	m_pairBufferCount: 0
	m_hashTable: null
' //  static
	' //  Thomas Wang's hash, see: http:
end

public  sub Hash (proxyId1 as variant, proxyId2 as variant) as variant ''funcion
dim 		 key  as variant = ((proxyId2 << 16) & 0xffff0000) | proxyId1

		key = ~key + ((key << 15) & 0xFFFF8000)
		key = key ^ ((key >> 12) & 0x000fffff)
		key = key + ((key << 2) & 0xFFFFFFFC)
		key = key ^ ((key >> 4) & 0x0fffffff)
		key = key * 2057
		key = key ^ ((key >> 16) & 0x0000ffff)
		return key
 '' TODO: posible funcion (revisar)

end

public  sub Equals (pair as variant, proxyId1 as variant, proxyId2 as variant) as variant ''funcion
		return (pair.proxyId1 == proxyId1 && pair.proxyId2 == proxyId2)
 '' TODO: posible funcion (revisar)

end

public  sub EqualsPair (pair1 as variant, pair2 as variant) as variant ''funcion
		return pair1.proxyId1 == pair2.proxyId1 && pair1.proxyId2 == pair2.proxyId2
 '' TODO: posible funcion (revisar)

﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  We use contact ids to facilitate warm starting.
dim  Features  as variant = Class.create()

Features.prototype = 
	' // 
end

public  sub 	set_referenceFace(value as variant)

		 me._referenceFace = value
		 me._m_id._key = ( me._m_id._key & 0xffffff00) | ( me._referenceFace & 0x000000ff)
end

public  sub 	get_referenceFace() as variant ''funcion
		return me._referenceFace
 '' TODO: posible funcion (revisar)

	_referenceFace: 0
	' // 
end

public  sub 	set_incidentEdge(value as variant)

		 me._incidentEdge = value
		 me._m_id._key = ( me._m_id._key & 0xffff00ff) | (( me._incidentEdge << 8) & 0x0000ff00)
end

public  sub 	get_incidentEdge() as variant ''funcion
		return me._incidentEdge
 '' TODO: posible funcion (revisar)

	_incidentEdge: 0
	' // 
end

public  sub 	set_incidentVertex(value as variant)

		 me._incidentVertex = value
		 me._m_id._key = ( me._m_id._key & 0xff00ffff) | (( me._incidentVertex << 16) & 0x00ff0000)
end

public  sub 	get_incidentVertex() as variant ''funcion
		return me._incidentVertex
 '' TODO: posible funcion (revisar)

	_incidentVertex: 0
	' // 
end

public  sub 	set_flip(value as variant)

		 me._flip = value
		 me._m_id._key = ( me._m_id._key & 0x00ffffff) | (( me._flip << 24) & 0xff000000)
end

public  sub 	get_flip() as variant ''funcion
		return me._flip
 '' TODO: posible funcion (revisar)

	_flip: 0
	_m_id: null
end

public  sub 	initialize()
 
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  We use contact ids to facilitate warm starting.
dim  b2ContactID  as variant = Class.create()

b2ContactID.prototype = 
end

public  sub 	initialize()

		' //  initialize instance variables for references
		 me.features = new Features()
		' // 
		 me.features._m_id = this
end

public  sub 	Set(id as variant)

		 me.set_key(id._key)
end

public  sub 	Copy() as variant ''funcion
dim 		 id  as variant = new b2ContactID()

		id.set_key( me._key)
		return id
 '' TODO: posible funcion (revisar)

end

public  sub 	get_key() as variant ''funcion
		return me._key
 '' TODO: posible funcion (revisar)

end

public  sub 	set_key(value as variant)
 
		 me._key = value
		 me.features._referenceFace = me._key & 0x000000ff
		 me.features._incidentEdge = (( me._key & 0x0000ff00) >> 8) & 0x000000ff
		 me.features._incidentVertex = (( me._key & 0x00ff0000) >> 16) & 0x000000ff
		 me.features._flip = (( me._key & 0xff000000) >> 24) & 0x000000ff
Public s: new Features(), as new eatures(),
	_key: 0
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' /* 
This broad phase uses the Sweep and Prune algorithm in:
Collision Detection in Interactive 3D Environments by Gino van den Bergen
Also, some ideas, such integral values for fast compares comes from
Bullet (http:/www.bulletphysics.com).
' */
' //  Notes:
' //  - we use bound arrays instead of linked lists for cache coherence.
' //  - we use quantized integral values for fast compares.
' //  - we use short indices rather than pointers to save memory.
' //  - we use a stabbing count for fast overlap queries (less than order N).
' //  - we also use a time stamp on each proxy to speed up the registration of
' //    overlap query results.
' //  - where possible, we compare bound indices instead of values to reduce
' //    cache misses (TODO_ERIN).
' //  - no broadphase is perfect and neither is this one: it is not great for huge
' //    worlds (use a multi-SAP instead), it is not great for large objects.
dim  b2BroadPhase  as variant = Class.create()

b2BroadPhase.prototype = 
' // public:
end

public  sub 	initialize(worldAABB as variant, callback as variant)

		' //  initialize instance variables for references
		 me.m_pairManager = new b2PairManager()
		 me.m_proxyPool = new Array(b2Settings.b2_maxPairs)
		 me.m_bounds = new Array(2*b2Settings.b2_maxProxies)
		 me.m_queryResults = new Array(b2Settings.b2_maxProxies)
		 me.m_quantizationFactor = new b2Vec2()
		' // 
		' // b2Settings.b2Assert(worldAABB.IsValid())
dim 		 i  as variant = 0

		 me.m_pairManager.Initialize(this, callback)
		 me.m_worldAABB = worldAABB
		 me.m_proxyCount = 0
		' //  query results
		for (i = 0; i < b2Settings.b2_maxProxies; i++)
			 me.m_queryResults[i] = 0
		' //  bounds array
		 me.m_bounds = new Array(2)
		for (i = 0; i < 2; i++)
			 me.m_bounds[i] = new Array(2*b2Settings.b2_maxProxies)
			for (var j = 0; j < 2*b2Settings.b2_maxProxies; j++)
				 me.m_bounds[i][j] = new b2Bound()
			
		' // var d = b2Math.SubtractVV(worldAABB.maxVertex, worldAABB.minVertex)
dim 		 dX  as variant = worldAABB.maxVertex.x

dim 		 dY  as variant = worldAABB.maxVertex.y

		dX -= worldAABB.minVertex.x
		dY -= worldAABB.minVertex.y
		 me.m_quantizationFactor.x = b2Settings.USHRT_MAX / dX
		 me.m_quantizationFactor.y = b2Settings.USHRT_MAX / dY
dim 		tProxy
 as variant
		for (i = 0; i < b2Settings.b2_maxProxies - 1; ++i)
			tProxy = new b2Proxy()
			 me.m_proxyPool[i] = tProxy
			tProxy.SetNext(i + 1)
			tProxy.timeStamp = 0
			tProxy.overlapCount = b2BroadPhase.b2_invalid
			tProxy.userData = null
		tProxy = new b2Proxy()
		 me.m_proxyPool[b2Settings.b2_maxProxies-1] = tProxy
		tProxy.SetNext(b2Pair.b2_nullProxy)
		tProxy.timeStamp = 0
		tProxy.overlapCount = b2BroadPhase.b2_invalid
		tProxy.userData = null
		 me.m_freeProxy = 0
		 me.m_timeStamp = 1
		 me.m_queryResultCount = 0
	' // ~b2BroadPhase()
	' //  Use this to see if your proxy is in range. If it is not in range
	' //  it should be destroyed. Otherwise you may get O(m^2) pairs, where m
	' //  is the number of proxies that are out of range.
end

public  sub 	InRange(aabb as variant) as variant ''funcion
		' // var d = b2Math.b2MaxV(b2Math.SubtractVV(aabb.minVertex, me.m_worldAABB.maxVertex), b2Math.SubtractVV( me.m_worldAABB.minVertex, aabb.maxVertex))
dim 		dX
 as variant
dim 		dY
 as variant
dim 		d2X
 as variant
dim 		d2Y
 as variant
		dX = aabb.minVertex.x
		dY = aabb.minVertex.y
		dX -= me.m_worldAABB.maxVertex.x
		dY -= me.m_worldAABB.maxVertex.y
		d2X = me.m_worldAABB.minVertex.x
		d2Y = me.m_worldAABB.minVertex.y
		d2X -= aabb.maxVertex.x
		d2Y -= aabb.maxVertex.y
		dX = b2Math.b2Max(dX, d2X)
		dY = b2Math.b2Max(dY, d2Y)
		return b2Math.b2Max(dX, dY) < 0.0
 '' TODO: posible funcion (revisar)

	' //  Get a single proxy. Returns NULL if the id is invalid.
end

public  sub 	GetProxy(proxyId as variant) as variant ''funcio as variant ''funcion
		if (proxyId == b2Pair.b2_nullProxy || me.m_proxyPool[proxyId].IsValid() == false)
			return null
 '' TODO: posible funcion (revisar)

		return me.m_proxyPool[ proxyId ]
 '' TODO: posible funcion (revisar)

	' //  Create and destroy proxies. These call Flush first.
end

public  sub 	CreateProxy(aabb as variant, userData as variant) as variant ''funcion
dim 		 index  as variant = 0

dim 		proxy
 as variant
		' // b2Settings.b2Assert( me.m_proxyCount < b2_maxProxies)
		' // b2Settings.b2Assert( me.m_freeProxy != b2Pair.b2_nullProxy)
dim 		 proxyId  as variant = me.m_freeProxy

		proxy = me.m_proxyPool[ proxyId ]
		 me.m_freeProxy = proxy.GetNext()
		proxy.overlapCount = 0
		proxy.userData = userData
dim 		 boundCount  as variant = 2 * me.m_proxyCount

dim 		 lowerValues  as variant = new Array()

dim 		 upperValues  as variant = new Array()

		 me.ComputeBounds(lowerValues, upperValues, aabb)
		for (var axis = 0; axis < 2; ++axis)
dim 			 bounds  as variant = me.m_bounds[axis]

dim 			 lowerIndex  as variant = 0

dim 			 upperIndex  as variant = 0

dim 			 lowerIndexOut  as variant = [lowerIndex]

dim 			 upperIndexOut  as variant = [upperIndex]

			 me.Query(lowerIndexOut, upperIndexOut, lowerValues[axis], upperValues[axis], bounds, boundCount, axis)
			lowerIndex = lowerIndexOut[0]
			upperIndex = upperIndexOut[0]
			' //  Replace memmove calls
			' // memmove(bounds + upperIndex + 2, bounds + upperIndex, (edgeCount - upperIndex) * sizeof(b2Bound))
dim 			 tArr  as variant = new Array()

dim 			 j  as variant = 0

dim 			 tEnd  as variant = boundCount - upperIndex
dim 			tBound1
 as variant
dim 			tBound2
 as variant
			' //  make temp array
			for (j = 0; j < tEnd; j++)
				tArr[j] = new b2Bound()
				tBound1 = tArr[j]
				tBound2 = bounds[upperIndex+j]
				tBound1.value = tBound2.value
				tBound1.proxyId = tBound2.proxyId
				tBound1.stabbingCount = tBound2.stabbingCount
			
			' //  move temp array back in to bounds
			tEnd = tArr.length
dim 			 tIndex  as variant = upperIndex+2

			for (j = 0; j < tEnd; j++)
				' // bounds[tIndex+j] = tArr[j]
				tBound2 = tArr[j]
				tBound1 = bounds[tIndex+j]
				tBound1.value = tBound2.value
				tBound1.proxyId = tBound2.proxyId
				tBound1.stabbingCount = tBound2.stabbingCount
			
			' // memmove(bounds + lowerIndex + 1, bounds + lowerIndex, (upperIndex - lowerIndex) * sizeof(b2Bound))
			' //  make temp array
			tArr = new Array()
			tEnd = upperIndex - lowerIndex
			for (j = 0; j < tEnd; j++)
				tArr[j] = new b2Bound()
				tBound1 = tArr[j]
				tBound2 = bounds[lowerIndex+j]
				tBound1.value = tBound2.value
				tBound1.proxyId = tBound2.proxyId
				tBound1.stabbingCount = tBound2.stabbingCount
			
			' //  move temp array back in to bounds
			tEnd = tArr.length
			tIndex = lowerIndex+1
			for (j = 0; j < tEnd; j++)
				' // bounds[tIndex+j] = tArr[j]
				tBound2 = tArr[j]
				tBound1 = bounds[tIndex+j]
				tBound1.value = tBound2.value
				tBound1.proxyId = tBound2.proxyId
				tBound1.stabbingCount = tBound2.stabbingCount
			
			' //  The upper index has increased because of the lower bound insertion.
			++upperIndex
			' //  Copy in the new bounds.
			bounds[lowerIndex].value = lowerValues[axis]
			bounds[lowerIndex].proxyId = proxyId
			bounds[upperIndex].value = upperValues[axis]
			bounds[upperIndex].proxyId = proxyId
			bounds[lowerIndex].stabbingCount = lowerIndex == 0 ? 0 : bounds[lowerIndex-1].stabbingCount
			bounds[upperIndex].stabbingCount = bounds[upperIndex-1].stabbingCount
			' //  Adjust the stabbing count between the new bounds.
			for (index = lowerIndex; index < upperIndex; ++index)
			
				bounds[index].stabbingCount++
			
			' //  Adjust the all the affected bound indices.
			for (index = lowerIndex; index < boundCount + 2; ++index)
			
dim 				 proxy2  as variant = me.m_proxyPool[ bounds[index].proxyId ]

				if (bounds[index].IsLower())
				
					proxy2.lowerBounds[axis] = index
				
				else
				
					proxy2.upperBounds[axis] = index
				
			
		++ me.m_proxyCount
		' // b2Settings.b2Assert( me.m_queryResultCount < b2Settings.b2_maxProxies)
		for (var i = 0; i < me.m_queryResultCount; ++i)
			' // b2Settings.b2Assert( me.m_queryResults[i] < b2_maxProxies)
			' // b2Settings.b2Assert( me.m_proxyPool[ me.m_queryResults[i]].IsValid())
			 me.m_pairManager.AddBufferedPair(proxyId, me.m_queryResults[i])
		 me.m_pairManager.Commit()
		' //  Prepare for next query.
		 me.m_queryResultCount = 0
		 me.IncrementTimeStamp()
		return proxyId
 '' TODO: posible funcion (revisar)

end

public  sub 	DestroyProxy(proxyId as variant)

		' // b2Settings.b2Assert(0 < me.m_proxyCount && me.m_proxyCount <= b2_maxProxies)
dim 		 proxy  as variant = me.m_proxyPool[ proxyId ]

		' // b2Settings.b2Assert(proxy.IsValid())
dim 		 boundCount  as variant = 2 * me.m_proxyCount

		for (var axis = 0; axis < 2; ++axis)
dim 			 bounds  as variant = me.m_bounds[axis]

dim 			 lowerIndex  as variant = proxy.lowerBounds[axis]

dim 			 upperIndex  as variant = proxy.upperBounds[axis]

dim 			 lowerValue  as variant = bounds[lowerIndex].value

dim 			 upperValue  as variant = bounds[upperIndex].value

			' //  replace memmove calls
			' // memmove(bounds + lowerIndex, bounds + lowerIndex + 1, (upperIndex - lowerIndex - 1) * sizeof(b2Bound))
dim 			 tArr  as variant = new Array()

dim 			 j  as variant = 0

dim 			 tEnd  as variant = upperIndex - lowerIndex - 1

dim 			tBound1
 as variant
dim 			tBound2
 as variant
			' //  make temp array
			for (j = 0; j < tEnd; j++)
				tArr[j] = new b2Bound()
				tBound1 = tArr[j]
				tBound2 = bounds[lowerIndex+1+j]
				tBound1.value = tBound2.value
				tBound1.proxyId = tBound2.proxyId
				tBound1.stabbingCount = tBound2.stabbingCount
			
			' //  move temp array back in to bounds
			tEnd = tArr.length
dim 			 tIndex  as variant = lowerIndex

			for (j = 0; j < tEnd; j++)
				' // bounds[tIndex+j] = tArr[j]
				tBound2 = tArr[j]
				tBound1 = bounds[tIndex+j]
				tBound1.value = tBound2.value
				tBound1.proxyId = tBound2.proxyId
				tBound1.stabbingCount = tBound2.stabbingCount
			
			' // memmove(bounds + upperIndex-1, bounds + upperIndex + 1, (edgeCount - upperIndex - 1) * sizeof(b2Bound))
			' //  make temp array
			tArr = new Array()
			tEnd = boundCount - upperIndex - 1
			for (j = 0; j < tEnd; j++)
				tArr[j] = new b2Bound()
				tBound1 = tArr[j]
				tBound2 = bounds[upperIndex+1+j]
				tBound1.value = tBound2.value
				tBound1.proxyId = tBound2.proxyId
				tBound1.stabbingCount = tBound2.stabbingCount
			
			' //  move temp array back in to bounds
			tEnd = tArr.length
			tIndex = upperIndex-1
			for (j = 0; j < tEnd; j++)
				' // bounds[tIndex+j] = tArr[j]
				tBound2 = tArr[j]
				tBound1 = bounds[tIndex+j]
				tBound1.value = tBound2.value
				tBound1.proxyId = tBound2.proxyId
				tBound1.stabbingCount = tBound2.stabbingCount
			
			' //  Fix bound indices.
			tEnd = boundCount - 2
			for (var index = lowerIndex; index < tEnd; ++index)
			
dim 				 proxy2  as variant = me.m_proxyPool[ bounds[index].proxyId ]

				if (bounds[index].IsLower())
				
					proxy2.lowerBounds[axis] = index
				
				else
				
					proxy2.upperBounds[axis] = index
				
			
			' //  Fix stabbing count.
			tEnd = upperIndex - 1
			for (var index2 = lowerIndex; index2 < tEnd; ++index2)
			
				bounds[index2].stabbingCount--
			
			' //  me.Query for pairs to be removed. lowerIndex and upperIndex are not needed.
			' //  make lowerIndex and upper output using an array and do this for others if compiler doesn't pick them up
			 me.Query([0], [0], lowerValue, upperValue, bounds, boundCount - 2, axis)
		' // b2Settings.b2Assert( me.m_queryResultCount < b2Settings.b2_maxProxies)
		for (var i = 0; i < me.m_queryResultCount; ++i)
			' // b2Settings.b2Assert( me.m_proxyPool[ me.m_queryResults[i]].IsValid())
			 me.m_pairManager.RemoveBufferedPair(proxyId, me.m_queryResults[i])
		 me.m_pairManager.Commit()
		' //  Prepare for next query.
		 me.m_queryResultCount = 0
		 me.IncrementTimeStamp()
		' //  Return the proxy to the pool.
		proxy.userData = null
		proxy.overlapCount = b2BroadPhase.b2_invalid
		proxy.lowerBounds[0] = b2BroadPhase.b2_invalid
		proxy.lowerBounds[1] = b2BroadPhase.b2_invalid
		proxy.upperBounds[0] = b2BroadPhase.b2_invalid
		proxy.upperBounds[1] = b2BroadPhase.b2_invalid
		proxy.SetNext( me.m_freeProxy)
		 me.m_freeProxy = proxyId
		-- me.m_proxyCount
	' //  Call me.MoveProxy times like, then when you are done
	' //  call me.Commit to finalized the proxy pairs (for your time step).
end

public  sub 	MoveProxy(proxyId as variant, aabb as variant) as variant ''funcio as variant ''funcion
dim 		 axis  as variant = 0

dim 		 index  as variant = 0

dim 		bound
 as variant
dim 		prevBound as variant
dim 		nextBound as variant
dim 		 nextProxyId  as variant = 0

dim 		nextProxy
 as variant
		if (proxyId == b2Pair.b2_nullProxy || b2Settings.b2_maxProxies <= proxyId)
			' // b2Settings.b2Assert(false)
			return
 '' TODO: posible funcion (revisar)

		if (aabb.IsValid() == false)
			' // b2Settings.b2Assert(false)
			return
 '' TODO: posible funcion (revisar)

dim 		 boundCount  as variant = 2 * me.m_proxyCount

dim 		 proxy  as variant = me.m_proxyPool[ proxyId ]

		' //  Get new bound values
dim 		 newValues  as variant = new b2BoundValues()

		 me.ComputeBounds(newValues.lowerValues, newValues.upperValues, aabb)
		' //  Get old bound values
dim 		 oldValues  as variant = new b2BoundValues()

		for (axis = 0; axis < 2; ++axis)
			oldValues.lowerValues[axis] = me.m_bounds[axis][proxy.lowerBounds[axis]].value
			oldValues.upperValues[axis] = me.m_bounds[axis][proxy.upperBounds[axis]].value
		for (axis = 0; axis < 2; ++axis)
dim 			 bounds  as variant = me.m_bounds[axis]

dim 			 lowerIndex  as variant = proxy.lowerBounds[axis]

dim 			 upperIndex  as variant = proxy.upperBounds[axis]

dim 			 lowerValue  as variant = newValues.lowerValues[axis]

dim 			 upperValue  as variant = newValues.upperValues[axis]

dim 			 deltaLower  as variant = lowerValue - bounds[lowerIndex].value

dim 			 deltaUpper  as variant = upperValue - bounds[upperIndex].value

			bounds[lowerIndex].value = lowerValue
			bounds[upperIndex].value = upperValue
			' // 
			' //  Expanding adds overlaps
			' // 
			' //  Should we move the lower bound down?
			if (deltaLower < 0)
			
				index = lowerIndex
				while (index > 0 && lowerValue < bounds[index-1].value)
				
					bound = bounds[index]
					prevBound = bounds[index - 1]
dim 					 prevProxyId  as variant = prevBound.proxyId

dim 					 prevProxy  as variant = me.m_proxyPool[ prevBound.proxyId ]

					prevBound.stabbingCount++
					if (prevBound.IsUpper() == true)
					
						if ( me.TestOverlap(newValues, prevProxy))
						
							 me.m_pairManager.AddBufferedPair(proxyId, prevProxyId)
						
						prevProxy.upperBounds[axis]++
						bound.stabbingCount++
					
					else
					
						prevProxy.lowerBounds[axis]++
						bound.stabbingCount--
					
					proxy.lowerBounds[axis]--
					' //  swap
					' // var temp = bound
					' // bound = prevEdge
					' // prevEdge = temp
					bound.Swap(prevBound)
					' // b2Math.b2Swap(bound, prevEdge)
					--index
				
			
			' //  Should we move the upper bound up?
			if (deltaUpper > 0)
			
				index = upperIndex
				while (index < boundCount-1 && bounds[index+1].value <= upperValue)
				
					bound = bounds[ index ]
					nextBound = bounds[ index + 1 ]
					nextProxyId = nextBound.proxyId
					nextProxy = me.m_proxyPool[ nextProxyId ]
					nextBound.stabbingCount++
					if (nextBound.IsLower() == true)
					
						if ( me.TestOverlap(newValues, nextProxy))
						
							 me.m_pairManager.AddBufferedPair(proxyId, nextProxyId)
						
						nextProxy.lowerBounds[axis]--
						bound.stabbingCount++
					
					else
					
						nextProxy.upperBounds[axis]--
						bound.stabbingCount--
					
					proxy.upperBounds[axis]++
					' //  swap
					' // var temp = bound
					' // bound = nextEdge
					' // nextEdge = temp
					bound.Swap(nextBound)
					' // b2Math.b2Swap(bound, nextEdge)
					index++
				
			
			' // 
			' //  Shrinking removes overlaps
			' // 
			' //  Should we move the lower bound up?
			if (deltaLower > 0)
			
				index = lowerIndex
				while (index < boundCount-1 && bounds[index+1].value <= lowerValue)
				
					bound = bounds[ index ]
					nextBound = bounds[ index + 1 ]
					nextProxyId = nextBound.proxyId
					nextProxy = me.m_proxyPool[ nextProxyId ]
					nextBound.stabbingCount--
					if (nextBound.IsUpper())
					
						if ( me.TestOverlap(oldValues, nextProxy))
						
							 me.m_pairManager.RemoveBufferedPair(proxyId, nextProxyId)
						
						nextProxy.upperBounds[axis]--
						bound.stabbingCount--
					
					else
					
						nextProxy.lowerBounds[axis]--
						bound.stabbingCount++
					
					proxy.lowerBounds[axis]++
					' //  swap
					' // var temp = bound
					' // bound = nextEdge
					' // nextEdge = temp
					bound.Swap(nextBound)
					' // b2Math.b2Swap(bound, nextEdge)
					index++
				
			
			' //  Should we move the upper bound down?
			if (deltaUpper < 0)
			
				index = upperIndex
				while (index > 0 && upperValue < bounds[index-1].value)
				
					bound = bounds[index]
					prevBound = bounds[index - 1]
					prevProxyId = prevBound.proxyId
					prevProxy = me.m_proxyPool[ prevProxyId ]
					prevBound.stabbingCount--
					if (prevBound.IsLower() == true)
					
						if ( me.TestOverlap(oldValues, prevProxy))
						
							 me.m_pairManager.RemoveBufferedPair(proxyId, prevProxyId)
						
						prevProxy.lowerBounds[axis]++
						bound.stabbingCount--
					
					else
					
						prevProxy.upperBounds[axis]++
						bound.stabbingCount++
					
					proxy.upperBounds[axis]--
					' //  swap
					' // var temp = bound
					' // bound = prevEdge
					' // prevEdge = temp
					bound.Swap(prevBound)
					' // b2Math.b2Swap(bound, prevEdge)
					index--
				
			
end

public  sub 	Commit() as variant ''funcion
		 me.m_pairManager.Commit()
	' //  me.Query an AABB for overlapping proxies, returns the user data and '' TODO: posible funcion (revisar)

	' //  the count, up to the supplied maximum count.
end

public  sub 	QueryAABB(aabb as variant, userData as variant, maxCount as variant) as variant ''funcion
dim 		 lowerValues  as variant = new Array()

dim 		 upperValues  as variant = new Array()

		 me.ComputeBounds(lowerValues, upperValues, aabb)
dim 		 lowerIndex  as variant = 0

dim 		 upperIndex  as variant = 0

dim 		 lowerIndexOut  as variant = [lowerIndex]

dim 		 upperIndexOut  as variant = [upperIndex]

		 me.Query(lowerIndexOut, upperIndexOut, lowerValues[0], upperValues[0], me.m_bounds[0], 2* me.m_proxyCount, 0)
		 me.Query(lowerIndexOut, upperIndexOut, lowerValues[1], upperValues[1], me.m_bounds[1], 2* me.m_proxyCount, 1)
		' // b2Settings.b2Assert( me.m_queryResultCount < b2Settings.b2_maxProxies)
dim 		 count  as variant = 0

		for (var i = 0; i < me.m_queryResultCount && count < maxCount; ++i, ++count)
			' // b2Settings.b2Assert( me.m_queryResults[i] < b2Settings.b2_maxProxies)
dim 			 proxy  as variant = me.m_proxyPool[ me.m_queryResults[i] ]

			' // b2Settings.b2Assert(proxy.IsValid())
			userData[i] = proxy.userData
		' //  Prepare for next query.
		 me.m_queryResultCount = 0
		 me.IncrementTimeStamp()
		return count
 '' TODO: posible funcion (revisar)

end

public  sub 	Validate()

dim 		pair
 as variant
dim 		proxy1
 as variant
dim 		proxy2
 as variant
dim 		overlap
 as variant
		for (var axis = 0; axis < 2; ++axis)
dim 			 bounds  as variant = me.m_bounds[axis]

dim 			 boundCount  as variant = 2 * me.m_proxyCount

dim 			 stabbingCount  as variant = 0

			for (var i = 0; i < boundCount; ++i)
			
dim 				 bound  as variant = bounds[i]

				' // b2Settings.b2Assert(i == 0 || bounds[i-1].value <= bound->value)
				' // b2Settings.b2Assert(bound->proxyId != b2_nullProxy)
				' // b2Settings.b2Assert( me.m_proxyPool[bound->proxyId].IsValid())
				if (bound.IsLower() == true)
				
					' // b2Settings.b2Assert( me.m_proxyPool[bound.proxyId].lowerBounds[axis] == i)
					stabbingCount++
				
				else
				
					' // b2Settings.b2Assert( me.m_proxyPool[bound.proxyId].upperBounds[axis] == i)
					stabbingCount--
				
				' // b2Settings.b2Assert(bound.stabbingCount == stabbingCount)
			
' // private:
end

public  sub 	ComputeBounds(lowerValues as variant, upperValues as variant, aabb as variant)

		' // b2Settings.b2Assert(aabb.maxVertex.x > aabb.minVertex.x)
		' // b2Settings.b2Assert(aabb.maxVertex.y > aabb.minVertex.y)
		' // var minVertex = b2Math.b2ClampV(aabb.minVertex, me.m_worldAABB.minVertex, me.m_worldAABB.maxVertex)
dim 		 minVertexX  as variant = aabb.minVertex.x

dim 		 minVertexY  as variant = aabb.minVertex.y

		minVertexX = b2Math.b2Min(minVertexX, me.m_worldAABB.maxVertex.x)
		minVertexY = b2Math.b2Min(minVertexY, me.m_worldAABB.maxVertex.y)
		minVertexX = b2Math.b2Max(minVertexX, me.m_worldAABB.minVertex.x)
		minVertexY = b2Math.b2Max(minVertexY, me.m_worldAABB.minVertex.y)
		' // var maxVertex = b2Math.b2ClampV(aabb.maxVertex, me.m_worldAABB.minVertex, me.m_worldAABB.maxVertex)
dim 		 maxVertexX  as variant = aabb.maxVertex.x

dim 		 maxVertexY  as variant = aabb.maxVertex.y

		maxVertexX = b2Math.b2Min(maxVertexX, me.m_worldAABB.maxVertex.x)
		maxVertexY = b2Math.b2Min(maxVertexY, me.m_worldAABB.maxVertex.y)
		maxVertexX = b2Math.b2Max(maxVertexX, me.m_worldAABB.minVertex.x)
		maxVertexY = b2Math.b2Max(maxVertexY, me.m_worldAABB.minVertex.y)
		' //  Bump lower bounds downs and upper bounds up. This ensures correct sorting of
		' //  lower/upper bounds that would have equal values.
		' //  TODO_ERIN implement fast float to uint16 conversion.
		lowerValues[0] = ' /* uint*/( me.m_quantizationFactor.x * (minVertexX - me.m_worldAABB.minVertex.x)) & (b2Settings.USHRT_MAX - 1)
		upperValues[0] = (' /* uint*/( me.m_quantizationFactor.x * (maxVertexX - me.m_worldAABB.minVertex.x))& 0x0000ffff) | 1
		lowerValues[1] = ' /* uint*/( me.m_quantizationFactor.y * (minVertexY - me.m_worldAABB.minVertex.y)) & (b2Settings.USHRT_MAX - 1)
		upperValues[1] = (' /* uint*/( me.m_quantizationFactor.y * (maxVertexY - me.m_worldAABB.minVertex.y))& 0x0000ffff) | 1
	' //  This one is only used for validation.
end

public  sub 	TestOverlapValidate(p1 as variant, p2 as variant) as variant ''funcio as variant ''funcio as variant ''funcion
		for (var axis = 0; axis < 2; ++axis)
dim 			 bounds  as variant = me.m_bounds[axis]

			' // b2Settings.b2Assert(p1.lowerBounds[axis] < 2 * me.m_proxyCount)
			' // b2Settings.b2Assert(p1.upperBounds[axis] < 2 * me.m_proxyCount)
			' // b2Settings.b2Assert(p2.lowerBounds[axis] < 2 * me.m_proxyCount)
			' // b2Settings.b2Assert(p2.upperBounds[axis] < 2 * me.m_proxyCount)
			if (bounds[p1.lowerBounds[axis]].value > bounds[p2.upperBounds[axis]].value)
				return false
 '' TODO: posible funcion (revisar)

			if (bounds[p1.upperBounds[axis]].value < bounds[p2.lowerBounds[axis]].value)
				return false
 '' TODO: posible funcion (revisar)

		return true
 '' TODO: posible funcion (revisar)

end

public  sub 	TestOverlap(b as variant, p as variant) as variant ''funcio as variant ''funcio as variant ''funcion
		for (var axis = 0; axis < 2; ++axis)
dim 			 bounds  as variant = me.m_bounds[axis]

			' // b2Settings.b2Assert(p.lowerBounds[axis] < 2 * me.m_proxyCount)
			' // b2Settings.b2Assert(p.upperBounds[axis] < 2 * me.m_proxyCount)
			if (b.lowerValues[axis] > bounds[p.upperBounds[axis]].value)
				return false
 '' TODO: posible funcion (revisar)

			if (b.upperValues[axis] < bounds[p.lowerBounds[axis]].value)
				return false
 '' TODO: posible funcion (revisar)

		return true
 '' TODO: posible funcion (revisar)

end

public  sub 	Query(lowerQueryOut as variant, upperQueryOut as variant, lowerValue as variant, upperValue as variant, bounds as variant, boundCount as variant, axis as variant)

dim 		 lowerQuery  as variant = b2BroadPhase.BinarySearch(bounds, boundCount, lowerValue)

dim 		 upperQuery  as variant = b2BroadPhase.BinarySearch(bounds, boundCount, upperValue)

		' //  Easy case: lowerQuery <= lowerIndex(i) < upperQuery
		' //  Solution: search query range for min bounds.
		for (var j = lowerQuery; j < upperQuery; ++j)
			if (bounds[j].IsLower())
			
				 me.IncrementOverlapCount(bounds[j].proxyId)
			
		' //  Hard case: lowerIndex(i) < lowerQuery < upperIndex(i)
		' //  Solution: use the stabbing count to search down the bound array.
		if (lowerQuery > 0)
dim 			 i  as variant = lowerQuery - 1

dim 			 s  as variant = bounds[i].stabbingCount

			' //  Find the s overlaps.
			while (s)
			
				' // b2Settings.b2Assert(i >= 0)
				if (bounds[i].IsLower())
				
dim 					 proxy  as variant = me.m_proxyPool[ bounds[i].proxyId ]

					if (lowerQuery <= proxy.upperBounds[axis])
					
						 me.IncrementOverlapCount(bounds[i].proxyId)
						--s
					
				
				--i
			
		lowerQueryOut[0] = lowerQuery
		upperQueryOut[0] = upperQuery
end

public  sub 	IncrementOverlapCount(proxyId as variant)

dim 		 proxy  as variant = me.m_proxyPool[ proxyId ]

		if (proxy.timeStamp < me.m_timeStamp)
			proxy.timeStamp = me.m_timeStamp
			proxy.overlapCount = 1
		else
			proxy.overlapCount = 2
			' // b2Settings.b2Assert( me.m_queryResultCount < b2Settings.b2_maxProxies)
			 me.m_queryResults[ me.m_queryResultCount] = proxyId
			++ me.m_queryResultCount
end

public  sub 	IncrementTimeStamp()

		if ( me.m_timeStamp == b2Settings.USHRT_MAX)
			for (var i = 0; i < b2Settings.b2_maxProxies; ++i)
			
				 me.m_proxyPool[i].timeStamp = 0
			
			 me.m_timeStamp = 1
		else
			++ me.m_timeStamp
' // public:
Public r: new b2PairManager(), as new 2PairManager(),
Public l: new Array(b2Settings.b2_maxPairs), as new rray(b2Settings.b2_maxPairs),
	m_freeProxy: 0
Public s: new Array(2*b2Settings.b2_maxProxies), as new rray(2*b2Settings.b2_maxProxies),
Public s: new Array(b2Settings.b2_maxProxies), as new rray(b2Settings.b2_maxProxies),
	m_queryResultCount: 0
	m_worldAABB: null
Public r: new b2Vec2(), as new 2Vec2(),
	m_proxyCount: 0
	m_timeStamp: 0
b2BroadPhase.s_validate = false
b2BroadPhase.b2_invalid = b2Settings.USHRT_MAX
b2BroadPhase.b2_nullEdge = b2Settings.USHRT_MAX
end

public  sub BinarySearch (bounds as variant, count as variant, value as variant) as variant ''funcio as variant ''funcio as variant ''funcio as variant ''funcion
dim 		 low  as variant = 0

dim 		 high  as variant = count - 1

		while (low <= high)
dim 			 mid  as variant = Math.floor((low + high) / 2)

			if (bounds[mid].value > value)
			
				high = mid - 1
			
			else if (bounds[mid].value < value)
			
				low = mid + 1
			
			else
			
				return ' /* uint*/(mid)
 '' TODO: posible funcion (revisar)

			
		return ' /* uint*/(low)
 '' TODO: posible funcion (revisar)

﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2Collision  as variant = Class.create()

b2Collision.prototype = 
	' //  Null feature
	' //  Find the separation between poly1 and poly2 for a give edge normal on poly1.
	' //  Find the max separation between poly1 and poly2 using edge normals
	' //  from poly1.
	' //  Find edge normal of max separation on A - return if separating axis is found '' TODO: posible funcion (revisar)

	' //  Find edge normal of max separation on B - return if separation axis is found '' TODO: posible funcion (revisar)

	' //  Choose reference edge(minA, minB)
	' //  Find incident edge
	' //  Clip
	' //  The normal points from 1 to 2
end

public  sub 	initialize()
 
b2Collision.b2_nullFeature = 0x000000ff
end

public  sub ClipSegmentToLine (vOut as variant, vIn as variant, normal as variant, offset as variant) as variant ''funcion
		' //  Start with no output points
dim 		 numOut  as variant = 0

dim 		 vIn0  as variant = vIn[0].v

dim 		 vIn1  as variant = vIn[1].v

		' //  Calculate the distance of end points to the line
dim 		 distance0  as variant = b2Math.b2Dot(normal, vIn[0].v) - offset

dim 		 distance1  as variant = b2Math.b2Dot(normal, vIn[1].v) - offset

		' //  If the points are behind the plane
		if (distance0 <= 0.0) vOut[numOut++] = vIn[0]
		if (distance1 <= 0.0) vOut[numOut++] = vIn[1]
		' //  If the points are on different sides of the plane
		if (distance0 * distance1 < 0.0)
			' //  Find intersection point of edge and plane
dim 			 interp  as variant = distance0 / (distance0 - distance1)

			' //  expanded for performance
dim 			 tVec  as variant = vOut[numOut].v

			tVec.x = vIn0.x + interp * (vIn1.x - vIn0.x)
			tVec.y = vIn0.y + interp * (vIn1.y - vIn0.y)
			if (distance0 > 0.0)
			
				vOut[numOut].id = vIn[0].id
			
			else
			
				vOut[numOut].id = vIn[1].id
			
			++numOut
		return numOut
 '' TODO: posible funcion (revisar)

end

public  sub EdgeSeparation (poly1 as variant, edge1 as variant, poly2 as variant) as variant ''funcion
dim 		 vert1s  as variant = poly1.m_vertices

dim 		 count2  as variant = poly2.m_vertexCount

dim 		 vert2s  as variant = poly2.m_vertices

		' //  Convert normal from into poly2's frame.
		' // b2Settings.b2Assert(edge1 < poly1.m_vertexCount)
		' // var normal = b2Math.b2MulMV(poly1.m_R, poly1->m_normals[edge1])
dim 		 normalX  as variant = poly1.m_normals[edge1].x

dim 		 normalY  as variant = poly1.m_normals[edge1].y

dim 		 tX  as variant = normalX

dim 		 tMat  as variant = poly1.m_R

		normalX = tMat.col1.x * tX + tMat.col2.x * normalY
		normalY = tMat.col1.y * tX + tMat.col2.y * normalY
		' //  ^^^^^^^ normal.MulM(poly1.m_R)
		' // var normalLocal2 = b2Math.b2MulTMV(poly2.m_R, normal)
dim 		 normalLocal2X  as variant = normalX

dim 		 normalLocal2Y  as variant = normalY

		tMat = poly2.m_R
		tX = normalLocal2X * tMat.col1.x + normalLocal2Y * tMat.col1.y
		normalLocal2Y = normalLocal2X * tMat.col2.x + normalLocal2Y * tMat.col2.y
		normalLocal2X = tX
		' //  ^^^^^ normalLocal2.MulTM(poly2.m_R)
		' //  Find support vertex on poly2 for -normal.
dim 		 vertexIndex2  as variant = 0

dim 		 minDot  as variant = Number.MAX_VALUE

		for (var i = 0; i < count2; ++i)
			' // var dot = b2Math.b2Dot(vert2s[i], normalLocal2)
dim 			 tVec  as variant = vert2s[i]

dim 			 dot  as variant = tVec.x * normalLocal2X + tVec.y * normalLocal2Y

			if (dot < minDot)
			
				minDot = dot
				vertexIndex2 = i
			
		' // b2Vec2 v1 = poly1->m_position + b2Mul(poly1->m_R, vert1s[edge1])
		tMat = poly1.m_R
dim 		 v1X  as variant = poly1.m_position.x + (tMat.col1.x * vert1s[edge1].x + tMat.col2.x * vert1s[edge1].y)
dim 		 v1Y  as variant = poly1.m_position.y + (tMat.col1.y * vert1s[edge1].x + tMat.col2.y * vert1s[edge1].y)
		' // b2Vec2 v2 = poly2->m_position + b2Mul(poly2->m_R, vert2s[vertexIndex2])
		tMat = poly2.m_R
dim 		 v2X  as variant = poly2.m_position.x + (tMat.col1.x * vert2s[vertexIndex2].x + tMat.col2.x * vert2s[vertexIndex2].y)
dim 		 v2Y  as variant = poly2.m_position.y + (tMat.col1.y * vert2s[vertexIndex2].x + tMat.col2.y * vert2s[vertexIndex2].y)
		' // var separation = b2Math.b2Dot( b2Math.SubtractVV( v2, v1 ) , normal)
		v2X -= v1X
		v2Y -= v1Y
		' // var separation = b2Math.b2Dot( v2 , normal)
dim 		 separation  as variant = v2X * normalX + v2Y * normalY

		return separation
 '' TODO: posible funcion (revisar)

end

public  sub FindMaxSeparation (edgeIndex ' /* int ptr*/ as variant, poly1 as variant, poly2 as variant, conservative as variant) as variant ''funcio as variant ''funcio as variant ''funcio as variant ''funcio as variant ''funcio as variant ''funcion
dim 		 count1  as variant = poly1.m_vertexCount

		' //  Vector pointing from the origin of poly1 to the origin of poly2.
		' // var d = b2Math.SubtractVV( poly2.m_position, poly1.m_position )
dim 		 dX  as variant = poly2.m_position.x - poly1.m_position.x

dim 		 dY  as variant = poly2.m_position.y - poly1.m_position.y

		' // var dLocal1 = b2Math.b2MulTMV(poly1.m_R, d)
dim 		 dLocal1X  as variant = (dX * poly1.m_R.col1.x + dY * poly1.m_R.col1.y)

dim 		 dLocal1Y  as variant = (dX * poly1.m_R.col2.x + dY * poly1.m_R.col2.y)

		' //  Get support vertex hint for our search
dim 		 edge  as variant = 0

dim 		 maxDot  as variant = -Number.MAX_VALUE

		for (var i = 0; i < count1; ++i)
			' // var dot = b2Math.b2Dot(poly.m_normals[i], dLocal1)
dim 			 dot  as variant = (poly1.m_normals[i].x * dLocal1X + poly1.m_normals[i].y * dLocal1Y)

			if (dot > maxDot)
			
				maxDot = dot
				edge = i
			
		' //  Get the separation for the edge normal.
dim 		 s  as variant = b2Collision.EdgeSeparation(poly1, edge, poly2)

		if (s > 0.0 && conservative == false)
			return s
 '' TODO: posible funcion (revisar)

		' //  Check the separation for the neighboring edges.
dim 		 prevEdge  as variant = edge - 1 >= 0 ? edge - 1 : count1 - 1

dim 		 sPrev  as variant = b2Collision.EdgeSeparation(poly1, prevEdge, poly2)

		if (sPrev > 0.0 && conservative == false)
			return sPrev
 '' TODO: posible funcion (revisar)

dim 		 nextEdge  as variant = edge + 1 < count1 ? edge + 1 : 0

dim 		 sNext  as variant = b2Collision.EdgeSeparation(poly1, nextEdge, poly2)

		if (sNext > 0.0 && conservative == false)
			return sNext
 '' TODO: posible funcion (revisar)

		' //  Find the best edge and the search direction.
dim 		 bestEdge  as variant = 0

dim 		bestSeparation
 as variant
dim 		 increment  as variant = 0

		if (sPrev > s && sPrev > sNext)
			increment = -1
			bestEdge = prevEdge
			bestSeparation = sPrev
		else if (sNext > s)
			increment = 1
			bestEdge = nextEdge
			bestSeparation = sNext
		else
			' //  pointer out
			edgeIndex[0] = edge
			return s
 '' TODO: posible funcion (revisar)

		while (true)
			if (increment == -1)
				edge = bestEdge - 1 >= 0 ? bestEdge - 1 : count1 - 1
			else
				edge = bestEdge + 1 < count1 ? bestEdge + 1 : 0
			s = b2Collision.EdgeSeparation(poly1, edge, poly2)
			if (s > 0.0 && conservative == false)
			
				return s
 '' TODO: posible funcion (revisar)

			
			if (s > bestSeparation)
			
				bestEdge = edge
				bestSeparation = s
			
			else
			
				break
			
		' //  pointer out
		edgeIndex[0] = bestEdge
		return bestSeparation
 '' TODO: posible funcion (revisar)

end

public  sub FindIncidentEdge (c as variant, poly1 as variant, edge1 as variant, poly2 as variant)

dim 		 count1  as variant = poly1.m_vertexCount

dim 		 vert1s  as variant = poly1.m_vertices

dim 		 count2  as variant = poly2.m_vertexCount

dim 		 vert2s  as variant = poly2.m_vertices

		' //  Get the vertices associated with edge1.
dim 		 vertex11  as variant = edge1

dim 		 vertex12  as variant = edge1 + 1 == count1 ? 0 : edge1 + 1

		' //  Get the normal of edge1.
dim 		 tVec  as variant = vert1s[vertex12]

		' // var normal1Local1 = b2Math.b2CrossVF( b2Math.SubtractVV( vert1s[vertex12], vert1s[vertex11] ), 1.0)
dim 		 normal1Local1X  as variant = tVec.x

dim 		 normal1Local1Y  as variant = tVec.y

		tVec = vert1s[vertex11]
		normal1Local1X -= tVec.x
		normal1Local1Y -= tVec.y
dim 		 tX  as variant = normal1Local1X

		normal1Local1X = normal1Local1Y
		normal1Local1Y = -tX
		' //  ^^^^ normal1Local1.CrossVF(1.0)
dim 		 invLength  as variant = 1.0 / Math.sqrt(normal1Local1X*normal1Local1X + normal1Local1Y*normal1Local1Y)

		normal1Local1X *= invLength
		normal1Local1Y *= invLength
		' //  ^^^^normal1Local1.Normalize()
		' // var normal1 = b2Math.b2MulMV(poly1.m_R, normal1Local1)
dim 		 normal1X  as variant = normal1Local1X

dim 		 normal1Y  as variant = normal1Local1Y

		tX = normal1X
dim 		 tMat  as variant = poly1.m_R

		normal1X = tMat.col1.x * tX + tMat.col2.x * normal1Y
		normal1Y = tMat.col1.y * tX + tMat.col2.y * normal1Y
		' //  ^^^^ normal1.MulM(poly1.m_R)
		' // var normal1Local2 = b2Math.b2MulTMV(poly2.m_R, normal1)
dim 		 normal1Local2X  as variant = normal1X

dim 		 normal1Local2Y  as variant = normal1Y

		tMat = poly2.m_R
		tX = normal1Local2X * tMat.col1.x + normal1Local2Y * tMat.col1.y
		normal1Local2Y = normal1Local2X * tMat.col2.x + normal1Local2Y * tMat.col2.y
		normal1Local2X = tX
		' //  ^^^^ normal1Local2.MulTM(poly2.m_R)
		' //  Find the incident edge on poly2.
dim 		 vertex21  as variant = 0

dim 		 vertex22  as variant = 0

dim 		 minDot  as variant = Number.MAX_VALUE

		for (var i = 0; i < count2; ++i)
dim 			 i1  as variant = i

dim 			 i2  as variant = i + 1 < count2 ? i + 1 : 0

			' // var normal2Local2 = b2Math.b2CrossVF( b2Math.SubtractVV( vert2s[i2], vert2s[i1] ), 1.0)
			tVec = vert2s[i2]
dim 			 normal2Local2X  as variant = tVec.x

dim 			 normal2Local2Y  as variant = tVec.y

			tVec = vert2s[i1]
			normal2Local2X -= tVec.x
			normal2Local2Y -= tVec.y
			tX = normal2Local2X
			normal2Local2X = normal2Local2Y
			normal2Local2Y = -tX
			' //  ^^^^ normal2Local2.CrossVF(1.0)
			invLength = 1.0 / Math.sqrt(normal2Local2X*normal2Local2X + normal2Local2Y*normal2Local2Y)
			normal2Local2X *= invLength
			normal2Local2Y *= invLength
			' //  ^^^^ normal2Local2.Normalize()
			' // var dot = b2Math.b2Dot(normal2Local2, normal1Local2)
dim 			 dot  as variant = normal2Local2X * normal1Local2X + normal2Local2Y * normal1Local2Y

			if (dot < minDot)
			
				minDot = dot
				vertex21 = i1
				vertex22 = i2
			
dim 		tClip
 as variant
		' //  Build the clip vertices for the incident edge.
		tClip = c[0]
		' // tClip.v = b2Math.AddVV(poly2.m_position, b2Math.b2MulMV(poly2.m_R, vert2s[vertex21]))
		tVec = tClip.v
		tVec.SetV(vert2s[vertex21])
		tVec.MulM(poly2.m_R)
		tVec.Add(poly2.m_position)
		tClip.id.features.referenceFace = edge1
		tClip.id.features.incidentEdge = vertex21
		tClip.id.features.incidentVertex = vertex21
		tClip = c[1]
		' // tClip.v = b2Math.AddVV(poly2.m_position, b2Math.b2MulMV(poly2.m_R, vert2s[vertex22]))
		tVec = tClip.v
		tVec.SetV(vert2s[vertex22])
		tVec.MulM(poly2.m_R)
		tVec.Add(poly2.m_position)
		tClip.id.features.referenceFace = edge1
		tClip.id.features.incidentEdge = vertex21
		tClip.id.features.incidentVertex = vertex22
b2Collision.b2CollidePolyTempVec = new b2Vec2()
end

public  sub b2CollidePoly (manifold as variant, polyA as variant, polyB as variant, conservative as variant) as variant ''funcio as variant ''funcio as variant ''funcio as variant ''funcion
		manifold.pointCount = 0
dim 		 edgeA  as variant = 0

dim 		 edgeAOut  as variant = [edgeA]

dim 		 separationA  as variant = b2Collision.FindMaxSeparation(edgeAOut, polyA, polyB, conservative)

		edgeA = edgeAOut[0]
		if (separationA > 0.0 && conservative == false)
			return
 '' TODO: posible funcion (revisar)

dim 		 edgeB  as variant = 0

dim 		 edgeBOut  as variant = [edgeB]

dim 		 separationB  as variant = b2Collision.FindMaxSeparation(edgeBOut, polyB, polyA, conservative)

		edgeB = edgeBOut[0]
		if (separationB > 0.0 && conservative == false)
			return
 '' TODO: posible funcion (revisar)

dim 		poly1
 as variant
dim 		poly2
 as variant
dim 		 edge1  as variant = 0

dim 		 flip  as variant = 0

dim 		 k_relativeTol  as variant = 0.98

dim 		 k_absoluteTol  as variant = 0.001

		' //  TODO_ERIN use "radius" of poly for absolute tolerance.
		if (separationB > k_relativeTol * separationA + k_absoluteTol)
			poly1 = polyB
			poly2 = polyA
			edge1 = edgeB
			flip = 1
		else
			poly1 = polyA
			poly2 = polyB
			edge1 = edgeA
			flip = 0
dim 		 incidentEdge  as variant = [new ClipVertex(), new ClipVertex()]

		b2Collision.FindIncidentEdge(incidentEdge, poly1, edge1, poly2)
dim 		 count1  as variant = poly1.m_vertexCount

dim 		 vert1s  as variant = poly1.m_vertices

dim 		 v11  as variant = vert1s[edge1]

dim 		 v12  as variant = edge1 + 1 < count1 ? vert1s[edge1+1] : vert1s[0]

		' // var dv = b2Math.SubtractVV(v12, v11)
dim 		 dvX  as variant = v12.x - v11.x

dim 		 dvY  as variant = v12.y - v11.y

		' // var sideNormal = b2Math.b2MulMV(poly1.m_R, b2Math.SubtractVV(v12, v11))
dim 		 sideNormalX  as variant = v12.x - v11.x

dim 		 sideNormalY  as variant = v12.y - v11.y

dim 		 tX  as variant = sideNormalX

dim 		 tMat  as variant = poly1.m_R

		sideNormalX = tMat.col1.x * tX + tMat.col2.x * sideNormalY
		sideNormalY = tMat.col1.y * tX + tMat.col2.y * sideNormalY
		' //  ^^^^ sideNormal.MulM(poly1.m_R)
dim 		 invLength  as variant = 1.0 / Math.sqrt(sideNormalX*sideNormalX + sideNormalY*sideNormalY)

		sideNormalX *= invLength
		sideNormalY *= invLength
		' //  ^^^^ sideNormal.Normalize()
		' // var frontNormal = b2Math.b2CrossVF(sideNormal, 1.0)
dim 		 frontNormalX  as variant = sideNormalX

dim 		 frontNormalY  as variant = sideNormalY

		tX = frontNormalX
		frontNormalX = frontNormalY
		frontNormalY = -tX
		' //  ^^^^ frontNormal.CrossVF(1.0)
		' //  Expanded for performance
		' // v11 = b2Math.AddVV(poly1.m_position, b2Math.b2MulMV(poly1.m_R, v11))
dim 		 v11X  as variant = v11.x

dim 		 v11Y  as variant = v11.y

		tX = v11X
		tMat = poly1.m_R
		v11X = tMat.col1.x * tX + tMat.col2.x * v11Y
		v11Y = tMat.col1.y * tX + tMat.col2.y * v11Y
		' //  ^^^^ v11.MulM(poly1.m_R)
		v11X += poly1.m_position.x
		v11Y += poly1.m_position.y
		' // v12 = b2Math.AddVV(poly1.m_position, b2Math.b2MulMV(poly1.m_R, v12))
dim 		 v12X  as variant = v12.x

dim 		 v12Y  as variant = v12.y

		tX = v12X
		tMat = poly1.m_R
		v12X = tMat.col1.x * tX + tMat.col2.x * v12Y
		v12Y = tMat.col1.y * tX + tMat.col2.y * v12Y
		' //  ^^^^ v12.MulM(poly1.m_R)
		v12X += poly1.m_position.x
		v12Y += poly1.m_position.y
		' // var frontOffset = b2Math.b2Dot(frontNormal, v11)
dim 		 frontOffset  as variant = frontNormalX * v11X + frontNormalY * v11Y

		' // var sideOffset1 = -b2Math.b2Dot(sideNormal, v11)
dim 		 sideOffset1  as variant = -(sideNormalX * v11X + sideNormalY * v11Y)

		' // var sideOffset2 = b2Math.b2Dot(sideNormal, v12)
dim 		 sideOffset2  as variant = sideNormalX * v12X + sideNormalY * v12Y

		' //  Clip incident edge against extruded edge1 side edges.
dim 		 clipPoints1  as variant = [new ClipVertex(), new ClipVertex()]

dim 		 clipPoints2  as variant = [new ClipVertex(), new ClipVertex()]

dim 		 np  as variant = 0

		' //  Clip to box side 1
		b2Collision.b2CollidePolyTempVec.Set(-sideNormalX, -sideNormalY)
		np = b2Collision.ClipSegmentToLine(clipPoints1, incidentEdge, b2Collision.b2CollidePolyTempVec, sideOffset1)
		if (np < 2)
			return
 '' TODO: posible funcion (revisar)

		' //  Clip to negative box side 1
		b2Collision.b2CollidePolyTempVec.Set(sideNormalX, sideNormalY)
		np = b2Collision.ClipSegmentToLine(clipPoints2, clipPoints1,  b2Collision.b2CollidePolyTempVec, sideOffset2)
		if (np < 2)
			return
 '' TODO: posible funcion (revisar)

		' //  Now clipPoints2 contains the clipped points.
		if (flip)
			manifold.normal.Set(-frontNormalX, -frontNormalY)
		else
			manifold.normal.Set(frontNormalX, frontNormalY)
		' //  ^^^^ manifold.normal = flip ? frontNormal.Negative() : frontNormal
dim 		 pointCount  as variant = 0

		for (var i = 0; i < b2Settings.b2_maxManifoldPoints; ++i)
			' // var separation = b2Math.b2Dot(frontNormal, clipPoints2[i].v) - frontOffset
dim 			 tVec  as variant = clipPoints2[i].v

dim 			 separation  as variant = (frontNormalX * tVec.x + frontNormalY * tVec.y) - frontOffset

			if (separation <= 0.0 || conservative == true)
			
dim 				 cp  as variant = manifold.points[ pointCount ]

				cp.separation = separation
				cp.position.SetV( clipPoints2[i].v )
				cp.id.Set( clipPoints2[i].id )
				cp.id.features.flip = flip
				++pointCount
			
		manifold.pointCount = pointCount
end

public  sub b2CollideCircle (manifold as variant, circle1 as variant, circle2 as variant, conservative as variant) as variant ''funcion
		manifold.pointCount = 0
		' // var d = b2Math.SubtractVV(circle2.m_position, circle1.m_position)
dim 		 dX  as variant = circle2.m_position.x - circle1.m_position.x

dim 		 dY  as variant = circle2.m_position.y - circle1.m_position.y

		' // var distSqr = b2Math.b2Dot(d, d)
dim 		 distSqr  as variant = dX * dX + dY * dY

dim 		 radiusSum  as variant = circle1.m_radius + circle2.m_radius

		if (distSqr > radiusSum * radiusSum && conservative == false)
			return
 '' TODO: posible funcion (revisar)

dim 		separation
 as variant
		if (distSqr < Number.MIN_VALUE)
			separation = -radiusSum
			manifold.normal.Set(0.0, 1.0)
		else
dim 			 dist  as variant = Math.sqrt(distSqr)

			separation = dist - radiusSum
dim 			 a  as variant = 1.0 / dist

			manifold.normal.x = a * dX
			manifold.normal.y = a * dY
		manifold.pointCount = 1
dim 		 tPoint  as variant = manifold.points[0]

		tPoint.id.set_key(0)
		tPoint.separation = separation
		' // tPoint.position = b2Math.SubtractVV(circle2.m_position, b2Math.MulFV(circle2.m_radius, manifold.normal))
		tPoint.position.x = circle2.m_position.x - (circle2.m_radius * manifold.normal.x)
		tPoint.position.y = circle2.m_position.y - (circle2.m_radius * manifold.normal.y)
end

public  sub b2CollidePolyAndCircle (manifold as variant, poly as variant, circle as variant, conservative as variant) as variant ''funcio as variant ''funcio as variant ''funcio as variant ''funcio as variant ''funcion
		manifold.pointCount = 0
dim 		tPoint
 as variant
dim 		dX
 as variant
dim 		dY
 as variant
		' //  Compute circle position in the frame of the polygon.
		' // var xLocal = b2Math.b2MulTMV(poly.m_R, b2Math.SubtractVV(circle.m_position, poly.m_position))
dim 		 xLocalX  as variant = circle.m_position.x - poly.m_position.x

dim 		 xLocalY  as variant = circle.m_position.y - poly.m_position.y

dim 		 tMat  as variant = poly.m_R

dim 		 tX  as variant = xLocalX * tMat.col1.x + xLocalY * tMat.col1.y

		xLocalY = xLocalX * tMat.col2.x + xLocalY * tMat.col2.y
		xLocalX = tX
dim 		dist
 as variant
		' //  Find the min separating edge.
dim 		 normalIndex  as variant = 0

dim 		 separation  as variant = -Number.MAX_VALUE

dim 		 radius  as variant = circle.m_radius

		for (var i = 0; i < poly.m_vertexCount; ++i)
			' // var s = b2Math.b2Dot(poly.m_normals[i], b2Math.SubtractVV(xLocal, poly.m_vertices[i]))
dim 			 s  as variant = poly.m_normals[i].x * (xLocalX-poly.m_vertices[i].x) + poly.m_normals[i].y * (xLocalY-poly.m_vertices[i].y)

			if (s > radius)
			
				' //  Early out.
				return
 '' TODO: posible funcion (revisar)

			
			if (s > separation)
			
				separation = s
				normalIndex = i
			
		' //  If the center is inside the polygon ...
		if (separation < Number.MIN_VALUE)
			manifold.pointCount = 1
			' // manifold.normal = b2Math.b2MulMV(poly.m_R, poly.m_normals[normalIndex])
dim 			 tVec  as variant = poly.m_normals[normalIndex]

			manifold.normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y
			manifold.normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y
			tPoint = manifold.points[0]
			tPoint.id.features.incidentEdge = normalIndex
			tPoint.id.features.incidentVertex = b2Collision.b2_nullFeature
			tPoint.id.features.referenceFace = b2Collision.b2_nullFeature
			tPoint.id.features.flip = 0
			tPoint.position.x = circle.m_position.x - radius * manifold.normal.x
			tPoint.position.y = circle.m_position.y - radius * manifold.normal.y
			' // tPoint.position = b2Math.SubtractVV(circle.m_position , b2Math.MulFV(radius , manifold.normal))
			tPoint.separation = separation - radius
			return
 '' TODO: posible funcion (revisar)

		' //  Project the circle center onto the edge segment.
dim 		 vertIndex1  as variant = normalIndex

dim 		 vertIndex2  as variant = vertIndex1 + 1 < poly.m_vertexCount ? vertIndex1 + 1 : 0

		' // var e = b2Math.SubtractVV(poly.m_vertices[vertIndex2] , poly.m_vertices[vertIndex1])
dim 		 eX  as variant = poly.m_vertices[vertIndex2].x - poly.m_vertices[vertIndex1].x

dim 		 eY  as variant = poly.m_vertices[vertIndex2].y - poly.m_vertices[vertIndex1].y

		' // var length = e.Normalize()
dim 		 length  as variant = Math.sqrt(eX*eX + eY*eY)

		eX /= length
		eY /= length
		' //  If the edge length is zero ...
		if (length < Number.MIN_VALUE)
			' // d = b2Math.SubtractVV(xLocal , poly.m_vertices[vertIndex1])
			dX = xLocalX - poly.m_vertices[vertIndex1].x
			dY = xLocalY - poly.m_vertices[vertIndex1].y
			' // dist = d.Normalize()
			dist = Math.sqrt(dX*dX + dY*dY)
			dX /= dist
			dY /= dist
			if (dist > radius)
			
				return
 '' TODO: posible funcion (revisar)

			
			manifold.pointCount = 1
			' // manifold.normal = b2Math.b2MulMV(poly.m_R, d)
			manifold.normal.Set(tMat.col1.x * dX + tMat.col2.x * dY, tMat.col1.y * dX + tMat.col2.y * dY)
			tPoint = manifold.points[0]
			tPoint.id.features.incidentEdge = b2Collision.b2_nullFeature
			tPoint.id.features.incidentVertex = vertIndex1
			tPoint.id.features.referenceFace = b2Collision.b2_nullFeature
			tPoint.id.features.flip = 0
			' // tPoint.position = b2Math.SubtractVV(circle.m_position , b2Math.MulFV(radius , manifold.normal))
			tPoint.position.x = circle.m_position.x - radius * manifold.normal.x
			tPoint.position.y = circle.m_position.y - radius * manifold.normal.y
			tPoint.separation = dist - radius
			return
 '' TODO: posible funcion (revisar)

		' //  Project the center onto the edge.
		' // var u = b2Math.b2Dot(b2Math.SubtractVV(xLocal , poly.m_vertices[vertIndex1]) , e)
dim 		 u  as variant = (xLocalX-poly.m_vertices[vertIndex1].x) * eX + (xLocalY-poly.m_vertices[vertIndex1].y) * eY

		tPoint = manifold.points[0]
		tPoint.id.features.incidentEdge = b2Collision.b2_nullFeature
		tPoint.id.features.incidentVertex = b2Collision.b2_nullFeature
		tPoint.id.features.referenceFace = b2Collision.b2_nullFeature
		tPoint.id.features.flip = 0
dim 		pX, pY
 as variant
		if (u <= 0.0)
			pX = poly.m_vertices[vertIndex1].x
			pY = poly.m_vertices[vertIndex1].y
			tPoint.id.features.incidentVertex = vertIndex1
		else if (u >= length)
			pX = poly.m_vertices[vertIndex2].x
			pY = poly.m_vertices[vertIndex2].y
			tPoint.id.features.incidentVertex = vertIndex2
		else
			' // p = b2Math.AddVV(poly.m_vertices[vertIndex1] , b2Math.MulFV(u, e))
			pX = eX * u + poly.m_vertices[vertIndex1].x
			pY = eY * u + poly.m_vertices[vertIndex1].y
			tPoint.id.features.incidentEdge = vertIndex1
		' // d = b2Math.SubtractVV(xLocal , p)
		dX = xLocalX - pX
		dY = xLocalY - pY
		' // dist = d.Normalize()
		dist = Math.sqrt(dX*dX + dY*dY)
		dX /= dist
		dY /= dist
		if (dist > radius)
			return
 '' TODO: posible funcion (revisar)

		manifold.pointCount = 1
		' // manifold.normal = b2Math.b2MulMV(poly.m_R, d)
		manifold.normal.Set(tMat.col1.x * dX + tMat.col2.x * dY, tMat.col1.y * dX + tMat.col2.y * dY)
		' // tPoint.position = b2Math.SubtractVV(circle.m_position , b2Math.MulFV(radius , manifold.normal))
		tPoint.position.x = circle.m_position.x - radius * manifold.normal.x
		tPoint.position.y = circle.m_position.y - radius * manifold.normal.y
		tPoint.separation = dist - radius
end

public  sub b2TestOverlap (a as variant, b as variant) as variant ''funcio as variant ''funcio as variant ''funcion
dim 		 t1  as variant = b.minVertex

dim 		 t2  as variant = a.maxVertex

		' // d1 = b2Math.SubtractVV(b.minVertex, a.maxVertex)
dim 		 d1X  as variant = t1.x - t2.x

dim 		 d1Y  as variant = t1.y - t2.y

		' // d2 = b2Math.SubtractVV(a.minVertex, b.maxVertex)
		t1 = a.minVertex
		t2 = b.maxVertex
dim 		 d2X  as variant = t1.x - t2.x

dim 		 d2Y  as variant = t1.y - t2.y

		if (d1X > 0.0 || d1Y > 0.0)
			return false
 '' TODO: posible funcion (revisar)

		if (d2X > 0.0 || d2Y > 0.0)
			return false
 '' TODO: posible funcion (revisar)

		return true
 '' TODO: posible funcion (revisar)

﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2PolyContact  as variant = Class.create()

inherits , b2Contact
inherits 
end

public  sub 		initialize(s1 as variant, s2 as variant)
 as variant ''funcion
		' //  The constructor for b2Contact
		' //  initialize instance variables for references
		 me.m_node1 = new b2ContactNode()
		 me.m_node2 = new b2ContactNode()
		' // 
		 me.m_flags = 0
		if (!s1 || !s2)
			 me.m_shape1 = null
			 me.m_shape2 = null
			return
 '' TODO: posible funcion (revisar)

		 me.m_shape1 = s1
		 me.m_shape2 = s2
		 me.m_manifoldCount = 0
		 me.m_friction = Math.sqrt( me.m_shape1.m_friction * me.m_shape2.m_friction)
		 me.m_restitution = b2Math.b2Max( me.m_shape1.m_restitution, me.m_shape2.m_restitution)
		 me.m_prev = null
		 me.m_next = null
		 me.m_node1.contact = null
		 me.m_node1.prev = null
		 me.m_node1.next = null
		 me.m_node1.other = null
		 me.m_node2.contact = null
		 me.m_node2.prev = null
		 me.m_node2.next = null
		 me.m_node2.other = null
		' // 
		' //  initialize instance variables for references
		 me.m0 = new b2Manifold()
		 me.m_manifold = [new b2Manifold()]
		' // 
		' // super(shape1, shape2)
		' // b2Settings.b2Assert( me.m_shape1.m_type == b2Shape.e_polyShape)
		' // b2Settings.b2Assert( me.m_shape2.m_type == b2Shape.e_polyShape)
		 me.m_manifold[0].pointCount = 0
	' // ~b2PolyContact() 
	' //  store temp manifold to reduce calls to new
Public 0: new b2Manifold(), as new 2Manifold(),
end

public  sub 	Evaluate()

dim 		 tMani  as variant = me.m_manifold[0]

		' //  replace memcpy
		' //  memcpy(& me.m0, & me.m_manifold, sizeof(b2Manifold))
		' // me.m0.points = new Array(tMani.pointCount)
dim 		 tPoints  as variant = me.m0.points

		for (var k = 0; k < tMani.pointCount; k++)
dim 			 tPoint  as variant = tPoints[k]

dim 			 tPoint0  as variant = tMani.points[k]

			' // tPoint.separation = tPoint0.separation
			tPoint.normalImpulse = tPoint0.normalImpulse
			tPoint.tangentImpulse = tPoint0.tangentImpulse
			' // tPoint.position.SetV( tPoint0.position )
			tPoint.id = tPoint0.id.Copy()
			' /* me.m0.points[k].id.features = new Features()
			 me.m0.points[k].id.features.referenceFace = me.m_manifold[0].points[k].id.features.referenceFace
			 me.m0.points[k].id.features.incidentEdge = me.m_manifold[0].points[k].id.features.incidentEdge
			 me.m0.points[k].id.features.incidentVertex = me.m_manifold[0].points[k].id.features.incidentVertex
			 me.m0.points[k].id.features.flip = me.m_manifold[0].points[k].id.features.flip
*/
		' // me.m0.normal.SetV( tMani.normal )
		 me.m0.pointCount = tMani.pointCount
		b2Collision.b2CollidePoly(tMani, me.m_shape1, me.m_shape2, false)
		' //  Match contact ids to facilitate warm starting.
		if (tMani.pointCount > 0)
dim 			 match  as variant = [false, false]

			' //  Match old contact ids to new contact ids and copy the
			' //  stored impulses to warm start the solver.
			for (var i = 0; i < tMani.pointCount; ++i)
			
dim 				 cp  as variant = tMani.points[ i ]

				cp.normalImpulse = 0.0
				cp.tangentImpulse = 0.0
dim 				 idKey  as variant = cp.id.key

				for (var j = 0; j < me.m0.pointCount; ++j)
				
					if (match[j] == true)
						continue
dim 					 cp0  as variant = me.m0.points[j]

dim 					 id0  as variant = cp0.id

					if (id0.key == idKey)
					
						match[j] = true
						cp.normalImpulse = cp0.normalImpulse
						cp.tangentImpulse = cp0.tangentImpulse
						break
					
				
			
			 me.m_manifoldCount = 1
		else
			 me.m_manifoldCount = 0
end

public  sub 	GetManifolds() as variant ''funcion
		return me.m_manifold
 '' TODO: posible funcion (revisar)

	m_manifold: [new b2Manifold()])
end

public  sub Create (shape1 as variant, shape2 as variant, allocator as variant) as variant ''funcion
		' // void* mem = allocator->Allocate(sizeof(b2PolyContact))
		return new b2PolyContact(shape1, shape2)
 '' TODO: posible funcion (revisar)

end

public  sub Destroy (contact as variant, allocator as variant)

		' // ((b2PolyContact*)contact)->~b2PolyContact()
		' // allocator->Free(contact, sizeof(b2PolyContact))
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2ContactConstraint  as variant = Class.create()

b2ContactConstraint.prototype = 
end

public  sub 	initialize()

		' //  initialize instance variables for references
		 me.normal = new b2Vec2()
		' // 
		 me.points = new Array(b2Settings.b2_maxManifoldPoints)
		for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++)
			 me.points[i] = new b2ContactConstraintPoint()
	points: null
Public l: new b2Vec2(), as new 2Vec2(),
	manifold: null
	body1: null
	body2: null
	friction: null
	restitution: null
	pointCount: 0
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2CircleContact  as variant = Class.create()

inherits , b2Contact
inherits 
end

public  sub 		initialize(s1 as variant, s2 as variant)
 as variant ''funcion
		' //  The constructor for b2Contact
		' //  initialize instance variables for references
		 me.m_node1 = new b2ContactNode()
		 me.m_node2 = new b2ContactNode()
		' // 
		 me.m_flags = 0
		if (!s1 || !s2)
			 me.m_shape1 = null
			 me.m_shape2 = null
			return
 '' TODO: posible funcion (revisar)

		 me.m_shape1 = s1
		 me.m_shape2 = s2
		 me.m_manifoldCount = 0
		 me.m_friction = Math.sqrt( me.m_shape1.m_friction * me.m_shape2.m_friction)
		 me.m_restitution = b2Math.b2Max( me.m_shape1.m_restitution, me.m_shape2.m_restitution)
		 me.m_prev = null
		 me.m_next = null
		 me.m_node1.contact = null
		 me.m_node1.prev = null
		 me.m_node1.next = null
		 me.m_node1.other = null
		 me.m_node2.contact = null
		 me.m_node2.prev = null
		 me.m_node2.next = null
		 me.m_node2.other = null
		' // 
		' //  initialize instance variables for references
		 me.m_manifold = [new b2Manifold()]
		' // 
		' // super(shape1, shape2)
		' // b2Settings.b2Assert( me.m_shape1.m_type == b2Shape.e_circleShape)
		' // b2Settings.b2Assert( me.m_shape2.m_type == b2Shape.e_circleShape)
		 me.m_manifold[0].pointCount = 0
		 me.m_manifold[0].points[0].normalImpulse = 0.0
		 me.m_manifold[0].points[0].tangentImpulse = 0.0
	' // ~b2CircleContact() 
end

public  sub 	Evaluate()

		b2Collision.b2CollideCircle( me.m_manifold[0], me.m_shape1, me.m_shape2, false)
		if ( me.m_manifold[0].pointCount > 0)
			 me.m_manifoldCount = 1
		else
			 me.m_manifoldCount = 0
end

public  sub 	GetManifolds() as variant ''funcion
		return me.m_manifold
 '' TODO: posible funcion (revisar)

	m_manifold: [new b2Manifold()])
end

public  sub Create (shape1 as variant, shape2 as variant, allocator as variant) as variant ''funcion
		return new b2CircleContact(shape1, shape2)
 '' TODO: posible funcion (revisar)

end

public  sub Destroy (contact as variant, allocator as variant)

		' // 
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2ContactConstraintPoint  as variant = Class.create()

b2ContactConstraintPoint.prototype = 
Public 1: new b2Vec2(), as new 2Vec2(),
Public 2: new b2Vec2(), as new 2Vec2(),
	normalImpulse: null
	tangentImpulse: null
	positionImpulse: null
	normalMass: null
	tangentMass: null
	separation: null
	velocityBias: null
end

public  sub 	initialize()
 
		' //  initialize instance variables for references
		 me.localAnchor1 = new b2Vec2()
		 me.localAnchor2 = new b2Vec2()
		' // 
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2ContactNode  as variant = Class.create()

b2ContactNode.prototype = 
	other: null
	contact: null
	prev: null
	next: null
end

public  sub 	initialize()
 
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2PolyAndCircleContact  as variant = Class.create()

inherits , b2Contact
inherits 
end

public  sub 		initialize(s1 as variant, s2 as variant)
 as variant ''funcion
		' //  The constructor for b2Contact
		' //  initialize instance variables for references
		 me.m_node1 = new b2ContactNode()
		 me.m_node2 = new b2ContactNode()
		' // 
		 me.m_flags = 0
		if (!s1 || !s2)
			 me.m_shape1 = null
			 me.m_shape2 = null
			return
 '' TODO: posible funcion (revisar)

		 me.m_shape1 = s1
		 me.m_shape2 = s2
		 me.m_manifoldCount = 0
		 me.m_friction = Math.sqrt( me.m_shape1.m_friction * me.m_shape2.m_friction)
		 me.m_restitution = b2Math.b2Max( me.m_shape1.m_restitution, me.m_shape2.m_restitution)
		 me.m_prev = null
		 me.m_next = null
		 me.m_node1.contact = null
		 me.m_node1.prev = null
		 me.m_node1.next = null
		 me.m_node1.other = null
		 me.m_node2.contact = null
		 me.m_node2.prev = null
		 me.m_node2.next = null
		 me.m_node2.other = null
		' // 
		' //  initialize instance variables for references
		 me.m_manifold = [new b2Manifold()]
		' // 
		' // super(shape1, shape2)
		b2Settings.b2Assert( me.m_shape1.m_type == b2Shape.e_polyShape)
		b2Settings.b2Assert( me.m_shape2.m_type == b2Shape.e_circleShape)
		 me.m_manifold[0].pointCount = 0
		 me.m_manifold[0].points[0].normalImpulse = 0.0
		 me.m_manifold[0].points[0].tangentImpulse = 0.0
	' // ~b2PolyAndCircleContact() 
end

public  sub 	Evaluate()

		b2Collision.b2CollidePolyAndCircle( me.m_manifold[0], me.m_shape1, me.m_shape2, false)
		if ( me.m_manifold[0].pointCount > 0)
			 me.m_manifoldCount = 1
		else
			 me.m_manifoldCount = 0
end

public  sub 	GetManifolds() as variant ''funcion
		return me.m_manifold
 '' TODO: posible funcion (revisar)

	m_manifold: [new b2Manifold()])
end

public  sub Create (shape1 as variant, shape2 as variant, allocator as variant) as variant ''funcion
		return new b2PolyAndCircleContact(shape1, shape2)
 '' TODO: posible funcion (revisar)

end

public  sub Destroy (contact as variant, allocator as variant)

		' // 
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2ContactRegister  as variant = Class.create()

b2ContactRegister.prototype = 
	createFcn: null
	destroyFcn: null
	primary: null
end

public  sub 	initialize()
 
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2ContactSolver  as variant = Class.create()

b2ContactSolver.prototype = 
end

public  sub 	initialize(contacts as variant, contactCount as variant, allocator as variant)

		' //  initialize instance variables for references
		 me.m_constraints = new Array()
		' // 
		 me.m_allocator = allocator
dim 		 i  as variant = 0

dim 		tVec
 as variant
dim 		tMat
 as variant
		 me.m_constraintCount = 0
		for (i = 0; i < contactCount; ++i)
			 me.m_constraintCount += contacts[i].GetManifoldCount()
		' //  fill array
		for (i = 0; i < me.m_constraintCount; i++)
			 me.m_constraints[i] = new b2ContactConstraint()
dim 		 count  as variant = 0

		for (i = 0; i < contactCount; ++i)
dim 			 contact  as variant = contacts[i]

dim 			 b1  as variant = contact.m_shape1.m_body

dim 			 b2  as variant = contact.m_shape2.m_body

dim 			 manifoldCount  as variant = contact.GetManifoldCount()

dim 			 manifolds  as variant = contact.GetManifolds()

dim 			 friction  as variant = contact.m_friction

dim 			 restitution  as variant = contact.m_restitution

			' // var v1 = b1.m_linearVelocity.Copy()
dim 			 v1X  as variant = b1.m_linearVelocity.x

dim 			 v1Y  as variant = b1.m_linearVelocity.y

			' // var v2 = b2.m_linearVelocity.Copy()
dim 			 v2X  as variant = b2.m_linearVelocity.x

dim 			 v2Y  as variant = b2.m_linearVelocity.y

dim 			 w1  as variant = b1.m_angularVelocity

dim 			 w2  as variant = b2.m_angularVelocity

			for (var j = 0; j < manifoldCount; ++j)
			
dim 				 manifold  as variant = manifolds[ j ]

				' // b2Settings.b2Assert(manifold.pointCount > 0)
				' // var normal = manifold.normal.Copy()
dim 				 normalX  as variant = manifold.normal.x

dim 				 normalY  as variant = manifold.normal.y

				' // b2Settings.b2Assert(count < me.m_constraintCount)
dim 				 c  as variant = me.m_constraints[ count ]

				c.body1 = b1
				c.body2 = b2
				c.manifold = manifold
				' // c.normal = normal
				c.normal.x = normalX
				c.normal.y = normalY
				c.pointCount = manifold.pointCount
				c.friction = friction
				c.restitution = restitution
				for (var k = 0; k < c.pointCount; ++k)
				
dim 					 cp  as variant = manifold.points[ k ]

dim 					 ccp  as variant = c.points[ k ]

					ccp.normalImpulse = cp.normalImpulse
					ccp.tangentImpulse = cp.tangentImpulse
					ccp.separation = cp.separation
					' // var r1 = b2Math.SubtractVV( cp.position, b1.m_position )
dim 					 r1X  as variant = cp.position.x - b1.m_position.x

dim 					 r1Y  as variant = cp.position.y - b1.m_position.y

					' // var r2 = b2Math.SubtractVV( cp.position, b2.m_position )
dim 					 r2X  as variant = cp.position.x - b2.m_position.x

dim 					 r2Y  as variant = cp.position.y - b2.m_position.y

					' // ccp.localAnchor1 = b2Math.b2MulTMV(b1.m_R, r1)
					tVec = ccp.localAnchor1
					tMat = b1.m_R
					tVec.x = r1X * tMat.col1.x + r1Y * tMat.col1.y
					tVec.y = r1X * tMat.col2.x + r1Y * tMat.col2.y
					' // ccp.localAnchor2 = b2Math.b2MulTMV(b2.m_R, r2)
					tVec = ccp.localAnchor2
					tMat = b2.m_R
					tVec.x = r2X * tMat.col1.x + r2Y * tMat.col1.y
					tVec.y = r2X * tMat.col2.x + r2Y * tMat.col2.y
dim 					 r1Sqr  as variant = r1X * r1X + r1Y * r1Y

dim 					 r2Sqr  as variant = r2X * r2X + r2Y * r2Y

					' // var rn1 = b2Math.b2Dot(r1, normal)
dim 					 rn1  as variant = r1X*normalX + r1Y*normalY

					' // var rn2 = b2Math.b2Dot(r2, normal)
dim 					 rn2  as variant = r2X*normalX + r2Y*normalY

dim 					 kNormal  as variant = b1.m_invMass + b2.m_invMass

					kNormal += b1.m_invI * (r1Sqr - rn1 * rn1) + b2.m_invI * (r2Sqr - rn2 * rn2)
					' // b2Settings.b2Assert(kNormal > Number.MIN_VALUE)
					ccp.normalMass = 1.0 / kNormal
					' // var tangent = b2Math.b2CrossVF(normal, 1.0)
dim 					 tangentX  as variant = normalY
dim 					 tangentY  as variant = -normalX

					' // var rt1 = b2Math.b2Dot(r1, tangent)
dim 					 rt1  as variant = r1X*tangentX + r1Y*tangentY

					' // var rt2 = b2Math.b2Dot(r2, tangent)
dim 					 rt2  as variant = r2X*tangentX + r2Y*tangentY

dim 					 kTangent  as variant = b1.m_invMass + b2.m_invMass

					kTangent += b1.m_invI * (r1Sqr - rt1 * rt1) + b2.m_invI * (r2Sqr - rt2 * rt2)
					' // b2Settings.b2Assert(kTangent > Number.MIN_VALUE)
					ccp.tangentMass = 1.0 /  kTangent
					' //  Setup a velocity bias for restitution.
					ccp.velocityBias = 0.0
					if (ccp.separation > 0.0)
					
						ccp.velocityBias = -60.0 * ccp.separation
					
					' // var vRel = b2Math.b2Dot(c.normal, b2Math.SubtractVV( b2Math.SubtractVV( b2Math.AddVV( v2, b2Math.b2CrossFV(w2, r2)), v1 ), b2Math.b2CrossFV(w1, r1)))
dim 					 tX  as variant = v2X + (-w2*r2Y) - v1X - (-w1*r1Y)

dim 					 tY  as variant = v2Y + (w2*r2X) - v1Y - (w1*r1X)

					' // var vRel = b2Dot(c.normal, tX/Y)
dim 					 vRel  as variant = c.normal.x*tX + c.normal.y*tY

					if (vRel < -b2Settings.b2_velocityThreshold)
					
						ccp.velocityBias += -c.restitution * vRel
					
				
				++count
			
		' // b2Settings.b2Assert(count == me.m_constraintCount)
	' // ~b2ContactSolver()
end

public  sub 	PreSolve()

dim 		tVec
 as variant
dim 		tVec2
 as variant
dim 		tMat
 as variant
		' //  Warm start.
		for (var i = 0; i < me.m_constraintCount; ++i)
dim 			 c  as variant = me.m_constraints[ i ]

dim 			 b1  as variant = c.body1

dim 			 b2  as variant = c.body2

dim 			 invMass1  as variant = b1.m_invMass

dim 			 invI1  as variant = b1.m_invI

dim 			 invMass2  as variant = b2.m_invMass

dim 			 invI2  as variant = b2.m_invI

			' // var normal = new b2Vec2(c.normal.x, c.normal.y)
dim 			 normalX  as variant = c.normal.x

dim 			 normalY  as variant = c.normal.y

			' // var tangent = b2Math.b2CrossVF(normal, 1.0)
dim 			 tangentX  as variant = normalY

dim 			 tangentY  as variant = -normalX

dim 			 j  as variant = 0

dim 			 tCount  as variant = 0

			if (b2World.s_enableWarmStarting)
			
				tCount = c.pointCount
				for (j = 0; j < tCount; ++j)
				
dim 					 ccp  as variant = c.points[ j ]

					' // var P = b2Math.AddVV( b2Math.MulFV(ccp.normalImpulse, normal), b2Math.MulFV(ccp.tangentImpulse, tangent))
dim 					 PX  as variant = ccp.normalImpulse*normalX + ccp.tangentImpulse*tangentX

dim 					 PY  as variant = ccp.normalImpulse*normalY + ccp.tangentImpulse*tangentY

					' // var r1 = b2Math.b2MulMV(b1.m_R, ccp.localAnchor1)
					tMat = b1.m_R
					tVec = ccp.localAnchor1
dim 					 r1X  as variant = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y

dim 					 r1Y  as variant = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y

					' // var r2 = b2Math.b2MulMV(b2.m_R, ccp.localAnchor2)
					tMat = b2.m_R
					tVec = ccp.localAnchor2
dim 					 r2X  as variant = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y

dim 					 r2Y  as variant = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y

					' // b1.m_angularVelocity -= invI1 * b2Math.b2CrossVV(r1, P)
					b1.m_angularVelocity -= invI1 * (r1X * PY - r1Y * PX)
					' // b1.m_linearVelocity.Subtract( b2Math.MulFV(invMass1, P) )
					b1.m_linearVelocity.x -= invMass1 * PX
					b1.m_linearVelocity.y -= invMass1 * PY
					' // b2.m_angularVelocity += invI2 * b2Math.b2CrossVV(r2, P)
					b2.m_angularVelocity += invI2 * (r2X * PY - r2Y * PX)
					' // b2.m_linearVelocity.Add( b2Math.MulFV(invMass2, P) )
					b2.m_linearVelocity.x += invMass2 * PX
					b2.m_linearVelocity.y += invMass2 * PY
					ccp.positionImpulse = 0.0
				
			
			else
				tCount = c.pointCount
				for (j = 0; j < tCount; ++j)
				
dim 					 ccp2  as variant = c.points[ j ]

					ccp2.normalImpulse = 0.0
					ccp2.tangentImpulse = 0.0
					ccp2.positionImpulse = 0.0
				
			
end

public  sub 	SolveVelocityConstraints()

dim 		 j  as variant = 0

dim 		ccp
 as variant
dim 		r1X
 as variant
dim 		r1Y
 as variant
dim 		r2X
 as variant
dim 		r2Y
 as variant
dim 		dvX
 as variant
dim 		dvY
 as variant
dim 		lambda
 as variant
dim 		newImpulse
 as variant
dim 		PX
 as variant
dim 		PY
 as variant
dim 		tMat
 as variant
dim 		tVec
 as variant
		for (var i = 0; i < me.m_constraintCount; ++i)
dim 			 c  as variant = me.m_constraints[ i ]

dim 			 b1  as variant = c.body1

dim 			 b2  as variant = c.body2

dim 			 b1_angularVelocity  as variant = b1.m_angularVelocity

dim 			 b1_linearVelocity  as variant = b1.m_linearVelocity

dim 			 b2_angularVelocity  as variant = b2.m_angularVelocity

dim 			 b2_linearVelocity  as variant = b2.m_linearVelocity

dim 			 invMass1  as variant = b1.m_invMass

dim 			 invI1  as variant = b1.m_invI

dim 			 invMass2  as variant = b2.m_invMass

dim 			 invI2  as variant = b2.m_invI

			' // var normal = new b2Vec2(c.normal.x, c.normal.y)
dim 			 normalX  as variant = c.normal.x

dim 			 normalY  as variant = c.normal.y

			' // var tangent = b2Math.b2CrossVF(normal, 1.0)
dim 			 tangentX  as variant = normalY

dim 			 tangentY  as variant = -normalX

			' //  Solver normal constraints
dim 			 tCount  as variant = c.pointCount

			for (j = 0; j < tCount; ++j)
			
				ccp = c.points[ j ]
				' // r1 = b2Math.b2MulMV(b1.m_R, ccp.localAnchor1)
				tMat = b1.m_R
				tVec = ccp.localAnchor1
				r1X = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y
				r1Y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y
				' // r2 = b2Math.b2MulMV(b2.m_R, ccp.localAnchor2)
				tMat = b2.m_R
				tVec = ccp.localAnchor2
				r2X = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y
				r2Y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y
				' //  Relative velocity at contact
				' // var dv = b2Math.SubtractVV( b2Math.AddVV( b2.m_linearVelocity, b2Math.b2CrossFV(b2.m_angularVelocity, r2)), b2Math.SubtractVV(b1.m_linearVelocity, b2Math.b2CrossFV(b1.m_angularVelocity, r1)))
				' // dv = b2Math.SubtractVV(b2Math.SubtractVV( b2Math.AddVV( b2.m_linearVelocity, b2Math.b2CrossFV(b2.m_angularVelocity, r2)), b1.m_linearVelocity), b2Math.b2CrossFV(b1.m_angularVelocity, r1))
				dvX = b2_linearVelocity.x + (-b2_angularVelocity * r2Y) - b1_linearVelocity.x - (-b1_angularVelocity * r1Y)
				dvY = b2_linearVelocity.y + (b2_angularVelocity * r2X) - b1_linearVelocity.y - (b1_angularVelocity * r1X)
				' //  Compute normal impulse
				' // var vn = b2Math.b2Dot(dv, normal)
dim 				 vn  as variant = dvX * normalX + dvY * normalY

				lambda = -ccp.normalMass * (vn - ccp.velocityBias)
				' //  b2Clamp the accumulated impulse
				newImpulse = b2Math.b2Max(ccp.normalImpulse + lambda, 0.0)
				lambda = newImpulse - ccp.normalImpulse
				' //  Apply contact impulse
				' // P = b2Math.MulFV(lambda, normal)
				PX = lambda * normalX
				PY = lambda * normalY
				' // b1.m_linearVelocity.Subtract( b2Math.MulFV( invMass1, P ) )
				b1_linearVelocity.x -= invMass1 * PX
				b1_linearVelocity.y -= invMass1 * PY
				b1_angularVelocity -= invI1 * (r1X * PY - r1Y * PX)
				' // b2.m_linearVelocity.Add( b2Math.MulFV( invMass2, P ) )
				b2_linearVelocity.x += invMass2 * PX
				b2_linearVelocity.y += invMass2 * PY
				b2_angularVelocity += invI2 * (r2X * PY - r2Y * PX)
				ccp.normalImpulse = newImpulse
				' //  MOVED FROM BELOW
				' //  Relative velocity at contact
				' // var dv = b2.m_linearVelocity + b2Cross(b2.m_angularVelocity, r2) - b1.m_linearVelocity - b2Cross(b1.m_angularVelocity, r1)
				' // dv =  b2Math.SubtractVV(b2Math.SubtractVV(b2Math.AddVV(b2.m_linearVelocity, b2Math.b2CrossFV(b2.m_angularVelocity, r2)), b1.m_linearVelocity), b2Math.b2CrossFV(b1.m_angularVelocity, r1))
				dvX = b2_linearVelocity.x + (-b2_angularVelocity * r2Y) - b1_linearVelocity.x - (-b1_angularVelocity * r1Y)
				dvY = b2_linearVelocity.y + (b2_angularVelocity * r2X) - b1_linearVelocity.y - (b1_angularVelocity * r1X)
				' //  Compute tangent impulse
dim 				 vt  as variant = dvX*tangentX + dvY*tangentY

				lambda = ccp.tangentMass * (-vt)
				' //  b2Clamp the accumulated impulse
dim 				 maxFriction  as variant = c.friction * ccp.normalImpulse

				newImpulse = b2Math.b2Clamp(ccp.tangentImpulse + lambda, -maxFriction, maxFriction)
				lambda = newImpulse - ccp.tangentImpulse
				' //  Apply contact impulse
				' // P = b2Math.MulFV(lambda, tangent)
				PX = lambda * tangentX
				PY = lambda * tangentY
				' // b1.m_linearVelocity.Subtract( b2Math.MulFV( invMass1, P ) )
				b1_linearVelocity.x -= invMass1 * PX
				b1_linearVelocity.y -= invMass1 * PY
				b1_angularVelocity -= invI1 * (r1X * PY - r1Y * PX)
				' // b2.m_linearVelocity.Add( b2Math.MulFV( invMass2, P ) )
				b2_linearVelocity.x += invMass2 * PX
				b2_linearVelocity.y += invMass2 * PY
				b2_angularVelocity += invI2 * (r2X * PY - r2Y * PX)
				ccp.tangentImpulse = newImpulse
			
			' //  Solver tangent constraints
			' //  MOVED ABOVE FOR EFFICIENCY
			' /* for (j = 0; j < tCount; ++j)
			
				ccp = c.points[ j ]
				' // r1 = b2Math.b2MulMV(b1.m_R, ccp.localAnchor1)
				tMat = b1.m_R
				tVec = ccp.localAnchor1
				r1X = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y
				r1Y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y
				' // r2 = b2Math.b2MulMV(b2.m_R, ccp.localAnchor2)
				tMat = b2.m_R
				tVec = ccp.localAnchor2
				r2X = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y
				r2Y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y
				' //  Relative velocity at contact
				' // var dv = b2.m_linearVelocity + b2Cross(b2.m_angularVelocity, r2) - b1.m_linearVelocity - b2Cross(b1.m_angularVelocity, r1)
				' // dv =  b2Math.SubtractVV(b2Math.SubtractVV(b2Math.AddVV(b2.m_linearVelocity, b2Math.b2CrossFV(b2.m_angularVelocity, r2)), b1.m_linearVelocity), b2Math.b2CrossFV(b1.m_angularVelocity, r1))
				dvX = b2_linearVelocity.x + (-b2_angularVelocity * r2Y) - b1_linearVelocity.x - (-b1_angularVelocity * r1Y)
				dvY = b2_linearVelocity.y + (b2_angularVelocity * r2X) - b1_linearVelocity.y - (b1_angularVelocity * r1X)
				' //  Compute tangent impulse
dim 				 vt  as variant = dvX*tangentX + dvY*tangentY

				lambda = ccp.tangentMass * (-vt)
				' //  b2Clamp the accumulated impulse
dim 				 maxFriction  as variant = c.friction * ccp.normalImpulse

				newImpulse = b2Math.b2Clamp(ccp.tangentImpulse + lambda, -maxFriction, maxFriction)
				lambda = newImpulse - ccp.tangentImpulse
				' //  Apply contact impulse
				' // P = b2Math.MulFV(lambda, tangent)
				PX = lambda * tangentX
				PY = lambda * tangentY
				' // b1.m_linearVelocity.Subtract( b2Math.MulFV( invMass1, P ) )
				b1_linearVelocity.x -= invMass1 * PX
				b1_linearVelocity.y -= invMass1 * PY
				b1_angularVelocity -= invI1 * (r1X * PY - r1Y * PX)
				' // b2.m_linearVelocity.Add( b2Math.MulFV( invMass2, P ) )
				b2_linearVelocity.x += invMass2 * PX
				b2_linearVelocity.y += invMass2 * PY
				b2_angularVelocity += invI2 * (r2X * PY - r2Y * PX)
				ccp.tangentImpulse = newImpulse
			*/
			' //  Update angular velocity
			b1.m_angularVelocity = b1_angularVelocity
			b2.m_angularVelocity = b2_angularVelocity
end

public  sub 	SolvePositionConstraints(beta as variant) as variant ''funcion
dim 		 minSeparation  as variant = 0.0

dim 		tMat
 as variant
dim 		tVec
 as variant
		for (var i = 0; i < me.m_constraintCount; ++i)
dim 			 c  as variant = me.m_constraints[ i ]

dim 			 b1  as variant = c.body1

dim 			 b2  as variant = c.body2

dim 			 b1_position  as variant = b1.m_position

dim 			 b1_rotation  as variant = b1.m_rotation

dim 			 b2_position  as variant = b2.m_position

dim 			 b2_rotation  as variant = b2.m_rotation

dim 			 invMass1  as variant = b1.m_invMass

dim 			 invI1  as variant = b1.m_invI

dim 			 invMass2  as variant = b2.m_invMass

dim 			 invI2  as variant = b2.m_invI

			' // var normal = new b2Vec2(c.normal.x, c.normal.y)
dim 			 normalX  as variant = c.normal.x

dim 			 normalY  as variant = c.normal.y

			' // var tangent = b2Math.b2CrossVF(normal, 1.0)
dim 			 tangentX  as variant = normalY

dim 			 tangentY  as variant = -normalX

			' //  Solver normal constraints
dim 			 tCount  as variant = c.pointCount

			for (var j = 0; j < tCount; ++j)
			
dim 				 ccp  as variant = c.points[ j ]

				' // r1 = b2Math.b2MulMV(b1.m_R, ccp.localAnchor1)
				tMat = b1.m_R
				tVec = ccp.localAnchor1
dim 				 r1X  as variant = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y
dim 				 r1Y  as variant = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y
				' // r2 = b2Math.b2MulMV(b2.m_R, ccp.localAnchor2)
				tMat = b2.m_R
				tVec = ccp.localAnchor2
dim 				 r2X  as variant = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y
dim 				 r2Y  as variant = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y
				' // var p1 = b2Math.AddVV(b1.m_position, r1)
dim 				 p1X  as variant = b1_position.x + r1X

dim 				 p1Y  as variant = b1_position.y + r1Y

				' // var p2 = b2Math.AddVV(b2.m_position, r2)
dim 				 p2X  as variant = b2_position.x + r2X

dim 				 p2Y  as variant = b2_position.y + r2Y

				' // var dp = b2Math.SubtractVV(p2, p1)
dim 				 dpX  as variant = p2X - p1X

dim 				 dpY  as variant = p2Y - p1Y

				' //  Approximate the current separation.
				' // var separation = b2Math.b2Dot(dp, normal) + ccp.separation
dim 				 separation  as variant = (dpX*normalX + dpY*normalY) + ccp.separation

				' //  Track max constraint error.
				minSeparation = b2Math.b2Min(minSeparation, separation)
				' //  Prevent large corrections and allow slop.
dim 				 C  as variant = beta * b2Math.b2Clamp(separation + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0.0)

				' //  Compute normal impulse
dim 				 dImpulse  as variant = -ccp.normalMass * C

				' //  b2Clamp the accumulated impulse
dim 				 impulse0  as variant = ccp.positionImpulse

				ccp.positionImpulse = b2Math.b2Max(impulse0 + dImpulse, 0.0)
				dImpulse = ccp.positionImpulse - impulse0
				' // var impulse = b2Math.MulFV( dImpulse, normal )
dim 				 impulseX  as variant = dImpulse * normalX

dim 				 impulseY  as variant = dImpulse * normalY

				' // b1.m_position.Subtract( b2Math.MulFV( invMass1, impulse ) )
				b1_position.x -= invMass1 * impulseX
				b1_position.y -= invMass1 * impulseY
				b1_rotation -= invI1 * (r1X * impulseY - r1Y * impulseX)
				b1.m_R.Set(b1_rotation)
				' // b2.m_position.Add( b2Math.MulFV( invMass2, impulse ) )
				b2_position.x += invMass2 * impulseX
				b2_position.y += invMass2 * impulseY
				b2_rotation += invI2 * (r2X * impulseY - r2Y * impulseX)
				b2.m_R.Set(b2_rotation)
			
			' //  Update body rotations
			b1.m_rotation = b1_rotation
			b2.m_rotation = b2_rotation
		return minSeparation >= -b2Settings.b2_linearSlop
 '' TODO: posible funcion (revisar)

end

public  sub 	PostSolve()

		for (var i = 0; i < me.m_constraintCount; ++i)
dim 			 c  as variant = me.m_constraints[ i ]

dim 			 m  as variant = c.manifold

			for (var j = 0; j < c.pointCount; ++j)
			
dim 				 mPoint  as variant = m.points[j]

dim 				 cPoint  as variant = c.points[j]

				mPoint.normalImpulse = cPoint.normalImpulse
				mPoint.tangentImpulse = cPoint.tangentImpulse
			
	m_allocator: null
Public s: new Array(), as new rray(),
	m_constraintCount: 0
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2Conservative  as variant = Class.create()

b2Conservative.prototype = 
	' //  Temp vars
end

public  sub 	initialize()
 
b2Conservative.R1 = new b2Mat22()
b2Conservative.R2 = new b2Mat22()
b2Conservative.x1 = new b2Vec2()
b2Conservative.x2 = new b2Vec2()
end

public  sub Conservative (shape1 as variant, shape2 as variant) as variant ''funcio as variant ''funcion
dim 		 body1  as variant = shape1.GetBody()

dim 		 body2  as variant = shape2.GetBody()

		' // b2Vec2 v1 = body1->m_position - body1->m_position0
dim 		 v1X  as variant = body1.m_position.x - body1.m_position0.x

dim 		 v1Y  as variant = body1.m_position.y - body1.m_position0.y

		' // float32 omega1 = body1->m_rotation - body1->m_rotation0
dim 		 omega1  as variant = body1.m_rotation - body1.m_rotation0

		' // b2Vec2 v2 = body2->m_position - body2->m_position0
dim 		 v2X  as variant = body2.m_position.x - body2.m_position0.x

dim 		 v2Y  as variant = body2.m_position.y - body2.m_position0.y

		' // float32 omega2 = body2->m_rotation - body2->m_rotation0
dim 		 omega2  as variant = body2.m_rotation - body2.m_rotation0

		' // float32 r1 = shape1->GetMaxRadius()
dim 		 r1  as variant = shape1.GetMaxRadius()

		' // float32 r2 = shape2->GetMaxRadius()
dim 		 r2  as variant = shape2.GetMaxRadius()

		' // b2Vec2 p1Start = body1->m_position0
dim 		 p1StartX  as variant = body1.m_position0.x

dim 		 p1StartY  as variant = body1.m_position0.y

		' // float32 a1Start = body1->m_rotation0
dim 		 a1Start  as variant = body1.m_rotation0

		' // b2Vec2 p2Start = body2->m_position0
dim 		 p2StartX  as variant = body2.m_position0.x

dim 		 p2StartY  as variant = body2.m_position0.y

		' // float32 a2Start = body2->m_rotation0
dim 		 a2Start  as variant = body2.m_rotation0

		' // b2Vec2 p1 = p1Start
dim 		 p1X  as variant = p1StartX

dim 		 p1Y  as variant = p1StartY

		' // float32 a1 = a1Start
dim 		 a1  as variant = a1Start

		' // b2Vec2 p2 = p2Start
dim 		 p2X  as variant = p2StartX

dim 		 p2Y  as variant = p2StartY

		' // float32 a2 = a2Start
dim 		 a2  as variant = a2Start

		' // b2Mat22 b2Conservative.R1(a1), b2Conservative.R2(a2)
		b2Conservative.R1.Set(a1)
		b2Conservative.R2.Set(a2)
		' // shape1->QuickSync(p1, b2Conservative.R1)
		shape1.QuickSync(p1, b2Conservative.R1)
		' // shape2->QuickSync(p2, b2Conservative.R2)
		shape2.QuickSync(p2, b2Conservative.R2)
		' // float32 s1 = 0.0f
dim 		 s1  as variant = 0.0

		' // const int32 maxIterations = 10
dim 		 maxIterations  as variant = 10

		' // b2Vec2 d
dim 		dX
 as variant
dim 		dY
 as variant
		' // float32 invRelativeVelocity = 0.0f
dim 		 invRelativeVelocity  as variant = 0.0

		' // bool hit = true
dim 		 hit  as variant = true

		' // b2Vec2 b2Conservative.x1, b2Conservative.x2
 moved to static var
		for (var iter = 0; iter < maxIterations; ++iter)
			' //  Get the accurate distance between shapes.
			' // float32 distance = b2Distance.Distance(&b2Conservative.x1, &b2Conservative.x2, shape1, shape2)
dim 			 distance  as variant = b2Distance.Distance(b2Conservative.x1, b2Conservative.x2, shape1, shape2)

			if (distance < b2Settings.b2_linearSlop)
			
				if (iter == 0)
				
					hit = false
				
				else
				
					hit = true
				
				break
			
			if (iter == 0)
			
				' // b2Vec2 d = b2Conservative.x2 - b2Conservative.x1
				dX = b2Conservative.x2.x - b2Conservative.x1.x
				dY = b2Conservative.x2.y - b2Conservative.x1.y
				' // d.Normalize()
dim 				 dLen  as variant = Math.sqrt(dX*dX + dY*dY)

				' // float32 relativeVelocity = b2Dot(d, v1 - v2) + b2Abs(omega1) * r1 + b2Abs(omega2) * r2
dim 				 relativeVelocity  as variant = (dX*(v1X-v2X) + dY*(v1Y - v2Y)) + Math.abs(omega1) * r1 + Math.abs(omega2) * r2

				if (Math.abs(relativeVelocity) < Number.MIN_VALUE)
				
					hit = false
					break
				
				invRelativeVelocity = 1.0 / relativeVelocity
			
			' //  Get the conservative movement.
			' // float32 ds = distance * invRelativeVelocity
dim 			 ds  as variant = distance * invRelativeVelocity

			' // float32 s2 = s1 + ds
dim 			 s2  as variant = s1 + ds

			if (s2 < 0.0 || 1.0 < s2)
			
				hit = false
				break
			
			if (s2 < (1.0 + 100.0 * Number.MIN_VALUE) * s1)
			
				hit = true
				break
			
			s1 = s2
			' //  Move forward conservatively.
			' // p1 = p1Start + s1 * v1
			p1X = p1StartX + s1 * v1.x
			p1Y = p1StartY + s1 * v1.y
			' // a1 = a1Start + s1 * omega1
			a1 = a1Start + s1 * omega1
			' // p2 = p2Start + s1 * v2
			p2X = p2StartX + s1 * v2.x
			p2Y = p2StartY + s1 * v2.y
			' // a2 = a2Start + s1 * omega2
			a2 = a2Start + s1 * omega2
			b2Conservative.R1.Set(a1)
			b2Conservative.R2.Set(a2)
			shape1.QuickSync(p1, b2Conservative.R1)
			shape2.QuickSync(p2, b2Conservative.R2)
		if (hit)
			' //  Hit, move bodies to safe position and re-sync shapes.
			' // b2Vec2 d = b2Conservative.x2 - b2Conservative.x1
			dX = b2Conservative.x2.x - b2Conservative.x1.x
			dY = b2Conservative.x2.y - b2Conservative.x1.y
			' // float32 length = d.Length()
dim 			 length  as variant = Math.sqrt(dX*dX + dY*dY)

			if (length > FLT_EPSILON)
			
				d *= b2_linearSlop / length
			
			if (body1.IsStatic())
			
				' // body1.m_position = p1
				body1.m_position.x = p1X
				body1.m_position.y = p1Y
			
			else
			
				' // body1.m_position = p1 - d
				body1.m_position.x = p1X - dX
				body1.m_position.y = p1Y - dY
			
			body1.m_rotation = a1
			body1.m_R.Set(a1)
			body1.QuickSyncShapes()
			if (body2.IsStatic())
			
				' // body2->m_position = p2
				body2.m_position.x = p2X
				body2.m_position.y = p2Y
			
			else
			
				' // body2->m_position = p2 + d
				body2.m_position.x = p2X + dX
				body2.m_position.y = p2Y + dY
			
			' // body2.m_position = p2 + d
			body2.m_position.x = p2X + dX
			body2.m_position.y = p2Y + dY
			body2.m_rotation = a2
			body2.m_R.Set(a2)
			body2.QuickSyncShapes()
			return true
 '' TODO: posible funcion (revisar)

		' //  No hit, restore shapes.
		shape1.QuickSync(body1.m_position, body1.m_R)
		shape2.QuickSync(body2.m_position, body2.m_R)
		return false
 '' TODO: posible funcion (revisar)

﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2NullContact  as variant = Class.create()

inherits , b2Contact
inherits 
end

public  sub 		initialize(s1 as variant, s2 as variant)
 as variant ''funcion
		' //  The constructor for b2Contact
		' //  initialize instance variables for references
		 me.m_node1 = new b2ContactNode()
		 me.m_node2 = new b2ContactNode()
		' // 
		 me.m_flags = 0
		if (!s1 || !s2)
			 me.m_shape1 = null
			 me.m_shape2 = null
			return
 '' TODO: posible funcion (revisar)

		 me.m_shape1 = s1
		 me.m_shape2 = s2
		 me.m_manifoldCount = 0
		 me.m_friction = Math.sqrt( me.m_shape1.m_friction * me.m_shape2.m_friction)
		 me.m_restitution = b2Math.b2Max( me.m_shape1.m_restitution, me.m_shape2.m_restitution)
		 me.m_prev = null
		 me.m_next = null
		 me.m_node1.contact = null
		 me.m_node1.prev = null
		 me.m_node1.next = null
		 me.m_node1.other = null
		 me.m_node2.contact = null
		 me.m_node2.prev = null
		 me.m_node2.next = null
		 me.m_node2.other = null
		' // 
end

public  sub 	Evaluate()
 
end

public  sub 	GetManifolds()
 return null
 )
 '' TODO: posible funcion (revisar)

﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' // typedef b2Contact* b2ContactCreateFcn(b2Shape* shape1, b2Shape* shape2, b2BlockAllocator* allocator)
' // typedef void b2ContactDestroyFcn(b2Contact* contact, b2BlockAllocator* allocator)
dim  b2Contact  as variant = Class.create()

b2Contact.prototype = 
end

public  sub 	GetManifolds()
return null '' TODO: posible funcion (revisar)

end

public  sub 	GetManifoldCount() as variant ''funcion
		return me.m_manifoldCount
 '' TODO: posible funcion (revisar)

end

public  sub 	GetNext() as variant ''funcion
		return me.m_next
 '' TODO: posible funcion (revisar)

end

public  sub 	GetShape1() as variant ''funcion
		return me.m_shape1
 '' TODO: posible funcion (revisar)

end

public  sub 	GetShape2() as variant ''funcion
		return me.m_shape2
 '' TODO: posible funcion (revisar)

	' // --------------- Internals Below -------------------
	' //  me.m_flags
	' //  enum
end

public  sub 	initialize(s1 as variant, s2 as variant) as variant ''funcion
		' //  initialize instance variables for references
		 me.m_node1 = new b2ContactNode()
		 me.m_node2 = new b2ContactNode()
		' // 
		 me.m_flags = 0
		if (!s1 || !s2)
			 me.m_shape1 = null
			 me.m_shape2 = null
			return
 '' TODO: posible funcion (revisar)

		 me.m_shape1 = s1
		 me.m_shape2 = s2
		 me.m_manifoldCount = 0
		 me.m_friction = Math.sqrt( me.m_shape1.m_friction * me.m_shape2.m_friction)
		 me.m_restitution = b2Math.b2Max( me.m_shape1.m_restitution, me.m_shape2.m_restitution)
		 me.m_prev = null
		 me.m_next = null
		 me.m_node1.contact = null
		 me.m_node1.prev = null
		 me.m_node1.next = null
		 me.m_node1.other = null
		 me.m_node2.contact = null
		 me.m_node2.prev = null
		 me.m_node2.next = null
		 me.m_node2.other = null
	' // virtual ~b2Contact() 
end

public  sub 	Evaluate()

	m_flags: 0
	' //  World pool and list pointers.
	m_prev: null
	m_next: null
	' //  Nodes for connecting bodies.
Public 1: new b2ContactNode(), as new 2ContactNode(),
Public 2: new b2ContactNode(), as new 2ContactNode(),
	m_shape1: null
	m_shape2: null
	m_manifoldCount: 0
	' //  Combined friction
	m_friction: null
	m_restitution: null
b2Contact.e_islandFlag = 0x0001
b2Contact.e_destroyFlag = 0x0002
end

public  sub AddType (createFcn as variant, destroyFcn as variant, type1 as variant, type2 as variant)

		' // b2Settings.b2Assert(b2Shape.e_unknownShape < type1 && type1 < b2Shape.e_shapeTypeCount)
		' // b2Settings.b2Assert(b2Shape.e_unknownShape < type2 && type2 < b2Shape.e_shapeTypeCount)
		b2Contact.s_registers[type1][type2].createFcn = createFcn
		b2Contact.s_registers[type1][type2].destroyFcn = destroyFcn
		b2Contact.s_registers[type1][type2].primary = true
		if (type1 != type2)
			b2Contact.s_registers[type2][type1].createFcn = createFcn
			b2Contact.s_registers[type2][type1].destroyFcn = destroyFcn
			b2Contact.s_registers[type2][type1].primary = false
end

public  sub InitializeRegisters ()

		b2Contact.s_registers = new Array(b2Shape.e_shapeTypeCount)
		for (var i = 0; i < b2Shape.e_shapeTypeCount; i++)
			b2Contact.s_registers[i] = new Array(b2Shape.e_shapeTypeCount)
			for (var j = 0; j < b2Shape.e_shapeTypeCount; j++)
				b2Contact.s_registers[i][j] = new b2ContactRegister()
			
		b2Contact.AddType(b2CircleContact.Create, b2CircleContact.Destroy, b2Shape.e_circleShape, b2Shape.e_circleShape)
		b2Contact.AddType(b2PolyAndCircleContact.Create, b2PolyAndCircleContact.Destroy, b2Shape.e_polyShape, b2Shape.e_circleShape)
		b2Contact.AddType(b2PolyContact.Create, b2PolyContact.Destroy, b2Shape.e_polyShape, b2Shape.e_polyShape)
end

public  sub Create (shape1 as variant, shape2 as variant, allocator as variant) as variant ''funcio as variant ''funcio as variant ''funcion
		if (b2Contact.s_initialized == false)
			b2Contact.InitializeRegisters()
			b2Contact.s_initialized = true
dim 		 type1  as variant = shape1.m_type

dim 		 type2  as variant = shape2.m_type

		' // b2Settings.b2Assert(b2Shape.e_unknownShape < type1 && type1 < b2Shape.e_shapeTypeCount)
		' // b2Settings.b2Assert(b2Shape.e_unknownShape < type2 && type2 < b2Shape.e_shapeTypeCount)
dim 		 createFcn  as variant = b2Contact.s_registers[type1][type2].createFcn

		if (createFcn)
			if (b2Contact.s_registers[type1][type2].primary)
			
				return createFcn(shape1, shape2, allocator)
 '' TODO: posible funcion (revisar)

			
			else
			
dim 				 c  as variant = createFcn(shape2, shape1, allocator)

				for (var i = 0; i < c.GetManifoldCount(); ++i)
				
dim 					 m  as variant = c.GetManifolds()[ i ]

					m.normal = m.normal.Negative()
				
				return c
 '' TODO: posible funcion (revisar)

			
		else
			return null
 '' TODO: posible funcion (revisar)

end

public  sub Destroy (contact as variant, allocator as variant)

		' // b2Settings.b2Assert(b2Contact.s_initialized == true)
		if (contact.GetManifoldCount() > 0)
			contact.m_shape1.m_body.WakeUp()
			contact.m_shape2.m_body.WakeUp()
dim 		 type1  as variant = contact.m_shape1.m_type

dim 		 type2  as variant = contact.m_shape2.m_type

		' // b2Settings.b2Assert(b2Shape.e_unknownShape < type1 && type1 < b2Shape.e_shapeTypeCount)
		' // b2Settings.b2Assert(b2Shape.e_unknownShape < type2 && type2 < b2Shape.e_shapeTypeCount)
dim 		 destroyFcn  as variant = b2Contact.s_registers[type1][type2].destroyFcn

		destroyFcn(contact, allocator)
b2Contact.s_registers = null
b2Contact.s_initialized = false
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2PulleyJoint  as variant = Class.create()

inherits , b2Joint
inherits 
end

public  sub 	GetAnchor1() as variant ''funcio as variant ''funcion
		' // return me.m_body1->m_position + b2Mul( me.m_body1->m_R, me.m_localAnchor1)
 '' TODO: posible funcion (revisar)

dim 		 tMat  as variant = me.m_body1.m_R

		return new b2Vec2(	 me.m_body1.m_position.x + (tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y), '' TODO: posible funcion (revisar)

							 me.m_body1.m_position.y + (tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y))
end

public  sub 	GetAnchor2() as variant ''funcio as variant ''funcion
		' // return me.m_body2->m_position + b2Mul( me.m_body2->m_R, me.m_localAnchor2)
 '' TODO: posible funcion (revisar)

dim 		 tMat  as variant = me.m_body2.m_R

		return new b2Vec2(	 me.m_body2.m_position.x + (tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y), '' TODO: posible funcion (revisar)

							 me.m_body2.m_position.y + (tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y))
end

public  sub 	GetGroundPoint1() as variant ''funcio as variant ''funcion
		' // return me.m_ground->m_position + me.m_groundAnchor1
 '' TODO: posible funcion (revisar)

		return new b2Vec2( me.m_ground.m_position.x + me.m_groundAnchor1.x, me.m_ground.m_position.y + me.m_groundAnchor1.y)
 '' TODO: posible funcion (revisar)

end

public  sub 	GetGroundPoint2() as variant ''funcion
		return new b2Vec2( me.m_ground.m_position.x + me.m_groundAnchor2.x, me.m_ground.m_position.y + me.m_groundAnchor2.y)
 '' TODO: posible funcion (revisar)

end

public  sub 	GetReactionForce(invTimeStep as variant) as variant ''funcion
		' // b2Vec2 F(0.0f, 0.0f)
		return new b2Vec2()
 '' TODO: posible funcion (revisar)

end

public  sub 	GetReactionTorque(invTimeStep as variant) as variant ''funcion
		return 0.0
 '' TODO: posible funcion (revisar)

end

public  sub 	GetLength1() as variant ''funcion
dim 		tMat
 as variant
		' // b2Vec2 p = me.m_body1->m_position + b2Mul( me.m_body1->m_R, me.m_localAnchor1)
		tMat = me.m_body1.m_R
dim 		 pX  as variant = me.m_body1.m_position.x + (tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y)

dim 		 pY  as variant = me.m_body1.m_position.y + (tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y)

		' // b2Vec2 s = me.m_ground->m_position + me.m_groundAnchor1
		' // b2Vec2 d = p - s
dim 		 dX  as variant = pX - ( me.m_ground.m_position.x + me.m_groundAnchor1.x)

dim 		 dY  as variant = pY - ( me.m_ground.m_position.y + me.m_groundAnchor1.y)

		return Math.sqrt(dX*dX + dY*dY)
 '' TODO: posible funcion (revisar)

end

public  sub 	GetLength2() as variant ''funcion
dim 		tMat
 as variant
		' // b2Vec2 p = me.m_body2->m_position + b2Mul( me.m_body2->m_R, me.m_localAnchor2)
		tMat = me.m_body2.m_R
dim 		 pX  as variant = me.m_body2.m_position.x + (tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y)

dim 		 pY  as variant = me.m_body2.m_position.y + (tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y)

		' // b2Vec2 s = me.m_ground->m_position + me.m_groundAnchor2
		' // b2Vec2 d = p - s
dim 		 dX  as variant = pX - ( me.m_ground.m_position.x + me.m_groundAnchor2.x)

dim 		 dY  as variant = pY - ( me.m_ground.m_position.y + me.m_groundAnchor2.y)

		return Math.sqrt(dX*dX + dY*dY)
 '' TODO: posible funcion (revisar)

end

public  sub 	GetRatio() as variant ''funcion
		return me.m_ratio
 '' TODO: posible funcion (revisar)

	' // --------------- Internals Below -------------------
end

public  sub 	initialize(def as variant)

		' //  The constructor for b2Joint
		' //  initialize instance variables for references
		 me.m_node1 = new b2JointNode()
		 me.m_node2 = new b2JointNode()
		' // 
		 me.m_type = def.type
		 me.m_prev = null
		 me.m_next = null
		 me.m_body1 = def.body1
		 me.m_body2 = def.body2
		 me.m_collideConnected = def.collideConnected
		 me.m_islandFlag = false
		 me.m_userData = def.userData
		' // 
		' //  initialize instance variables for references
		 me.m_groundAnchor1 = new b2Vec2()
		 me.m_groundAnchor2 = new b2Vec2()
		 me.m_localAnchor1 = new b2Vec2()
		 me.m_localAnchor2 = new b2Vec2()
		 me.m_u1 = new b2Vec2()
		 me.m_u2 = new b2Vec2()
		' // 
		' //  parent
		' // super(def)
dim 		tMat
 as variant
dim 		tX
 as variant
dim 		tY
 as variant
		 me.m_ground = me.m_body1.m_world.m_groundBody
		' // me.m_groundAnchor1 = def.groundPoint1 - me.m_ground.m_position
		 me.m_groundAnchor1.x = def.groundPoint1.x - me.m_ground.m_position.x
		 me.m_groundAnchor1.y = def.groundPoint1.y - me.m_ground.m_position.y
		' // me.m_groundAnchor2 = def.groundPoint2 - me.m_ground.m_position
		 me.m_groundAnchor2.x = def.groundPoint2.x - me.m_ground.m_position.x
		 me.m_groundAnchor2.y = def.groundPoint2.y - me.m_ground.m_position.y
		' // me.m_localAnchor1 = b2MulT( me.m_body1.m_R, def.anchorPoint1 - me.m_body1.m_position)
		tMat = me.m_body1.m_R
		tX = def.anchorPoint1.x - me.m_body1.m_position.x
		tY = def.anchorPoint1.y - me.m_body1.m_position.y
		 me.m_localAnchor1.x = tX*tMat.col1.x + tY*tMat.col1.y
		 me.m_localAnchor1.y = tX*tMat.col2.x + tY*tMat.col2.y
		' // me.m_localAnchor2 = b2MulT( me.m_body2.m_R, def.anchorPoint2 - me.m_body2.m_position)
		tMat = me.m_body2.m_R
		tX = def.anchorPoint2.x - me.m_body2.m_position.x
		tY = def.anchorPoint2.y - me.m_body2.m_position.y
		 me.m_localAnchor2.x = tX*tMat.col1.x + tY*tMat.col1.y
		 me.m_localAnchor2.y = tX*tMat.col2.x + tY*tMat.col2.y
		 me.m_ratio = def.ratio
		' // var d1 = def.groundPoint1 - def.anchorPoint1
		tX = def.groundPoint1.x - def.anchorPoint1.x
		tY = def.groundPoint1.y - def.anchorPoint1.y
dim 		 d1Len  as variant = Math.sqrt(tX*tX + tY*tY)

		' // var d2 = def.groundPoint2 - def.anchorPoint2
		tX = def.groundPoint2.x - def.anchorPoint2.x
		tY = def.groundPoint2.y - def.anchorPoint2.y
dim 		 d2Len  as variant = Math.sqrt(tX*tX + tY*tY)

dim 		 length1  as variant = b2Math.b2Max(0.5 * b2PulleyJoint.b2_minPulleyLength, d1Len)

dim 		 length2  as variant = b2Math.b2Max(0.5 * b2PulleyJoint.b2_minPulleyLength, d2Len)

		 me.m_constant = length1 + me.m_ratio * length2
		 me.m_maxLength1 = b2Math.b2Clamp(def.maxLength1, length1, me.m_constant - me.m_ratio * b2PulleyJoint.b2_minPulleyLength)
		 me.m_maxLength2 = b2Math.b2Clamp(def.maxLength2, length2, ( me.m_constant - b2PulleyJoint.b2_minPulleyLength) / me.m_ratio)
		 me.m_pulleyImpulse = 0.0
		 me.m_limitImpulse1 = 0.0
		 me.m_limitImpulse2 = 0.0
end

public  sub 	PrepareVelocitySolver()

dim 		 b1  as variant = me.m_body1

dim 		 b2  as variant = me.m_body2

dim 		tMat
 as variant
		' // b2Vec2 r1 = b2Mul(b1->m_R, me.m_localAnchor1)
		tMat = b1.m_R
dim 		 r1X  as variant = tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y

dim 		 r1Y  as variant = tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y

		' // b2Vec2 r2 = b2Mul(b2->m_R, me.m_localAnchor2)
		tMat = b2.m_R
dim 		 r2X  as variant = tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y

dim 		 r2Y  as variant = tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y

		' // b2Vec2 p1 = b1->m_position + r1
dim 		 p1X  as variant = b1.m_position.x + r1X

dim 		 p1Y  as variant = b1.m_position.y + r1Y

		' // b2Vec2 p2 = b2->m_position + r2
dim 		 p2X  as variant = b2.m_position.x + r2X

dim 		 p2Y  as variant = b2.m_position.y + r2Y

		' // b2Vec2 s1 = me.m_ground->m_position + me.m_groundAnchor1
dim 		 s1X  as variant = me.m_ground.m_position.x + me.m_groundAnchor1.x

dim 		 s1Y  as variant = me.m_ground.m_position.y + me.m_groundAnchor1.y

		' // b2Vec2 s2 = me.m_ground->m_position + me.m_groundAnchor2
dim 		 s2X  as variant = me.m_ground.m_position.x + me.m_groundAnchor2.x

dim 		 s2Y  as variant = me.m_ground.m_position.y + me.m_groundAnchor2.y

		' //  Get the pulley axes.
		' // me.m_u1 = p1 - s1
		 me.m_u1.Set(p1X - s1X, p1Y - s1Y)
		' // me.m_u2 = p2 - s2
		 me.m_u2.Set(p2X - s2X, p2Y - s2Y)
dim 		 length1  as variant = me.m_u1.Length()

dim 		 length2  as variant = me.m_u2.Length()

		if (length1 > b2Settings.b2_linearSlop)
			' // me.m_u1 *= 1.0f / length1
			 me.m_u1.Multiply(1.0 / length1)
		else
			 me.m_u1.SetZero()
		if (length2 > b2Settings.b2_linearSlop)
			' // me.m_u2 *= 1.0f / length2
			 me.m_u2.Multiply(1.0 / length2)
		else
			 me.m_u2.SetZero()
		if (length1 < me.m_maxLength1)
			 me.m_limitState1 = b2Joint.e_inactiveLimit
			 me.m_limitImpulse1 = 0.0
		else
			 me.m_limitState1 = b2Joint.e_atUpperLimit
			 me.m_limitPositionImpulse1 = 0.0
		if (length2 < me.m_maxLength2)
			 me.m_limitState2 = b2Joint.e_inactiveLimit
			 me.m_limitImpulse2 = 0.0
		else
			 me.m_limitState2 = b2Joint.e_atUpperLimit
			 me.m_limitPositionImpulse2 = 0.0
		' //  Compute effective mass.
		' // var cr1u1 = b2Cross(r1, me.m_u1)
dim 		 cr1u1  as variant = r1X * me.m_u1.y - r1Y * me.m_u1.x

		' // var cr2u2 = b2Cross(r2, me.m_u2)
dim 		 cr2u2  as variant = r2X * me.m_u2.y - r2Y * me.m_u2.x

		 me.m_limitMass1 = b1.m_invMass + b1.m_invI * cr1u1 * cr1u1
		 me.m_limitMass2 = b2.m_invMass + b2.m_invI * cr2u2 * cr2u2
		 me.m_pulleyMass = me.m_limitMass1 + me.m_ratio * me.m_ratio * me.m_limitMass2
		' // b2Settings.b2Assert( me.m_limitMass1 > Number.MIN_VALUE)
		' // b2Settings.b2Assert( me.m_limitMass2 > Number.MIN_VALUE)
		' // b2Settings.b2Assert( me.m_pulleyMass > Number.MIN_VALUE)
		 me.m_limitMass1 = 1.0 / me.m_limitMass1
		 me.m_limitMass2 = 1.0 / me.m_limitMass2
		 me.m_pulleyMass = 1.0 / me.m_pulleyMass
		' //  Warm starting.
		' // b2Vec2 P1 = (- me.m_pulleyImpulse - me.m_limitImpulse1) * me.m_u1
dim 		 P1X  as variant = (- me.m_pulleyImpulse - me.m_limitImpulse1) * me.m_u1.x

dim 		 P1Y  as variant = (- me.m_pulleyImpulse - me.m_limitImpulse1) * me.m_u1.y

		' // b2Vec2 P2 = (- me.m_ratio * me.m_pulleyImpulse - me.m_limitImpulse2) * me.m_u2
dim 		 P2X  as variant = (- me.m_ratio * me.m_pulleyImpulse - me.m_limitImpulse2) * me.m_u2.x

dim 		 P2Y  as variant = (- me.m_ratio * me.m_pulleyImpulse - me.m_limitImpulse2) * me.m_u2.y

		' // b1.m_linearVelocity += b1.m_invMass * P1
		b1.m_linearVelocity.x += b1.m_invMass * P1X
		b1.m_linearVelocity.y += b1.m_invMass * P1Y
		' // b1.m_angularVelocity += b1.m_invI * b2Cross(r1, P1)
		b1.m_angularVelocity += b1.m_invI * (r1X * P1Y - r1Y * P1X)
		' // b2.m_linearVelocity += b2.m_invMass * P2
		b2.m_linearVelocity.x += b2.m_invMass * P2X
		b2.m_linearVelocity.y += b2.m_invMass * P2Y
		' // b2.m_angularVelocity += b2.m_invI * b2Cross(r2, P2)
		b2.m_angularVelocity += b2.m_invI * (r2X * P2Y - r2Y * P2X)
end

public  sub 	SolveVelocityConstraints(step as variant)

dim 		 b1  as variant = me.m_body1

dim 		 b2  as variant = me.m_body2

dim 		tMat
 as variant
		' // var r1 = b2Mul(b1.m_R, me.m_localAnchor1)
		tMat = b1.m_R
dim 		 r1X  as variant = tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y

dim 		 r1Y  as variant = tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y

		' // var r2 = b2Mul(b2.m_R, me.m_localAnchor2)
		tMat = b2.m_R
dim 		 r2X  as variant = tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y

dim 		 r2Y  as variant = tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y

		' //  temp vars
dim 		v1X
 as variant
dim 		v1Y
 as variant
dim 		v2X
 as variant
dim 		v2Y
 as variant
dim 		P1X
 as variant
dim 		P1Y
 as variant
dim 		P2X
 as variant
dim 		P2Y
 as variant
dim 		Cdot
 as variant
dim 		impulse
 as variant
dim 		oldLimitImpulse
 as variant
		' // 
			' // b2Vec2 v1 = b1->m_linearVelocity + b2Cross(b1->m_angularVelocity, r1)
			v1X = b1.m_linearVelocity.x + (-b1.m_angularVelocity * r1Y)
			v1Y = b1.m_linearVelocity.y + (b1.m_angularVelocity * r1X)
			' // b2Vec2 v2 = b2->m_linearVelocity + b2Cross(b2->m_angularVelocity, r2)
			v2X = b2.m_linearVelocity.x + (-b2.m_angularVelocity * r2Y)
			v2Y = b2.m_linearVelocity.y + (b2.m_angularVelocity * r2X)
			' // Cdot = -b2Dot( me.m_u1, v1) - me.m_ratio * b2Dot( me.m_u2, v2)
			Cdot = -( me.m_u1.x * v1X + me.m_u1.y * v1Y) - me.m_ratio * ( me.m_u2.x * v2X + me.m_u2.y * v2Y)
			impulse = - me.m_pulleyMass * Cdot
			 me.m_pulleyImpulse += impulse
			' // b2Vec2 P1 = -impulse * me.m_u1
			P1X = -impulse * me.m_u1.x
			P1Y = -impulse * me.m_u1.y
			' // b2Vec2 P2 = - me.m_ratio * impulse * me.m_u2
			P2X = - me.m_ratio * impulse * me.m_u2.x
			P2Y = - me.m_ratio * impulse * me.m_u2.y
			' // b1.m_linearVelocity += b1.m_invMass * P1
			b1.m_linearVelocity.x += b1.m_invMass * P1X
			b1.m_linearVelocity.y += b1.m_invMass * P1Y
			' // b1.m_angularVelocity += b1.m_invI * b2Cross(r1, P1)
			b1.m_angularVelocity += b1.m_invI * (r1X * P1Y - r1Y * P1X)
			' // b2.m_linearVelocity += b2.m_invMass * P2
			b2.m_linearVelocity.x += b2.m_invMass * P2X
			b2.m_linearVelocity.y += b2.m_invMass * P2Y
			' // b2.m_angularVelocity += b2.m_invI * b2Cross(r2, P2)
			b2.m_angularVelocity += b2.m_invI * (r2X * P2Y - r2Y * P2X)
		' // 
		if ( me.m_limitState1 == b2Joint.e_atUpperLimit)
			' // b2Vec2 v1 = b1->m_linearVelocity + b2Cross(b1->m_angularVelocity, r1)
			v1X = b1.m_linearVelocity.x + (-b1.m_angularVelocity * r1Y)
			v1Y = b1.m_linearVelocity.y + (b1.m_angularVelocity * r1X)
			' // float32 Cdot = -b2Dot( me.m_u1, v1)
			Cdot = -( me.m_u1.x * v1X + me.m_u1.y * v1Y)
			impulse = - me.m_limitMass1 * Cdot
			oldLimitImpulse = me.m_limitImpulse1
			 me.m_limitImpulse1 = b2Math.b2Max(0.0, me.m_limitImpulse1 + impulse)
			impulse = me.m_limitImpulse1 - oldLimitImpulse
			' // b2Vec2 P1 = -impulse * me.m_u1
			P1X = -impulse * me.m_u1.x
			P1Y = -impulse * me.m_u1.y
			' // b1.m_linearVelocity += b1->m_invMass * P1
			b1.m_linearVelocity.x += b1.m_invMass * P1X
			b1.m_linearVelocity.y += b1.m_invMass * P1Y
			' // b1.m_angularVelocity += b1->m_invI * b2Cross(r1, P1)
			b1.m_angularVelocity += b1.m_invI * (r1X * P1Y - r1Y * P1X)
		if ( me.m_limitState2 == b2Joint.e_atUpperLimit)
			' // b2Vec2 v2 = b2->m_linearVelocity + b2Cross(b2->m_angularVelocity, r2)
			v2X = b2.m_linearVelocity.x + (-b2.m_angularVelocity * r2Y)
			v2Y = b2.m_linearVelocity.y + (b2.m_angularVelocity * r2X)
			' // float32 Cdot = -b2Dot( me.m_u2, v2)
			Cdot = -( me.m_u2.x * v2X + me.m_u2.y * v2Y)
			impulse = - me.m_limitMass2 * Cdot
			oldLimitImpulse = me.m_limitImpulse2
			 me.m_limitImpulse2 = b2Math.b2Max(0.0, me.m_limitImpulse2 + impulse)
			impulse = me.m_limitImpulse2 - oldLimitImpulse
			' // b2Vec2 P2 = -impulse * me.m_u2
			P2X = -impulse * me.m_u2.x
			P2Y = -impulse * me.m_u2.y
			' // b2->m_linearVelocity += b2->m_invMass * P2
			b2.m_linearVelocity.x += b2.m_invMass * P2X
			b2.m_linearVelocity.y += b2.m_invMass * P2Y
			' // b2->m_angularVelocity += b2->m_invI * b2Cross(r2, P2)
			b2.m_angularVelocity += b2.m_invI * (r2X * P2Y - r2Y * P2X)
end

public  sub 	SolvePositionConstraints() as variant ''funcion
dim 		 b1  as variant = me.m_body1

dim 		 b2  as variant = me.m_body2

dim 		tMat
 as variant
		' // b2Vec2 s1 = me.m_ground->m_position + me.m_groundAnchor1
dim 		 s1X  as variant = me.m_ground.m_position.x + me.m_groundAnchor1.x

dim 		 s1Y  as variant = me.m_ground.m_position.y + me.m_groundAnchor1.y

		' // b2Vec2 s2 = me.m_ground->m_position + me.m_groundAnchor2
dim 		 s2X  as variant = me.m_ground.m_position.x + me.m_groundAnchor2.x

dim 		 s2Y  as variant = me.m_ground.m_position.y + me.m_groundAnchor2.y

		' //  temp vars
dim 		r1X
 as variant
dim 		r1Y
 as variant
dim 		r2X
 as variant
dim 		r2Y
 as variant
dim 		p1X
 as variant
dim 		p1Y
 as variant
dim 		p2X
 as variant
dim 		p2Y
 as variant
dim 		length1
 as variant
dim 		length2
 as variant
dim 		C
 as variant
dim 		impulse
 as variant
dim 		oldLimitPositionImpulse
 as variant
dim 		 linearError  as variant = 0.0

			' // var r1 = b2Mul(b1.m_R, me.m_localAnchor1)
			tMat = b1.m_R
			r1X = tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y
			r1Y = tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y
			' // var r2 = b2Mul(b2.m_R, me.m_localAnchor2)
			tMat = b2.m_R
			r2X = tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y
			r2Y = tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y
			' // b2Vec2 p1 = b1->m_position + r1
			p1X = b1.m_position.x + r1X
			p1Y = b1.m_position.y + r1Y
			' // b2Vec2 p2 = b2->m_position + r2
			p2X = b2.m_position.x + r2X
			p2Y = b2.m_position.y + r2Y
			' //  Get the pulley axes.
			' // me.m_u1 = p1 - s1
			 me.m_u1.Set(p1X - s1X, p1Y - s1Y)
			' // me.m_u2 = p2 - s2
			 me.m_u2.Set(p2X - s2X, p2Y - s2Y)
			length1 = me.m_u1.Length()
			length2 = me.m_u2.Length()
			if (length1 > b2Settings.b2_linearSlop)
			
				' // me.m_u1 *= 1.0f / length1
				 me.m_u1.Multiply( 1.0 / length1 )
			
			else
			
				 me.m_u1.SetZero()
			
			if (length2 > b2Settings.b2_linearSlop)
			
				' // me.m_u2 *= 1.0f / length2
				 me.m_u2.Multiply( 1.0 / length2 )
			
			else
			
				 me.m_u2.SetZero()
			
			C = me.m_constant - length1 - me.m_ratio * length2
			linearError = b2Math.b2Max(linearError, Math.abs(C))
			C = b2Math.b2Clamp(C, -b2Settings.b2_maxLinearCorrection, b2Settings.b2_maxLinearCorrection)
			impulse = - me.m_pulleyMass * C
			p1X = -impulse * me.m_u1.x
			p1Y = -impulse * me.m_u1.y
			p2X = - me.m_ratio * impulse * me.m_u2.x
			p2Y = - me.m_ratio * impulse * me.m_u2.y
			b1.m_position.x += b1.m_invMass * p1X
			b1.m_position.y += b1.m_invMass * p1Y
			b1.m_rotation += b1.m_invI * (r1X * p1Y - r1Y * p1X)
			b2.m_position.x += b2.m_invMass * p2X
			b2.m_position.y += b2.m_invMass * p2Y
			b2.m_rotation += b2.m_invI * (r2X * p2Y - r2Y * p2X)
			b1.m_R.Set(b1.m_rotation)
			b2.m_R.Set(b2.m_rotation)
		if ( me.m_limitState1 == b2Joint.e_atUpperLimit)
			' // b2Vec2 r1 = b2Mul(b1->m_R, me.m_localAnchor1)
			tMat = b1.m_R
			r1X = tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y
			r1Y = tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y
			' // b2Vec2 p1 = b1->m_position + r1
			p1X = b1.m_position.x + r1X
			p1Y = b1.m_position.y + r1Y
			' // me.m_u1 = p1 - s1
			 me.m_u1.Set(p1X - s1X, p1Y - s1Y)
			length1 = me.m_u1.Length()
			if (length1 > b2Settings.b2_linearSlop)
			
				' // me.m_u1 *= 1.0 / length1
				 me.m_u1.x *= 1.0 / length1
				 me.m_u1.y *= 1.0 / length1
			
			else
			
				 me.m_u1.SetZero()
			
			C = me.m_maxLength1 - length1
			linearError = b2Math.b2Max(linearError, -C)
			C = b2Math.b2Clamp(C + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0.0)
			impulse = - me.m_limitMass1 * C
			oldLimitPositionImpulse = me.m_limitPositionImpulse1
			 me.m_limitPositionImpulse1 = b2Math.b2Max(0.0, me.m_limitPositionImpulse1 + impulse)
			impulse = me.m_limitPositionImpulse1 - oldLimitPositionImpulse
			' // P1 = -impulse * me.m_u1
			p1X = -impulse * me.m_u1.x
			p1Y = -impulse * me.m_u1.y
			b1.m_position.x += b1.m_invMass * p1X
			b1.m_position.y += b1.m_invMass * p1Y
			' // b1.m_rotation += b1.m_invI * b2Cross(r1, P1)
			b1.m_rotation += b1.m_invI * (r1X * p1Y - r1Y * p1X)
			b1.m_R.Set(b1.m_rotation)
		if ( me.m_limitState2 == b2Joint.e_atUpperLimit)
			' // b2Vec2 r2 = b2Mul(b2->m_R, me.m_localAnchor2)
			tMat = b2.m_R
			r2X = tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y
			r2Y = tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y
			' // b2Vec2 p2 = b2->m_position + r2
			p2X = b2.m_position.x + r2X
			p2Y = b2.m_position.y + r2Y
			' // me.m_u2 = p2 - s2
			 me.m_u2.Set(p2X - s2X, p2Y - s2Y)
			length2 = me.m_u2.Length()
			if (length2 > b2Settings.b2_linearSlop)
			
				' // me.m_u2 *= 1.0 / length2
				 me.m_u2.x *= 1.0 / length2
				 me.m_u2.y *= 1.0 / length2
			
			else
			
				 me.m_u2.SetZero()
			
			C = me.m_maxLength2 - length2
			linearError = b2Math.b2Max(linearError, -C)
			C = b2Math.b2Clamp(C + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0.0)
			impulse = - me.m_limitMass2 * C
			oldLimitPositionImpulse = me.m_limitPositionImpulse2
			 me.m_limitPositionImpulse2 = b2Math.b2Max(0.0, me.m_limitPositionImpulse2 + impulse)
			impulse = me.m_limitPositionImpulse2 - oldLimitPositionImpulse
			' // P2 = -impulse * me.m_u2
			p2X = -impulse * me.m_u2.x
			p2Y = -impulse * me.m_u2.y
			' // b2.m_position += b2.m_invMass * P2
			b2.m_position.x += b2.m_invMass * p2X
			b2.m_position.y += b2.m_invMass * p2Y
			' // b2.m_rotation += b2.m_invI * b2Cross(r2, P2)
			b2.m_rotation += b2.m_invI * (r2X * p2Y - r2Y * p2X)
			b2.m_R.Set(b2.m_rotation)
		return linearError < b2Settings.b2_linearSlop
 '' TODO: posible funcion (revisar)

	m_ground: null
Public 1: new b2Vec2(), as new 2Vec2(),
Public 2: new b2Vec2(), as new 2Vec2(),
Public 1: new b2Vec2(), as new 2Vec2(),
Public 2: new b2Vec2(), as new 2Vec2(),
Public 1: new b2Vec2(), as new 2Vec2(),
Public 2: new b2Vec2(), as new 2Vec2(),
	m_constant: null
	m_ratio: null
	m_maxLength1: null
	m_maxLength2: null
	' //  Effective masses
	m_pulleyMass: null
	m_limitMass1: null
	m_limitMass2: null
	' //  Impulses for accumulation/warm starting.
	m_pulleyImpulse: null
	m_limitImpulse1: null
	m_limitImpulse2: null
	' //  Position impulses for accumulation.
	m_limitPositionImpulse1: null
	m_limitPositionImpulse2: null
	m_limitState1: 0
	m_limitState2: 0
	' //  static
)
b2PulleyJoint.b2_minPulleyLength = b2Settings.b2_lengthUnitsPerMeter
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  A gear joint is used to connect two joints together. Either joint
' //  can be a revolute or prismatic joint. You specify a gear ratio
' //  to bind the motions together:
' //  coordinate1 + ratio * coordinate2 = constant
' //  The ratio can be negative or positive. If one joint is a revolute joint
' //  and the other joint is a prismatic joint, then the ratio will have units
' //  of length or units of 1/length.
' // 
' //  RESTRICITON: The revolute and prismatic joints must be attached to
' //  a fixed body (which must be body1 on those joints).
dim  b2GearJointDef  as variant = Class.create()

inherits , b2JointDef
inherits 
end

public  sub 	initialize()

		 me.type = b2Joint.e_gearJoint
		 me.joint1 = null
		 me.joint2 = null
		 me.ratio = 1.0
	joint1: null
	joint2: null
	ratio: null)
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2Jacobian  as variant = Class.create()

b2Jacobian.prototype = 
Public 1: new b2Vec2(), as new 2Vec2(),
	angular1: null
Public 2: new b2Vec2(), as new 2Vec2(),
	angular2: null
end

public  sub 	SetZero()

		 me.linear1.SetZero()
 me.angular1 = 0.0
		 me.linear2.SetZero()
 me.angular2 = 0.0
end

public  sub 	Set(x1 as variant, a1 as variant, x2 as variant, a2 as variant)

		 me.linear1.SetV(x1)
 me.angular1 = a1
		 me.linear2.SetV(x2)
 me.angular2 = a2
end

public  sub 	Compute(x1 as variant, a1 as variant, x2 as variant, a2 as variant) as variant ''funcio as variant ''funcion
		' // return b2Math.b2Dot( me.linear1, x1) + me.angular1 * a1 + b2Math.b2Dot( me.linear2, x2) + me.angular2 * a2
 '' TODO: posible funcion (revisar)

		return ( me.linear1.x*x1.x + me.linear1.y*x1.y) + me.angular1 * a1 + ( me.linear2.x*x2.x + me.linear2.y*x2.y) + me.angular2 * a2
 '' TODO: posible funcion (revisar)

end

public  sub 	initialize()
 
		' //  initialize instance variables for references
		 me.linear1 = new b2Vec2()
		 me.linear2 = new b2Vec2()
		' // 
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  The pulley joint is connected to two bodies and two fixed ground points.
' //  The pulley supports a ratio such that:
' //  length1 + ratio * length2 = constant
' //  Yes, the force transmitted is scaled by the ratio.
' //  The pulley also enforces a maximum length limit on both sides. This is
' //  useful to prevent one side of the pulley hitting the top.
dim  b2PulleyJointDef  as variant = Class.create()

inherits , b2JointDef
inherits 
end

public  sub 	initialize()

		' //  The constructor for b2JointDef
		 me.type = b2Joint.e_unknownJoint
		 me.userData = null
		 me.body1 = null
		 me.body2 = null
		 me.collideConnected = false
		' // 
		' //  initialize instance variables for references
		 me.groundPoint1 = new b2Vec2()
		 me.groundPoint2 = new b2Vec2()
		 me.anchorPoint1 = new b2Vec2()
		 me.anchorPoint2 = new b2Vec2()
		' // 
		 me.type = b2Joint.e_pulleyJoint
		 me.groundPoint1.Set(-1.0, 1.0)
		 me.groundPoint2.Set(1.0, 1.0)
		 me.anchorPoint1.Set(-1.0, 0.0)
		 me.anchorPoint2.Set(1.0, 0.0)
		 me.maxLength1 = 0.5 * b2PulleyJoint.b2_minPulleyLength
		 me.maxLength2 = 0.5 * b2PulleyJoint.b2_minPulleyLength
		 me.ratio = 1.0
		 me.collideConnected = true
Public 1: new b2Vec2(), as new 2Vec2(),
Public 2: new b2Vec2(), as new 2Vec2(),
Public 1: new b2Vec2(), as new 2Vec2(),
Public 2: new b2Vec2(), as new 2Vec2(),
	maxLength1: null
	maxLength2: null
	ratio: null)
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2DistanceJointDef  as variant = Class.create()

inherits , b2JointDef
inherits 
end

public  sub 	initialize()

		' //  The constructor for b2JointDef
		 me.type = b2Joint.e_unknownJoint
		 me.userData = null
		 me.body1 = null
		 me.body2 = null
		 me.collideConnected = false
		' // 
		' //  initialize instance variables for references
		 me.anchorPoint1 = new b2Vec2()
		 me.anchorPoint2 = new b2Vec2()
		' // 
		 me.type = b2Joint.e_distanceJoint
		' // me.anchorPoint1.Set(0.0, 0.0)
		' // me.anchorPoint2.Set(0.0, 0.0)
Public 1: new b2Vec2(), as new 2Vec2(),
Public 2: new b2Vec2())
 as new 2Vec2())

﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2GearJoint  as variant = Class.create()

inherits , b2Joint
inherits 
end

public  sub 	GetAnchor1() as variant ''funcio as variant ''funcion
		' // return me.m_body1.m_position + b2MulMV( me.m_body1.m_R, me.m_localAnchor1)
 '' TODO: posible funcion (revisar)

dim 		 tMat  as variant = me.m_body1.m_R

		return new b2Vec2(	 me.m_body1.m_position.x + (tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y), '' TODO: posible funcion (revisar)

							 me.m_body1.m_position.y + (tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y))
end

public  sub 	GetAnchor2() as variant ''funcio as variant ''funcion
		' // return me.m_body2->m_position + b2Mul( me.m_body2->m_R, me.m_localAnchor2)
 '' TODO: posible funcion (revisar)

dim 		 tMat  as variant = me.m_body2.m_R

		return new b2Vec2(	 me.m_body2.m_position.x + (tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y), '' TODO: posible funcion (revisar)

							 me.m_body2.m_position.y + (tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y))
end

public  sub 	GetReactionForce(invTimeStep as variant) as variant ''funcion
		' // b2Vec2 F(0.0f, 0.0f)
		return new b2Vec2()
 '' TODO: posible funcion (revisar)

end

public  sub 	GetReactionTorque(invTimeStep as variant) as variant ''funcion
		return 0.0
 '' TODO: posible funcion (revisar)

end

public  sub 	GetRatio() as variant ''funcion
		return me.m_ratio
 '' TODO: posible funcion (revisar)

	' // --------------- Internals Below -------------------
end

public  sub 	initialize(def as variant)

		' //  The constructor for b2Joint
		' //  initialize instance variables for references
		 me.m_node1 = new b2JointNode()
		 me.m_node2 = new b2JointNode()
		' // 
		 me.m_type = def.type
		 me.m_prev = null
		 me.m_next = null
		 me.m_body1 = def.body1
		 me.m_body2 = def.body2
		 me.m_collideConnected = def.collideConnected
		 me.m_islandFlag = false
		 me.m_userData = def.userData
		' // 
		' //  initialize instance variables for references
		 me.m_groundAnchor1 = new b2Vec2()
		 me.m_groundAnchor2 = new b2Vec2()
		 me.m_localAnchor1 = new b2Vec2()
		 me.m_localAnchor2 = new b2Vec2()
		 me.m_J = new b2Jacobian()
		' // 
		' //  parent constructor
		' // super(def)
		' // b2Settings.b2Assert(def.joint1.m_type == b2Joint.e_revoluteJoint || def.joint1.m_type == b2Joint.e_prismaticJoint)
		' // b2Settings.b2Assert(def.joint2.m_type == b2Joint.e_revoluteJoint || def.joint2.m_type == b2Joint.e_prismaticJoint)
		' // b2Settings.b2Assert(def.joint1.m_body1.IsStatic())
		' // b2Settings.b2Assert(def.joint2.m_body1.IsStatic())
		 me.m_revolute1 = null
		 me.m_prismatic1 = null
		 me.m_revolute2 = null
		 me.m_prismatic2 = null
dim 		coordinate1
 as variant
dim 		coordinate2
 as variant
		 me.m_ground1 = def.joint1.m_body1
		 me.m_body1 = def.joint1.m_body2
		if (def.joint1.m_type == b2Joint.e_revoluteJoint)
			 me.m_revolute1 = def.joint1
			 me.m_groundAnchor1.SetV( me.m_revolute1.m_localAnchor1 )
			 me.m_localAnchor1.SetV( me.m_revolute1.m_localAnchor2 )
			coordinate1 = me.m_revolute1.GetJointAngle()
		else
			 me.m_prismatic1 = def.joint1
			 me.m_groundAnchor1.SetV( me.m_prismatic1.m_localAnchor1 )
			 me.m_localAnchor1.SetV( me.m_prismatic1.m_localAnchor2 )
			coordinate1 = me.m_prismatic1.GetJointTranslation()
		 me.m_ground2 = def.joint2.m_body1
		 me.m_body2 = def.joint2.m_body2
		if (def.joint2.m_type == b2Joint.e_revoluteJoint)
			 me.m_revolute2 = def.joint2
			 me.m_groundAnchor2.SetV( me.m_revolute2.m_localAnchor1 )
			 me.m_localAnchor2.SetV( me.m_revolute2.m_localAnchor2 )
			coordinate2 = me.m_revolute2.GetJointAngle()
		else
			 me.m_prismatic2 = def.joint2
			 me.m_groundAnchor2.SetV( me.m_prismatic2.m_localAnchor1 )
			 me.m_localAnchor2.SetV( me.m_prismatic2.m_localAnchor2 )
			coordinate2 = me.m_prismatic2.GetJointTranslation()
		 me.m_ratio = def.ratio
		 me.m_constant = coordinate1 + me.m_ratio * coordinate2
		 me.m_impulse = 0.0
end

public  sub 	PrepareVelocitySolver()

dim 		 g1  as variant = me.m_ground1

dim 		 g2  as variant = me.m_ground2

dim 		 b1  as variant = me.m_body1

dim 		 b2  as variant = me.m_body2

		' //  temp vars
dim 		ugX
 as variant
dim 		ugY
 as variant
dim 		rX
 as variant
dim 		rY
 as variant
dim 		tMat
 as variant
dim 		tVec
 as variant
dim 		crug
 as variant
dim 		 K  as variant = 0.0

		 me.m_J.SetZero()
		if ( me.m_revolute1)
			 me.m_J.angular1 = -1.0
			K += b1.m_invI
		else
			' // b2Vec2 ug = b2MulMV(g1->m_R, me.m_prismatic1->m_localXAxis1)
			tMat = g1.m_R
			tVec = me.m_prismatic1.m_localXAxis1
			ugX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y
			ugY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y
			' // b2Vec2 r = b2MulMV(b1->m_R, me.m_localAnchor1)
			tMat = b1.m_R
			rX = tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y
			rY = tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y
			' // var crug = b2Cross(r, ug)
			crug = rX * ugY - rY * ugX
			' // me.m_J.linear1 = -ug
			 me.m_J.linear1.Set(-ugX, -ugY)
			 me.m_J.angular1 = -crug
			K += b1.m_invMass + b1.m_invI * crug * crug
		if ( me.m_revolute2)
			 me.m_J.angular2 = - me.m_ratio
			K += me.m_ratio * me.m_ratio * b2.m_invI
		else
			' // b2Vec2 ug = b2Mul(g2->m_R, me.m_prismatic2->m_localXAxis1)
			tMat = g2.m_R
			tVec = me.m_prismatic2.m_localXAxis1
			ugX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y
			ugY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y
			' // b2Vec2 r = b2Mul(b2->m_R, me.m_localAnchor2)
			tMat = b2.m_R
			rX = tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y
			rY = tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y
			' // float32 crug = b2Cross(r, ug)
			crug = rX * ugY - rY * ugX
			' // me.m_J.linear2 = - me.m_ratio * ug
			 me.m_J.linear2.Set(- me.m_ratio*ugX, - me.m_ratio*ugY)
			 me.m_J.angular2 = - me.m_ratio * crug
			K += me.m_ratio * me.m_ratio * (b2.m_invMass + b2.m_invI * crug * crug)
		' //  Compute effective mass.
		' // b2Settings.b2Assert(K > 0.0)
		 me.m_mass = 1.0 / K
		' //  Warm starting.
		' // b1.m_linearVelocity += b1.m_invMass * me.m_impulse * me.m_J.linear1
		b1.m_linearVelocity.x += b1.m_invMass * me.m_impulse * me.m_J.linear1.x
		b1.m_linearVelocity.y += b1.m_invMass * me.m_impulse * me.m_J.linear1.y
		b1.m_angularVelocity += b1.m_invI * me.m_impulse * me.m_J.angular1
		' // b2.m_linearVelocity += b2.m_invMass * me.m_impulse * me.m_J.linear2
		b2.m_linearVelocity.x += b2.m_invMass * me.m_impulse * me.m_J.linear2.x
		b2.m_linearVelocity.y += b2.m_invMass * me.m_impulse * me.m_J.linear2.y
		b2.m_angularVelocity += b2.m_invI * me.m_impulse * me.m_J.angular2
end

public  sub 	SolveVelocityConstraints(step as variant)

dim 		 b1  as variant = me.m_body1

dim 		 b2  as variant = me.m_body2

dim 		 Cdot  as variant = me.m_J.Compute(	b1.m_linearVelocity, b1.m_angularVelocity,
										b2.m_linearVelocity, b2.m_angularVelocity)
dim 		 impulse  as variant = - me.m_mass * Cdot

		 me.m_impulse += impulse
		b1.m_linearVelocity.x += b1.m_invMass * impulse * me.m_J.linear1.x
		b1.m_linearVelocity.y += b1.m_invMass * impulse * me.m_J.linear1.y
		b1.m_angularVelocity  += b1.m_invI * impulse * me.m_J.angular1
		b2.m_linearVelocity.x += b2.m_invMass * impulse * me.m_J.linear2.x
		b2.m_linearVelocity.y += b2.m_invMass * impulse * me.m_J.linear2.y
		b2.m_angularVelocity  += b2.m_invI * impulse * me.m_J.angular2
end

public  sub 	SolvePositionConstraints() as variant ''funcion
dim 		 linearError  as variant = 0.0

dim 		 b1  as variant = me.m_body1

dim 		 b2  as variant = me.m_body2

dim 		coordinate1
 as variant
dim 		coordinate2
 as variant
		if ( me.m_revolute1)
			coordinate1 = me.m_revolute1.GetJointAngle()
		else
			coordinate1 = me.m_prismatic1.GetJointTranslation()
		if ( me.m_revolute2)
			coordinate2 = me.m_revolute2.GetJointAngle()
		else
			coordinate2 = me.m_prismatic2.GetJointTranslation()
dim 		 C  as variant = me.m_constant - (coordinate1 + me.m_ratio * coordinate2)

dim 		 impulse  as variant = - me.m_mass * C

		b1.m_position.x += b1.m_invMass * impulse * me.m_J.linear1.x
		b1.m_position.y += b1.m_invMass * impulse * me.m_J.linear1.y
		b1.m_rotation += b1.m_invI * impulse * me.m_J.angular1
		b2.m_position.x += b2.m_invMass * impulse * me.m_J.linear2.x
		b2.m_position.y += b2.m_invMass * impulse * me.m_J.linear2.y
		b2.m_rotation += b2.m_invI * impulse * me.m_J.angular2
		b1.m_R.Set(b1.m_rotation)
		b2.m_R.Set(b2.m_rotation)
		return linearError < b2Settings.b2_linearSlop
 '' TODO: posible funcion (revisar)

	m_ground1: null
	m_ground2: null
	' //  One of these is NULL.
	m_revolute1: null
	m_prismatic1: null
	' //  One of these is NULL.
	m_revolute2: null
	m_prismatic2: null
Public 1: new b2Vec2(), as new 2Vec2(),
Public 2: new b2Vec2(), as new 2Vec2(),
Public 1: new b2Vec2(), as new 2Vec2(),
Public 2: new b2Vec2(), as new 2Vec2(),
Public J: new b2Jacobian(), as new 2Jacobian(),
	m_constant: null
	m_ratio: null
	' //  Effective mass
	m_mass: null
	' //  Impulse for accumulation/warm starting.
	m_impulse: null)
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  Point-to-point constraint
' //  C = p2 - p1
' //  Cdot = v2 - v1
' //       = v2 + cross(w2, r2) - v1 - cross(w1, r1)
' //  J = [-I -r1_skew I r2_skew ]
' //  Identity used:
' //  w k % (rx i + ry j) = w * (-ry i + rx j)
' //  Motor constraint
' //  Cdot = w2 - w1
' //  J = [0 0 -1 0 0 1]
' //  K = invI1 + invI2
dim  b2RevoluteJoint  as variant = Class.create()

inherits , b2Joint
inherits 
end

public  sub 	GetAnchor1() as variant ''funcion
dim 		 tMat  as variant = me.m_body1.m_R

		return new b2Vec2(	 me.m_body1.m_position.x + (tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y), '' TODO: posible funcion (revisar)

							 me.m_body1.m_position.y + (tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y))
end

public  sub 	GetAnchor2() as variant ''funcion
dim 		 tMat  as variant = me.m_body2.m_R

		return new b2Vec2(	 me.m_body2.m_position.x + (tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y), '' TODO: posible funcion (revisar)

							 me.m_body2.m_position.y + (tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y))
end

public  sub 	GetJointAngle() as variant ''funcion
		return me.m_body2.m_rotation - me.m_body1.m_rotation
 '' TODO: posible funcion (revisar)

end

public  sub 	GetJointSpeed() as variant ''funcion
		return me.m_body2.m_angularVelocity - me.m_body1.m_angularVelocity
 '' TODO: posible funcion (revisar)

end

public  sub 	GetMotorTorque(invTimeStep as variant) as variant ''funcion
		return  invTimeStep * me.m_motorImpulse
 '' TODO: posible funcion (revisar)

end

public  sub 	SetMotorSpeed(speed as variant)

		 me.m_motorSpeed = speed
end

public  sub 	SetMotorTorque(torque as variant)

		 me.m_maxMotorTorque = torque
end

public  sub 	GetReactionForce(invTimeStep as variant) as variant ''funcio as variant ''funcion
dim 		 tVec  as variant = me.m_ptpImpulse.Copy()

		tVec.Multiply(invTimeStep)
		' // return invTimeStep * me.m_ptpImpulse
 '' TODO: posible funcion (revisar)

		return tVec
 '' TODO: posible funcion (revisar)

end

public  sub 	GetReactionTorque(invTimeStep as variant) as variant ''funcion
		return invTimeStep * me.m_limitImpulse
 '' TODO: posible funcion (revisar)

	' // --------------- Internals Below -------------------
end

public  sub 	initialize(def as variant)

		' //  The constructor for b2Joint
		' //  initialize instance variables for references
		 me.m_node1 = new b2JointNode()
		 me.m_node2 = new b2JointNode()
		' // 
		 me.m_type = def.type
		 me.m_prev = null
		 me.m_next = null
		 me.m_body1 = def.body1
		 me.m_body2 = def.body2
		 me.m_collideConnected = def.collideConnected
		 me.m_islandFlag = false
		 me.m_userData = def.userData
		' // 
		' //  initialize instance variables for references
		 me.K = new b2Mat22()
		 me.K1 = new b2Mat22()
		 me.K2 = new b2Mat22()
		 me.K3 = new b2Mat22()
		 me.m_localAnchor1 = new b2Vec2()
		 me.m_localAnchor2 = new b2Vec2()
		 me.m_ptpImpulse = new b2Vec2()
		 me.m_ptpMass = new b2Mat22()
		' // 
		' // super(def)
dim 		tMat
 as variant
dim 		tX
 as variant
dim 		tY
 as variant
		' // me.m_localAnchor1 = b2Math.b2MulTMV( me.m_body1.m_R, b2Math.SubtractVV( def.anchorPoint, me.m_body1.m_position))
		tMat = me.m_body1.m_R
		tX = def.anchorPoint.x - me.m_body1.m_position.x
		tY = def.anchorPoint.y - me.m_body1.m_position.y
		 me.m_localAnchor1.x = tX * tMat.col1.x + tY * tMat.col1.y
		 me.m_localAnchor1.y = tX * tMat.col2.x + tY * tMat.col2.y
		' // me.m_localAnchor2 = b2Math.b2MulTMV( me.m_body2.m_R, b2Math.SubtractVV( def.anchorPoint, me.m_body2.m_position))
		tMat = me.m_body2.m_R
		tX = def.anchorPoint.x - me.m_body2.m_position.x
		tY = def.anchorPoint.y - me.m_body2.m_position.y
		 me.m_localAnchor2.x = tX * tMat.col1.x + tY * tMat.col1.y
		 me.m_localAnchor2.y = tX * tMat.col2.x + tY * tMat.col2.y
		 me.m_intialAngle = me.m_body2.m_rotation - me.m_body1.m_rotation
		 me.m_ptpImpulse.Set(0.0, 0.0)
		 me.m_motorImpulse = 0.0
		 me.m_limitImpulse = 0.0
		 me.m_limitPositionImpulse = 0.0
		 me.m_lowerAngle = def.lowerAngle
		 me.m_upperAngle = def.upperAngle
		 me.m_maxMotorTorque = def.motorTorque
		 me.m_motorSpeed = def.motorSpeed
		 me.m_enableLimit = def.enableLimit
		 me.m_enableMotor = def.enableMotor
	' //  internal vars
Public K: new b2Mat22(), as new 2Mat22(),
Public 1: new b2Mat22(), as new 2Mat22(),
Public 2: new b2Mat22(), as new 2Mat22(),
Public 3: new b2Mat22(), as new 2Mat22(),
end

public  sub 	PrepareVelocitySolver()

dim 		 b1  as variant = me.m_body1

dim 		 b2  as variant = me.m_body2

dim 		tMat
 as variant
		' //  Compute the effective mass matrix.
		' // b2Vec2 r1 = b2Mul(b1->m_R, me.m_localAnchor1)
		tMat = b1.m_R
dim 		 r1X  as variant = tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y

dim 		 r1Y  as variant = tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y

		' // b2Vec2 r2 = b2Mul(b2->m_R, me.m_localAnchor2)
		tMat = b2.m_R
dim 		 r2X  as variant = tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y

dim 		 r2Y  as variant = tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y

		' //  me.K    = [(1/m1 + 1/m2) * eye(2) - skew(r1) * invI1 * skew(r1) - skew(r2) * invI2 * skew(r2)]
		' //       = [1/m1+1/m2     0    ] + invI1 * [r1.y*r1.y -r1.x*r1.y] + invI2 * [r1.y*r1.y -r1.x*r1.y]
		' //         [    0     1/m1+1/m2]           [-r1.x*r1.y r1.x*r1.x]           [-r1.x*r1.y r1.x*r1.x]
dim 		 invMass1  as variant = b1.m_invMass

dim 		 invMass2  as variant = b2.m_invMass

dim 		 invI1  as variant = b1.m_invI

dim 		 invI2  as variant = b2.m_invI

		' // var me.K1 = new b2Mat22()
		 me.K1.col1.x = invMass1 + invMass2
	 me.K1.col2.x = 0.0
		 me.K1.col1.y = 0.0
					 me.K1.col2.y = invMass1 + invMass2
		' // var me.K2 = new b2Mat22()
		 me.K2.col1.x =  invI1 * r1Y * r1Y
	 me.K2.col2.x = -invI1 * r1X * r1Y
		 me.K2.col1.y = -invI1 * r1X * r1Y
	 me.K2.col2.y =  invI1 * r1X * r1X
		' // var me.K3 = new b2Mat22()
		 me.K3.col1.x =  invI2 * r2Y * r2Y
	 me.K3.col2.x = -invI2 * r2X * r2Y
		 me.K3.col1.y = -invI2 * r2X * r2Y
	 me.K3.col2.y =  invI2 * r2X * r2X
		' // var me.K = b2Math.AddMM(b2Math.AddMM( me.K1, me.K2), me.K3)
		 me.K.SetM( me.K1)
		 me.K.AddM( me.K2)
		 me.K.AddM( me.K3)
		' // me.m_ptpMass = me.K.Invert()
		 me.K.Invert( me.m_ptpMass)
		 me.m_motorMass = 1.0 / (invI1 + invI2)
		if ( me.m_enableMotor == false)
			 me.m_motorImpulse = 0.0
		if ( me.m_enableLimit)
dim 			 jointAngle  as variant = b2.m_rotation - b1.m_rotation - me.m_intialAngle

			if (b2Math.b2Abs( me.m_upperAngle - me.m_lowerAngle) < 2.0 * b2Settings.b2_angularSlop)
			
				 me.m_limitState = b2Joint.e_equalLimits
			
			else if (jointAngle <= me.m_lowerAngle)
			
				if ( me.m_limitState != b2Joint.e_atLowerLimit)
				
					 me.m_limitImpulse = 0.0
				
				 me.m_limitState = b2Joint.e_atLowerLimit
			
			else if (jointAngle >= me.m_upperAngle)
			
				if ( me.m_limitState != b2Joint.e_atUpperLimit)
				
					 me.m_limitImpulse = 0.0
				
				 me.m_limitState = b2Joint.e_atUpperLimit
			
			else
			
				 me.m_limitState = b2Joint.e_inactiveLimit
				 me.m_limitImpulse = 0.0
			
		else
			 me.m_limitImpulse = 0.0
		' //  Warm starting.
		if (b2World.s_enableWarmStarting)
			' // b1.m_linearVelocity.Subtract( b2Math.MulFV( invMass1, me.m_ptpImpulse) )
			b1.m_linearVelocity.x -= invMass1 * me.m_ptpImpulse.x
			b1.m_linearVelocity.y -= invMass1 * me.m_ptpImpulse.y
			' // b1.m_angularVelocity -= invI1 * (b2Math.b2CrossVV(r1, me.m_ptpImpulse) + me.m_motorImpulse + me.m_limitImpulse)
			b1.m_angularVelocity -= invI1 * ((r1X * me.m_ptpImpulse.y - r1Y * me.m_ptpImpulse.x) + me.m_motorImpulse + me.m_limitImpulse)
			' // b2.m_linearVelocity.Add( b2Math.MulFV( invMass2 , me.m_ptpImpulse ))
			b2.m_linearVelocity.x += invMass2 * me.m_ptpImpulse.x
			b2.m_linearVelocity.y += invMass2 * me.m_ptpImpulse.y
			' // b2.m_angularVelocity += invI2 * (b2Math.b2CrossVV(r2, me.m_ptpImpulse) + me.m_motorImpulse + me.m_limitImpulse)
			b2.m_angularVelocity += invI2 * ((r2X * me.m_ptpImpulse.y - r2Y * me.m_ptpImpulse.x) + me.m_motorImpulse + me.m_limitImpulse)
		else
			 me.m_ptpImpulse.SetZero()
			 me.m_motorImpulse = 0.0
			 me.m_limitImpulse = 0.0
		 me.m_limitPositionImpulse = 0.0
end

public  sub 	SolveVelocityConstraints(step as variant)

dim 		 b1  as variant = me.m_body1

dim 		 b2  as variant = me.m_body2

dim 		tMat
 as variant
		' // var r1 = b2Math.b2MulMV(b1.m_R, me.m_localAnchor1)
		tMat = b1.m_R
dim 		 r1X  as variant = tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y

dim 		 r1Y  as variant = tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y

		' // var r2 = b2Math.b2MulMV(b2.m_R, me.m_localAnchor2)
		tMat = b2.m_R
dim 		 r2X  as variant = tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y

dim 		 r2Y  as variant = tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y

dim 		oldLimitImpulse
 as variant
		' //  Solve point-to-point constraint
		' // b2Vec2 ptpCdot = b2.m_linearVelocity + b2Cross(b2.m_angularVelocity, r2) - b1.m_linearVelocity - b2Cross(b1.m_angularVelocity, r1)
dim 		 ptpCdotX  as variant = b2.m_linearVelocity.x + (-b2.m_angularVelocity * r2Y) - b1.m_linearVelocity.x - (-b1.m_angularVelocity * r1Y)

dim 		 ptpCdotY  as variant = b2.m_linearVelocity.y + (b2.m_angularVelocity * r2X) - b1.m_linearVelocity.y - (b1.m_angularVelocity * r1X)

		' // b2Vec2 ptpImpulse = -b2Mul( me.m_ptpMass, ptpCdot)
dim 		 ptpImpulseX  as variant = -( me.m_ptpMass.col1.x * ptpCdotX + me.m_ptpMass.col2.x * ptpCdotY)

dim 		 ptpImpulseY  as variant = -( me.m_ptpMass.col1.y * ptpCdotX + me.m_ptpMass.col2.y * ptpCdotY)

		 me.m_ptpImpulse.x += ptpImpulseX
		 me.m_ptpImpulse.y += ptpImpulseY
		' // b1->m_linearVelocity -= b1->m_invMass * ptpImpulse
		b1.m_linearVelocity.x -= b1.m_invMass * ptpImpulseX
		b1.m_linearVelocity.y -= b1.m_invMass * ptpImpulseY
		' // b1->m_angularVelocity -= b1->m_invI * b2Cross(r1, ptpImpulse)
		b1.m_angularVelocity -= b1.m_invI * (r1X * ptpImpulseY - r1Y * ptpImpulseX)
		' // b2->m_linearVelocity += b2->m_invMass * ptpImpulse
		b2.m_linearVelocity.x += b2.m_invMass * ptpImpulseX
		b2.m_linearVelocity.y += b2.m_invMass * ptpImpulseY
		' // b2->m_angularVelocity += b2->m_invI * b2Cross(r2, ptpImpulse)
		b2.m_angularVelocity += b2.m_invI * (r2X * ptpImpulseY - r2Y * ptpImpulseX)
		if ( me.m_enableMotor && me.m_limitState != b2Joint.e_equalLimits)
dim 			 motorCdot  as variant = b2.m_angularVelocity - b1.m_angularVelocity - me.m_motorSpeed

dim 			 motorImpulse  as variant = - me.m_motorMass * motorCdot

dim 			 oldMotorImpulse  as variant = me.m_motorImpulse

			 me.m_motorImpulse = b2Math.b2Clamp( me.m_motorImpulse + motorImpulse, -step.dt * me.m_maxMotorTorque, step.dt * me.m_maxMotorTorque)
			motorImpulse = me.m_motorImpulse - oldMotorImpulse
			b1.m_angularVelocity -= b1.m_invI * motorImpulse
			b2.m_angularVelocity += b2.m_invI * motorImpulse
		if ( me.m_enableLimit && me.m_limitState != b2Joint.e_inactiveLimit)
dim 			 limitCdot  as variant = b2.m_angularVelocity - b1.m_angularVelocity

dim 			 limitImpulse  as variant = - me.m_motorMass * limitCdot

			if ( me.m_limitState == b2Joint.e_equalLimits)
			
				 me.m_limitImpulse += limitImpulse
			
			else if ( me.m_limitState == b2Joint.e_atLowerLimit)
			
				oldLimitImpulse = me.m_limitImpulse
				 me.m_limitImpulse = b2Math.b2Max( me.m_limitImpulse + limitImpulse, 0.0)
				limitImpulse = me.m_limitImpulse - oldLimitImpulse
			
			else if ( me.m_limitState == b2Joint.e_atUpperLimit)
			
				oldLimitImpulse = me.m_limitImpulse
				 me.m_limitImpulse = b2Math.b2Min( me.m_limitImpulse + limitImpulse, 0.0)
				limitImpulse = me.m_limitImpulse - oldLimitImpulse
			
			b1.m_angularVelocity -= b1.m_invI * limitImpulse
			b2.m_angularVelocity += b2.m_invI * limitImpulse
end

public  sub 	SolvePositionConstraints() as variant ''funcion
dim 		oldLimitImpulse
 as variant
dim 		limitC
 as variant
dim 		 b1  as variant = me.m_body1

dim 		 b2  as variant = me.m_body2

dim 		 positionError  as variant = 0.0

dim 		tMat
 as variant
		' //  Solve point-to-point position error.
		' // var r1 = b2Math.b2MulMV(b1.m_R, me.m_localAnchor1)
		tMat = b1.m_R
dim 		 r1X  as variant = tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y

dim 		 r1Y  as variant = tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y

		' // var r2 = b2Math.b2MulMV(b2.m_R, me.m_localAnchor2)
		tMat = b2.m_R
dim 		 r2X  as variant = tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y

dim 		 r2Y  as variant = tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y

		' // b2Vec2 p1 = b1->m_position + r1
dim 		 p1X  as variant = b1.m_position.x + r1X

dim 		 p1Y  as variant = b1.m_position.y + r1Y

		' // b2Vec2 p2 = b2->m_position + r2
dim 		 p2X  as variant = b2.m_position.x + r2X

dim 		 p2Y  as variant = b2.m_position.y + r2Y

		' // b2Vec2 ptpC = p2 - p1
dim 		 ptpCX  as variant = p2X - p1X

dim 		 ptpCY  as variant = p2Y - p1Y

		' // float32 positionError = ptpC.Length()
		positionError = Math.sqrt(ptpCX*ptpCX + ptpCY*ptpCY)
		' //  Prevent overly large corrections.
		' // b2Vec2 dpMax(b2_maxLinearCorrection, b2_maxLinearCorrection)
		' // ptpC = b2Clamp(ptpC, -dpMax, dpMax)
		' // float32 invMass1 = b1->m_invMass, invMass2 = b2->m_invMass
dim 		 invMass1  as variant = b1.m_invMass

dim 		 invMass2  as variant = b2.m_invMass

		' // float32 invI1 = b1->m_invI, invI2 = b2->m_invI
dim 		 invI1  as variant = b1.m_invI

dim 		 invI2  as variant = b2.m_invI

		' // b2Mat22 me.K1
		 me.K1.col1.x = invMass1 + invMass2
	 me.K1.col2.x = 0.0
		 me.K1.col1.y = 0.0
					 me.K1.col2.y = invMass1 + invMass2
		' // b2Mat22 me.K2
		 me.K2.col1.x =  invI1 * r1Y * r1Y
	 me.K2.col2.x = -invI1 * r1X * r1Y
		 me.K2.col1.y = -invI1 * r1X * r1Y
	 me.K2.col2.y =  invI1 * r1X * r1X
		' // b2Mat22 me.K3
		 me.K3.col1.x =  invI2 * r2Y * r2Y
		 me.K3.col2.x = -invI2 * r2X * r2Y
		 me.K3.col1.y = -invI2 * r2X * r2Y
		 me.K3.col2.y =  invI2 * r2X * r2X
		' // b2Mat22 me.K = me.K1 + me.K2 + me.K3
		 me.K.SetM( me.K1)
		 me.K.AddM( me.K2)
		 me.K.AddM( me.K3)
		' // b2Vec2 impulse = me.K.Solve(-ptpC)
		 me.K.Solve(b2RevoluteJoint.tImpulse, -ptpCX, -ptpCY)
dim 		 impulseX  as variant = b2RevoluteJoint.tImpulse.x

dim 		 impulseY  as variant = b2RevoluteJoint.tImpulse.y

		' // b1.m_position -= b1.m_invMass * impulse
		b1.m_position.x -= b1.m_invMass * impulseX
		b1.m_position.y -= b1.m_invMass * impulseY
		' // b1.m_rotation -= b1.m_invI * b2Cross(r1, impulse)
		b1.m_rotation -= b1.m_invI * (r1X * impulseY - r1Y * impulseX)
		b1.m_R.Set(b1.m_rotation)
		' // b2.m_position += b2.m_invMass * impulse
		b2.m_position.x += b2.m_invMass * impulseX
		b2.m_position.y += b2.m_invMass * impulseY
		' // b2.m_rotation += b2.m_invI * b2Cross(r2, impulse)
		b2.m_rotation += b2.m_invI * (r2X * impulseY - r2Y * impulseX)
		b2.m_R.Set(b2.m_rotation)
		' //  Handle limits.
dim 		 angularError  as variant = 0.0

		if ( me.m_enableLimit && me.m_limitState != b2Joint.e_inactiveLimit)
dim 			 angle  as variant = b2.m_rotation - b1.m_rotation - me.m_intialAngle

dim 			 limitImpulse  as variant = 0.0

			if ( me.m_limitState == b2Joint.e_equalLimits)
			
				' //  Prevent large angular corrections
				limitC = b2Math.b2Clamp(angle, -b2Settings.b2_maxAngularCorrection, b2Settings.b2_maxAngularCorrection)
				limitImpulse = - me.m_motorMass * limitC
				angularError = b2Math.b2Abs(limitC)
			
			else if ( me.m_limitState == b2Joint.e_atLowerLimit)
			
				limitC = angle - me.m_lowerAngle
				angularError = b2Math.b2Max(0.0, -limitC)
				' //  Prevent large angular corrections and allow some slop.
				limitC = b2Math.b2Clamp(limitC + b2Settings.b2_angularSlop, -b2Settings.b2_maxAngularCorrection, 0.0)
				limitImpulse = - me.m_motorMass * limitC
				oldLimitImpulse = me.m_limitPositionImpulse
				 me.m_limitPositionImpulse = b2Math.b2Max( me.m_limitPositionImpulse + limitImpulse, 0.0)
				limitImpulse = me.m_limitPositionImpulse - oldLimitImpulse
			
			else if ( me.m_limitState == b2Joint.e_atUpperLimit)
			
				limitC = angle - me.m_upperAngle
				angularError = b2Math.b2Max(0.0, limitC)
				' //  Prevent large angular corrections and allow some slop.
				limitC = b2Math.b2Clamp(limitC - b2Settings.b2_angularSlop, 0.0, b2Settings.b2_maxAngularCorrection)
				limitImpulse = - me.m_motorMass * limitC
				oldLimitImpulse = me.m_limitPositionImpulse
				 me.m_limitPositionImpulse = b2Math.b2Min( me.m_limitPositionImpulse + limitImpulse, 0.0)
				limitImpulse = me.m_limitPositionImpulse - oldLimitImpulse
			
			b1.m_rotation -= b1.m_invI * limitImpulse
			b1.m_R.Set(b1.m_rotation)
			b2.m_rotation += b2.m_invI * limitImpulse
			b2.m_R.Set(b2.m_rotation)
		return positionError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop
 '' TODO: posible funcion (revisar)

Public 1: new b2Vec2(), as new 2Vec2(),
Public 2: new b2Vec2(), as new 2Vec2(),
Public e: new b2Vec2(), as new 2Vec2(),
	m_motorImpulse: null
	m_limitImpulse: null
	m_limitPositionImpulse: null
Public s: new b2Mat22(), as new 2Mat22(),
	m_motorMass: null
	m_intialAngle: null
	m_lowerAngle: null
	m_upperAngle: null
	m_maxMotorTorque: null
	m_motorSpeed: null
	m_enableLimit: null
	m_enableMotor: null
	m_limitState: 0)
b2RevoluteJoint.tImpulse = new b2Vec2()
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2JointNode  as variant = Class.create()

b2JointNode.prototype = 
	other: null
	joint: null
	prev: null
	next: null
end

public  sub 	initialize()
 
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2JointDef  as variant = Class.create()

b2JointDef.prototype = 
end

public  sub 	initialize()

		 me.type = b2Joint.e_unknownJoint
		 me.userData = null
		 me.body1 = null
		 me.body2 = null
		 me.collideConnected = false
	type: 0
	userData: null
	body1: null
	body2: null
	collideConnected: null
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2MouseJointDef  as variant = Class.create()

inherits , b2JointDef
inherits 
end

public  sub 	initialize()

		' //  The constructor for b2JointDef
		 me.type = b2Joint.e_unknownJoint
		 me.userData = null
		 me.body1 = null
		 me.body2 = null
		 me.collideConnected = false
		' // 
		' //  initialize instance variables for references
		 me.target = new b2Vec2()
		' // 
		 me.type = b2Joint.e_mouseJoint
		 me.maxForce = 0.0
		 me.frequencyHz = 5.0
		 me.dampingRatio = 0.7
		 me.timeStep = 1.0 / 60.0
Public t: new b2Vec2(), as new 2Vec2(),
	maxForce: null
	frequencyHz: null
	dampingRatio: null
	timeStep: null)
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  Linear constraint (point-to-line)
' //  d = p2 - p1 = x2 + r2 - x1 - r1
' //  C = dot(ay1, d)
' //  Cdot = dot(d, cross(w1, ay1)) + dot(ay1, v2 + cross(w2, r2) - v1 - cross(w1, r1))
' //       = -dot(ay1, v1) - dot(cross(d + r1, ay1), w1) + dot(ay1, v2) + dot(cross(r2, ay1), v2)
' //  J = [-ay1 -cross(d+r1,ay1) ay1 cross(r2,ay1)]
' // 
' //  Angular constraint
' //  C = a2 - a1 + a_initial
' //  Cdot = w2 - w1
' //  J = [0 0 -1 0 0 1]
' //  Motor/Limit linear constraint
' //  C = dot(ax1, d)
' //  Cdot = = -dot(ax1, v1) - dot(cross(d + r1, ax1), w1) + dot(ax1, v2) + dot(cross(r2, ax1), v2)
' //  J = [-ax1 -cross(d+r1,ax1) ax1 cross(r2,ax1)]
dim  b2PrismaticJoint  as variant = Class.create()

inherits , b2Joint
inherits 
end

public  sub 	GetAnchor1() as variant ''funcio as variant ''funcion
dim 		 b1  as variant = me.m_body1

		' // return b2Math.AddVV(b1.m_position, b2Math.b2MulMV(b1.m_R, me.m_localAnchor1))
 '' TODO: posible funcion (revisar)

dim 		 tVec  as variant = new b2Vec2()

		tVec.SetV( me.m_localAnchor1)
		tVec.MulM(b1.m_R)
		tVec.Add(b1.m_position)
		return tVec
 '' TODO: posible funcion (revisar)

end

public  sub 	GetAnchor2() as variant ''funcio as variant ''funcion
dim 		 b2  as variant = me.m_body2

		' // return b2Math.AddVV(b2.m_position, b2Math.b2MulMV(b2.m_R, me.m_localAnchor2))
 '' TODO: posible funcion (revisar)

dim 		 tVec  as variant = new b2Vec2()

		tVec.SetV( me.m_localAnchor2)
		tVec.MulM(b2.m_R)
		tVec.Add(b2.m_position)
		return tVec
 '' TODO: posible funcion (revisar)

end

public  sub 	GetJointTranslation() as variant ''funcion
dim 		 b1  as variant = me.m_body1

dim 		 b2  as variant = me.m_body2

dim 		tMat
 as variant
		' // var r1 = b2Math.b2MulMV(b1.m_R, me.m_localAnchor1)
		tMat = b1.m_R
dim 		 r1X  as variant = tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y

dim 		 r1Y  as variant = tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y

		' // var r2 = b2Math.b2MulMV(b2.m_R, me.m_localAnchor2)
		tMat = b2.m_R
dim 		 r2X  as variant = tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y

dim 		 r2Y  as variant = tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y

		' // var p1 = b2Math.AddVV(b1.m_position , r1)
dim 		 p1X  as variant = b1.m_position.x + r1X

dim 		 p1Y  as variant = b1.m_position.y + r1Y

		' // var p2 = b2Math.AddVV(b2.m_position , r2)
dim 		 p2X  as variant = b2.m_position.x + r2X

dim 		 p2Y  as variant = b2.m_position.y + r2Y

		' // var d = b2Math.SubtractVV(p2, p1)
dim 		 dX  as variant = p2X - p1X

dim 		 dY  as variant = p2Y - p1Y

		' // var ax1 = b2Math.b2MulMV(b1.m_R, me.m_localXAxis1)
		tMat = b1.m_R
dim 		 ax1X  as variant = tMat.col1.x * me.m_localXAxis1.x + tMat.col2.x * me.m_localXAxis1.y

dim 		 ax1Y  as variant = tMat.col1.y * me.m_localXAxis1.x + tMat.col2.y * me.m_localXAxis1.y

		' // var translation = b2Math.b2Dot(ax1, d)
dim 		 translation  as variant = ax1X*dX + ax1Y*dY

		return translation
 '' TODO: posible funcion (revisar)

end

public  sub 	GetJointSpeed() as variant ''funcion
dim 		 b1  as variant = me.m_body1

dim 		 b2  as variant = me.m_body2

dim 		tMat
 as variant
		' // var r1 = b2Math.b2MulMV(b1.m_R, me.m_localAnchor1)
		tMat = b1.m_R
dim 		 r1X  as variant = tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y

dim 		 r1Y  as variant = tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y

		' // var r2 = b2Math.b2MulMV(b2.m_R, me.m_localAnchor2)
		tMat = b2.m_R
dim 		 r2X  as variant = tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y

dim 		 r2Y  as variant = tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y

		' // var p1 = b2Math.AddVV(b1.m_position , r1)
dim 		 p1X  as variant = b1.m_position.x + r1X

dim 		 p1Y  as variant = b1.m_position.y + r1Y

		' // var p2 = b2Math.AddVV(b2.m_position , r2)
dim 		 p2X  as variant = b2.m_position.x + r2X

dim 		 p2Y  as variant = b2.m_position.y + r2Y

		' // var d = b2Math.SubtractVV(p2, p1)
dim 		 dX  as variant = p2X - p1X

dim 		 dY  as variant = p2Y - p1Y

		' // var ax1 = b2Math.b2MulMV(b1.m_R, me.m_localXAxis1)
		tMat = b1.m_R
dim 		 ax1X  as variant = tMat.col1.x * me.m_localXAxis1.x + tMat.col2.x * me.m_localXAxis1.y

dim 		 ax1Y  as variant = tMat.col1.y * me.m_localXAxis1.x + tMat.col2.y * me.m_localXAxis1.y

dim 		 v1  as variant = b1.m_linearVelocity

dim 		 v2  as variant = b2.m_linearVelocity

dim 		 w1  as variant = b1.m_angularVelocity

dim 		 w2  as variant = b2.m_angularVelocity

		' // var speed = b2Math.b2Dot(d, b2Math.b2CrossFV(w1, ax1)) + b2Math.b2Dot(ax1, b2Math.SubtractVV( b2Math.SubtractVV( b2Math.AddVV( v2 , b2Math.b2CrossFV(w2, r2)) , v1) , b2Math.b2CrossFV(w1, r1)))
		' // var b2D = (dX*(-w1 * ax1Y) + dY*(w1 * ax1X))
		' // var b2D2 = (ax1X * ((( v2.x + (-w2 * r2Y)) - v1.x) - (-w1 * r1Y)) + ax1Y * ((( v2.y + (w2 * r2X)) - v1.y) - (w1 * r1X)))
dim 		 speed  as variant = (dX*(-w1 * ax1Y) + dY*(w1 * ax1X)) + (ax1X * ((( v2.x + (-w2 * r2Y)) - v1.x) - (-w1 * r1Y)) + ax1Y * ((( v2.y + (w2 * r2X)) - v1.y) - (w1 * r1X)))

		return speed
 '' TODO: posible funcion (revisar)

end

public  sub 	GetMotorForce(invTimeStep as variant) as variant ''funcion
		return invTimeStep * me.m_motorImpulse
 '' TODO: posible funcion (revisar)

end

public  sub 	SetMotorSpeed(speed as variant)

		 me.m_motorSpeed = speed
end

public  sub 	SetMotorForce(force as variant)

		 me.m_maxMotorForce = force
end

public  sub 	GetReactionForce(invTimeStep as variant) as variant ''funcio as variant ''funcion
dim 		 tImp  as variant = invTimeStep * me.m_limitImpulse

dim 		tMat
 as variant
		' // var ax1 = b2Math.b2MulMV( me.m_body1.m_R, me.m_localXAxis1)
		tMat = me.m_body1.m_R
dim 		 ax1X  as variant = tImp * (tMat.col1.x * me.m_localXAxis1.x + tMat.col2.x * me.m_localXAxis1.y)

dim 		 ax1Y  as variant = tImp * (tMat.col1.y * me.m_localXAxis1.x + tMat.col2.y * me.m_localXAxis1.y)

		' // var ay1 = b2Math.b2MulMV( me.m_body1.m_R, me.m_localYAxis1)
dim 		 ay1X  as variant = tImp * (tMat.col1.x * me.m_localYAxis1.x + tMat.col2.x * me.m_localYAxis1.y)

dim 		 ay1Y  as variant = tImp * (tMat.col1.y * me.m_localYAxis1.x + tMat.col2.y * me.m_localYAxis1.y)

		' // return (invTimeStep * me.m_limitImpulse) * ax1 + (invTimeStep * me.m_linearImpulse) * ay1
 '' TODO: posible funcion (revisar)

		return new b2Vec2(ax1X+ay1X, ax1Y+ay1Y)
 '' TODO: posible funcion (revisar)

end

public  sub 	GetReactionTorque(invTimeStep as variant) as variant ''funcion
		return invTimeStep * me.m_angularImpulse
 '' TODO: posible funcion (revisar)

	' // --------------- Internals Below -------------------
end

public  sub 	initialize(def as variant)

		' //  The constructor for b2Joint
		' //  initialize instance variables for references
		 me.m_node1 = new b2JointNode()
		 me.m_node2 = new b2JointNode()
		' // 
		 me.m_type = def.type
		 me.m_prev = null
		 me.m_next = null
		 me.m_body1 = def.body1
		 me.m_body2 = def.body2
		 me.m_collideConnected = def.collideConnected
		 me.m_islandFlag = false
		 me.m_userData = def.userData
		' // 
		' //  initialize instance variables for references
		 me.m_localAnchor1 = new b2Vec2()
		 me.m_localAnchor2 = new b2Vec2()
		 me.m_localXAxis1 = new b2Vec2()
		 me.m_localYAxis1 = new b2Vec2()
		 me.m_linearJacobian = new b2Jacobian()
		 me.m_motorJacobian = new b2Jacobian()
		' // 
		' // super(def)
dim 		tMat
 as variant
dim 		tX
 as variant
dim 		tY
 as variant
		' // me.m_localAnchor1 = b2Math.b2MulTMV( me.m_body1.m_R, b2Math.SubtractVV(def.anchorPoint , me.m_body1.m_position))
		tMat = me.m_body1.m_R
		tX = (def.anchorPoint.x - me.m_body1.m_position.x)
		tY = (def.anchorPoint.y - me.m_body1.m_position.y)
		 me.m_localAnchor1.Set((tX*tMat.col1.x + tY*tMat.col1.y), (tX*tMat.col2.x + tY*tMat.col2.y))
		' // me.m_localAnchor2 = b2Math.b2MulTMV( me.m_body2.m_R, b2Math.SubtractVV(def.anchorPoint , me.m_body2.m_position))
		tMat = me.m_body2.m_R
		tX = (def.anchorPoint.x - me.m_body2.m_position.x)
		tY = (def.anchorPoint.y - me.m_body2.m_position.y)
		 me.m_localAnchor2.Set((tX*tMat.col1.x + tY*tMat.col1.y), (tX*tMat.col2.x + tY*tMat.col2.y))
		' // me.m_localXAxis1 = b2Math.b2MulTMV( me.m_body1.m_R, def.axis)
		tMat = me.m_body1.m_R
		tX = def.axis.x
		tY = def.axis.y
		 me.m_localXAxis1.Set((tX*tMat.col1.x + tY*tMat.col1.y), (tX*tMat.col2.x + tY*tMat.col2.y))
		' // me.m_localYAxis1 = b2Math.b2CrossFV(1.0, me.m_localXAxis1)
		 me.m_localYAxis1.x = - me.m_localXAxis1.y
		 me.m_localYAxis1.y = me.m_localXAxis1.x
		 me.m_initialAngle = me.m_body2.m_rotation - me.m_body1.m_rotation
		 me.m_linearJacobian.SetZero()
		 me.m_linearMass = 0.0
		 me.m_linearImpulse = 0.0
		 me.m_angularMass = 0.0
		 me.m_angularImpulse = 0.0
		 me.m_motorJacobian.SetZero()
		 me.m_motorMass = 0.0
		 me.m_motorImpulse = 0.0
		 me.m_limitImpulse = 0.0
		 me.m_limitPositionImpulse = 0.0
		 me.m_lowerTranslation = def.lowerTranslation
		 me.m_upperTranslation = def.upperTranslation
		 me.m_maxMotorForce = def.motorForce
		 me.m_motorSpeed = def.motorSpeed
		 me.m_enableLimit = def.enableLimit
		 me.m_enableMotor = def.enableMotor
end

public  sub 	PrepareVelocitySolver()

dim 		 b1  as variant = me.m_body1

dim 		 b2  as variant = me.m_body2

dim 		tMat
 as variant
		' //  Compute the effective masses.
		' // b2Vec2 r1 = b2Mul(b1->m_R, me.m_localAnchor1)
		tMat = b1.m_R
dim 		 r1X  as variant = tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y

dim 		 r1Y  as variant = tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y

		' // b2Vec2 r2 = b2Mul(b2->m_R, me.m_localAnchor2)
		tMat = b2.m_R
dim 		 r2X  as variant = tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y

dim 		 r2Y  as variant = tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y

		' // float32 invMass1 = b1->m_invMass, invMass2 = b2->m_invMass
dim 		 invMass1  as variant = b1.m_invMass

dim 		 invMass2  as variant = b2.m_invMass

		' // float32 invI1 = b1->m_invI, invI2 = b2->m_invI
dim 		 invI1  as variant = b1.m_invI

dim 		 invI2  as variant = b2.m_invI

		' //  Compute point to line constraint effective mass.
		' //  J = [-ay1 -cross(d+r1,ay1) ay1 cross(r2,ay1)]
		' // b2Vec2 ay1 = b2Mul(b1->m_R, me.m_localYAxis1)
		tMat = b1.m_R
dim 		 ay1X  as variant = tMat.col1.x * me.m_localYAxis1.x + tMat.col2.x * me.m_localYAxis1.y

dim 		 ay1Y  as variant = tMat.col1.y * me.m_localYAxis1.x + tMat.col2.y * me.m_localYAxis1.y

		' // b2Vec2 e = b2->m_position + r2 - b1->m_position
dim 		 eX  as variant = b2.m_position.x + r2X - b1.m_position.x

dim 		 eY  as variant = b2.m_position.y + r2Y - b1.m_position.y

		' // me.m_linearJacobian.Set(-ay1, -b2Math.b2Cross(e, ay1), ay1, b2Math.b2Cross(r2, ay1))
		 me.m_linearJacobian.linear1.x = -ay1X
		 me.m_linearJacobian.linear1.y = -ay1Y
		 me.m_linearJacobian.linear2.x = ay1X
		 me.m_linearJacobian.linear2.y = ay1Y
		 me.m_linearJacobian.angular1 = -(eX * ay1Y - eY * ay1X)
		 me.m_linearJacobian.angular2 = r2X * ay1Y - r2Y * ay1X
		 me.m_linearMass =	invMass1 + invI1 * me.m_linearJacobian.angular1 * me.m_linearJacobian.angular1 +
						invMass2 + invI2 * me.m_linearJacobian.angular2 * me.m_linearJacobian.angular2
		' // b2Settings.b2Assert( me.m_linearMass > Number.MIN_VALUE)
		 me.m_linearMass = 1.0 / me.m_linearMass
		' //  Compute angular constraint effective mass.
		 me.m_angularMass = 1.0 / (invI1 + invI2)
		' //  Compute motor and limit terms.
		if ( me.m_enableLimit || me.m_enableMotor)
			' //  The motor and limit share a Jacobian and effective mass.
			' // b2Vec2 ax1 = b2Mul(b1->m_R, me.m_localXAxis1)
			tMat = b1.m_R
dim 			 ax1X  as variant = tMat.col1.x * me.m_localXAxis1.x + tMat.col2.x * me.m_localXAxis1.y

dim 			 ax1Y  as variant = tMat.col1.y * me.m_localXAxis1.x + tMat.col2.y * me.m_localXAxis1.y

			' // me.m_motorJacobian.Set(-ax1, -b2Cross(e, ax1), ax1, b2Cross(r2, ax1))
			 me.m_motorJacobian.linear1.x = -ax1X
 me.m_motorJacobian.linear1.y = -ax1Y
			 me.m_motorJacobian.linear2.x = ax1X
 me.m_motorJacobian.linear2.y = ax1Y
			 me.m_motorJacobian.angular1 = -(eX * ax1Y - eY * ax1X)
			 me.m_motorJacobian.angular2 = r2X * ax1Y - r2Y * ax1X
			 me.m_motorMass =	invMass1 + invI1 * me.m_motorJacobian.angular1 * me.m_motorJacobian.angular1 +
							invMass2 + invI2 * me.m_motorJacobian.angular2 * me.m_motorJacobian.angular2
			' // b2Settings.b2Assert( me.m_motorMass > Number.MIN_VALUE)
			 me.m_motorMass = 1.0 / me.m_motorMass
			if ( me.m_enableLimit)
			
				' // b2Vec2 d = e - r1
dim 				 dX  as variant = eX - r1X

dim 				 dY  as variant = eY - r1Y

				' // float32 jointTranslation = b2Dot(ax1, d)
dim 				 jointTranslation  as variant = ax1X * dX + ax1Y * dY

				if (b2Math.b2Abs( me.m_upperTranslation - me.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop)
				
					 me.m_limitState = b2Joint.e_equalLimits
				
				else if (jointTranslation <= me.m_lowerTranslation)
				
					if ( me.m_limitState != b2Joint.e_atLowerLimit)
					
						 me.m_limitImpulse = 0.0
					
					 me.m_limitState = b2Joint.e_atLowerLimit
				
				else if (jointTranslation >= me.m_upperTranslation)
				
					if ( me.m_limitState != b2Joint.e_atUpperLimit)
					
						 me.m_limitImpulse = 0.0
					
					 me.m_limitState = b2Joint.e_atUpperLimit
				
				else
				
					 me.m_limitState = b2Joint.e_inactiveLimit
					 me.m_limitImpulse = 0.0
				
			
		if ( me.m_enableMotor == false)
			 me.m_motorImpulse = 0.0
		if ( me.m_enableLimit == false)
			 me.m_limitImpulse = 0.0
		if (b2World.s_enableWarmStarting)
			' // b2Vec2 P1 = me.m_linearImpulse * me.m_linearJacobian.linear1 + ( me.m_motorImpulse + me.m_limitImpulse) * me.m_motorJacobian.linear1
dim 			 P1X  as variant = me.m_linearImpulse * me.m_linearJacobian.linear1.x + ( me.m_motorImpulse + me.m_limitImpulse) * me.m_motorJacobian.linear1.x

dim 			 P1Y  as variant = me.m_linearImpulse * me.m_linearJacobian.linear1.y + ( me.m_motorImpulse + me.m_limitImpulse) * me.m_motorJacobian.linear1.y

			' // b2Vec2 P2 = me.m_linearImpulse * me.m_linearJacobian.linear2 + ( me.m_motorImpulse + me.m_limitImpulse) * me.m_motorJacobian.linear2
dim 			 P2X  as variant = me.m_linearImpulse * me.m_linearJacobian.linear2.x + ( me.m_motorImpulse + me.m_limitImpulse) * me.m_motorJacobian.linear2.x

dim 			 P2Y  as variant = me.m_linearImpulse * me.m_linearJacobian.linear2.y + ( me.m_motorImpulse + me.m_limitImpulse) * me.m_motorJacobian.linear2.y

			' // float32 L1 = me.m_linearImpulse * me.m_linearJacobian.angular1 - me.m_angularImpulse + ( me.m_motorImpulse + me.m_limitImpulse) * me.m_motorJacobian.angular1
dim 			 L1  as variant = me.m_linearImpulse * me.m_linearJacobian.angular1 - me.m_angularImpulse + ( me.m_motorImpulse + me.m_limitImpulse) * me.m_motorJacobian.angular1

			' // float32 L2 = me.m_linearImpulse * me.m_linearJacobian.angular2 + me.m_angularImpulse + ( me.m_motorImpulse + me.m_limitImpulse) * me.m_motorJacobian.angular2
dim 			 L2  as variant = me.m_linearImpulse * me.m_linearJacobian.angular2 + me.m_angularImpulse + ( me.m_motorImpulse + me.m_limitImpulse) * me.m_motorJacobian.angular2

			' // b1->m_linearVelocity += invMass1 * P1
			b1.m_linearVelocity.x += invMass1 * P1X
			b1.m_linearVelocity.y += invMass1 * P1Y
			' // b1->m_angularVelocity += invI1 * L1
			b1.m_angularVelocity += invI1 * L1
			' // b2->m_linearVelocity += invMass2 * P2
			b2.m_linearVelocity.x += invMass2 * P2X
			b2.m_linearVelocity.y += invMass2 * P2Y
			' // b2->m_angularVelocity += invI2 * L2
			b2.m_angularVelocity += invI2 * L2
		else
			 me.m_linearImpulse = 0.0
			 me.m_angularImpulse = 0.0
			 me.m_limitImpulse = 0.0
			 me.m_motorImpulse = 0.0
		 me.m_limitPositionImpulse = 0.0
end

public  sub 	SolveVelocityConstraints(step as variant)

dim 		 b1  as variant = me.m_body1

dim 		 b2  as variant = me.m_body2

dim 		 invMass1  as variant = b1.m_invMass

dim 		 invMass2  as variant = b2.m_invMass

dim 		 invI1  as variant = b1.m_invI

dim 		 invI2  as variant = b2.m_invI

dim 		oldLimitImpulse
 as variant
		' //  Solve linear constraint.
dim 		 linearCdot  as variant = me.m_linearJacobian.Compute(b1.m_linearVelocity, b1.m_angularVelocity, b2.m_linearVelocity, b2.m_angularVelocity)

dim 		 linearImpulse  as variant = - me.m_linearMass * linearCdot

		 me.m_linearImpulse += linearImpulse
		' // b1->m_linearVelocity += (invMass1 * linearImpulse) * me.m_linearJacobian.linear1
		b1.m_linearVelocity.x += (invMass1 * linearImpulse) * me.m_linearJacobian.linear1.x
		b1.m_linearVelocity.y += (invMass1 * linearImpulse) * me.m_linearJacobian.linear1.y
		' // b1->m_angularVelocity += invI1 * linearImpulse * me.m_linearJacobian.angular1
		b1.m_angularVelocity += invI1 * linearImpulse * me.m_linearJacobian.angular1
		' // b2->m_linearVelocity += (invMass2 * linearImpulse) * me.m_linearJacobian.linear2
		b2.m_linearVelocity.x += (invMass2 * linearImpulse) * me.m_linearJacobian.linear2.x
		b2.m_linearVelocity.y += (invMass2 * linearImpulse) * me.m_linearJacobian.linear2.y
		' // b2.m_angularVelocity += invI2 * linearImpulse * me.m_linearJacobian.angular2
		b2.m_angularVelocity += invI2 * linearImpulse * me.m_linearJacobian.angular2
		' //  Solve angular constraint.
dim 		 angularCdot  as variant = b2.m_angularVelocity - b1.m_angularVelocity

dim 		 angularImpulse  as variant = - me.m_angularMass * angularCdot

		 me.m_angularImpulse += angularImpulse
		b1.m_angularVelocity -= invI1 * angularImpulse
		b2.m_angularVelocity += invI2 * angularImpulse
		' //  Solve linear motor constraint.
		if ( me.m_enableMotor && me.m_limitState != b2Joint.e_equalLimits)
dim 			 motorCdot  as variant = me.m_motorJacobian.Compute(b1.m_linearVelocity, b1.m_angularVelocity, b2.m_linearVelocity, b2.m_angularVelocity) - me.m_motorSpeed

dim 			 motorImpulse  as variant = - me.m_motorMass * motorCdot

dim 			 oldMotorImpulse  as variant = me.m_motorImpulse

			 me.m_motorImpulse = b2Math.b2Clamp( me.m_motorImpulse + motorImpulse, -step.dt * me.m_maxMotorForce, step.dt * me.m_maxMotorForce)
			motorImpulse = me.m_motorImpulse - oldMotorImpulse
			' // b1.m_linearVelocity += (invMass1 * motorImpulse) * me.m_motorJacobian.linear1
			b1.m_linearVelocity.x += (invMass1 * motorImpulse) * me.m_motorJacobian.linear1.x
			b1.m_linearVelocity.y += (invMass1 * motorImpulse) * me.m_motorJacobian.linear1.y
			' // b1.m_angularVelocity += invI1 * motorImpulse * me.m_motorJacobian.angular1
			b1.m_angularVelocity += invI1 * motorImpulse * me.m_motorJacobian.angular1
			' // b2->m_linearVelocity += (invMass2 * motorImpulse) * me.m_motorJacobian.linear2
			b2.m_linearVelocity.x += (invMass2 * motorImpulse) * me.m_motorJacobian.linear2.x
			b2.m_linearVelocity.y += (invMass2 * motorImpulse) * me.m_motorJacobian.linear2.y
			' // b2->m_angularVelocity += invI2 * motorImpulse * me.m_motorJacobian.angular2
			b2.m_angularVelocity += invI2 * motorImpulse * me.m_motorJacobian.angular2
		' //  Solve linear limit constraint.
		if ( me.m_enableLimit && me.m_limitState != b2Joint.e_inactiveLimit)
dim 			 limitCdot  as variant = me.m_motorJacobian.Compute(b1.m_linearVelocity, b1.m_angularVelocity, b2.m_linearVelocity, b2.m_angularVelocity)

dim 			 limitImpulse  as variant = - me.m_motorMass * limitCdot

			if ( me.m_limitState == b2Joint.e_equalLimits)
			
				 me.m_limitImpulse += limitImpulse
			
			else if ( me.m_limitState == b2Joint.e_atLowerLimit)
			
				oldLimitImpulse = me.m_limitImpulse
				 me.m_limitImpulse = b2Math.b2Max( me.m_limitImpulse + limitImpulse, 0.0)
				limitImpulse = me.m_limitImpulse - oldLimitImpulse
			
			else if ( me.m_limitState == b2Joint.e_atUpperLimit)
			
				oldLimitImpulse = me.m_limitImpulse
				 me.m_limitImpulse = b2Math.b2Min( me.m_limitImpulse + limitImpulse, 0.0)
				limitImpulse = me.m_limitImpulse - oldLimitImpulse
			
			' // b1->m_linearVelocity += (invMass1 * limitImpulse) * me.m_motorJacobian.linear1
			b1.m_linearVelocity.x += (invMass1 * limitImpulse) * me.m_motorJacobian.linear1.x
			b1.m_linearVelocity.y += (invMass1 * limitImpulse) * me.m_motorJacobian.linear1.y
			' // b1->m_angularVelocity += invI1 * limitImpulse * me.m_motorJacobian.angular1
			b1.m_angularVelocity += invI1 * limitImpulse * me.m_motorJacobian.angular1
			' // b2->m_linearVelocity += (invMass2 * limitImpulse) * me.m_motorJacobian.linear2
			b2.m_linearVelocity.x += (invMass2 * limitImpulse) * me.m_motorJacobian.linear2.x
			b2.m_linearVelocity.y += (invMass2 * limitImpulse) * me.m_motorJacobian.linear2.y
			' // b2->m_angularVelocity += invI2 * limitImpulse * me.m_motorJacobian.angular2
			b2.m_angularVelocity += invI2 * limitImpulse * me.m_motorJacobian.angular2
end

public  sub 	SolvePositionConstraints() as variant ''funcion
dim 		limitC
 as variant
dim 		oldLimitImpulse
 as variant
dim 		 b1  as variant = me.m_body1

dim 		 b2  as variant = me.m_body2

dim 		 invMass1  as variant = b1.m_invMass

dim 		 invMass2  as variant = b2.m_invMass

dim 		 invI1  as variant = b1.m_invI

dim 		 invI2  as variant = b2.m_invI

dim 		tMat
 as variant
		' // b2Vec2 r1 = b2Mul(b1->m_R, me.m_localAnchor1)
		tMat = b1.m_R
dim 		 r1X  as variant = tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y

dim 		 r1Y  as variant = tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y

		' // b2Vec2 r2 = b2Mul(b2->m_R, me.m_localAnchor2)
		tMat = b2.m_R
dim 		 r2X  as variant = tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y

dim 		 r2Y  as variant = tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y

		' // b2Vec2 p1 = b1->m_position + r1
dim 		 p1X  as variant = b1.m_position.x + r1X

dim 		 p1Y  as variant = b1.m_position.y + r1Y

		' // b2Vec2 p2 = b2->m_position + r2
dim 		 p2X  as variant = b2.m_position.x + r2X

dim 		 p2Y  as variant = b2.m_position.y + r2Y

		' // b2Vec2 d = p2 - p1
dim 		 dX  as variant = p2X - p1X

dim 		 dY  as variant = p2Y - p1Y

		' // b2Vec2 ay1 = b2Mul(b1->m_R, me.m_localYAxis1)
		tMat = b1.m_R
dim 		 ay1X  as variant = tMat.col1.x * me.m_localYAxis1.x + tMat.col2.x * me.m_localYAxis1.y

dim 		 ay1Y  as variant = tMat.col1.y * me.m_localYAxis1.x + tMat.col2.y * me.m_localYAxis1.y

		' //  Solve linear (point-to-line) constraint.
		' // float32 linearC = b2Dot(ay1, d)
dim 		 linearC  as variant = ay1X*dX + ay1Y*dY

		' //  Prevent overly large corrections.
		linearC = b2Math.b2Clamp(linearC, -b2Settings.b2_maxLinearCorrection, b2Settings.b2_maxLinearCorrection)
dim 		 linearImpulse  as variant = - me.m_linearMass * linearC

		' // b1->m_position += (invMass1 * linearImpulse) * me.m_linearJacobian.linear1
		b1.m_position.x += (invMass1 * linearImpulse) * me.m_linearJacobian.linear1.x
		b1.m_position.y += (invMass1 * linearImpulse) * me.m_linearJacobian.linear1.y
		' // b1->m_rotation += invI1 * linearImpulse * me.m_linearJacobian.angular1
		b1.m_rotation += invI1 * linearImpulse * me.m_linearJacobian.angular1
		' // b1->m_R.Set(b1->m_rotation)
		' // b2->m_position += (invMass2 * linearImpulse) * me.m_linearJacobian.linear2
		b2.m_position.x += (invMass2 * linearImpulse) * me.m_linearJacobian.linear2.x
		b2.m_position.y += (invMass2 * linearImpulse) * me.m_linearJacobian.linear2.y
		b2.m_rotation += invI2 * linearImpulse * me.m_linearJacobian.angular2
		' // b2->m_R.Set(b2->m_rotation)
dim 		 positionError  as variant = b2Math.b2Abs(linearC)

		' //  Solve angular constraint.
dim 		 angularC  as variant = b2.m_rotation - b1.m_rotation - me.m_initialAngle

		' //  Prevent overly large corrections.
		angularC = b2Math.b2Clamp(angularC, -b2Settings.b2_maxAngularCorrection, b2Settings.b2_maxAngularCorrection)
dim 		 angularImpulse  as variant = - me.m_angularMass * angularC

		b1.m_rotation -= b1.m_invI * angularImpulse
		b1.m_R.Set(b1.m_rotation)
		b2.m_rotation += b2.m_invI * angularImpulse
		b2.m_R.Set(b2.m_rotation)
dim 		 angularError  as variant = b2Math.b2Abs(angularC)

		' //  Solve linear limit constraint.
		if ( me.m_enableLimit && me.m_limitState != b2Joint.e_inactiveLimit)
			' // b2Vec2 r1 = b2Mul(b1->m_R, me.m_localAnchor1)
			tMat = b1.m_R
			r1X = tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y
			r1Y = tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y
			' // b2Vec2 r2 = b2Mul(b2->m_R, me.m_localAnchor2)
			tMat = b2.m_R
			r2X = tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y
			r2Y = tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y
			' // b2Vec2 p1 = b1->m_position + r1
			p1X = b1.m_position.x + r1X
			p1Y = b1.m_position.y + r1Y
			' // b2Vec2 p2 = b2->m_position + r2
			p2X = b2.m_position.x + r2X
			p2Y = b2.m_position.y + r2Y
			' // b2Vec2 d = p2 - p1
			dX = p2X - p1X
			dY = p2Y - p1Y
			' // b2Vec2 ax1 = b2Mul(b1->m_R, me.m_localXAxis1)
			tMat = b1.m_R
dim 			 ax1X  as variant = tMat.col1.x * me.m_localXAxis1.x + tMat.col2.x * me.m_localXAxis1.y

dim 			 ax1Y  as variant = tMat.col1.y * me.m_localXAxis1.x + tMat.col2.y * me.m_localXAxis1.y

			' // float32 translation = b2Dot(ax1, d)
dim 			 translation  as variant = (ax1X*dX + ax1Y*dY)

dim 			 limitImpulse  as variant = 0.0

			if ( me.m_limitState == b2Joint.e_equalLimits)
			
				' //  Prevent large angular corrections
				limitC = b2Math.b2Clamp(translation, -b2Settings.b2_maxLinearCorrection, b2Settings.b2_maxLinearCorrection)
				limitImpulse = - me.m_motorMass * limitC
				positionError = b2Math.b2Max(positionError, b2Math.b2Abs(angularC))
			
			else if ( me.m_limitState == b2Joint.e_atLowerLimit)
			
				limitC = translation - me.m_lowerTranslation
				positionError = b2Math.b2Max(positionError, -limitC)
				' //  Prevent large linear corrections and allow some slop.
				limitC = b2Math.b2Clamp(limitC + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0.0)
				limitImpulse = - me.m_motorMass * limitC
				oldLimitImpulse = me.m_limitPositionImpulse
				 me.m_limitPositionImpulse = b2Math.b2Max( me.m_limitPositionImpulse + limitImpulse, 0.0)
				limitImpulse = me.m_limitPositionImpulse - oldLimitImpulse
			
			else if ( me.m_limitState == b2Joint.e_atUpperLimit)
			
				limitC = translation - me.m_upperTranslation
				positionError = b2Math.b2Max(positionError, limitC)
				' //  Prevent large linear corrections and allow some slop.
				limitC = b2Math.b2Clamp(limitC - b2Settings.b2_linearSlop, 0.0, b2Settings.b2_maxLinearCorrection)
				limitImpulse = - me.m_motorMass * limitC
				oldLimitImpulse = me.m_limitPositionImpulse
				 me.m_limitPositionImpulse = b2Math.b2Min( me.m_limitPositionImpulse + limitImpulse, 0.0)
				limitImpulse = me.m_limitPositionImpulse - oldLimitImpulse
			
			' // b1->m_position += (invMass1 * limitImpulse) * me.m_motorJacobian.linear1
			b1.m_position.x += (invMass1 * limitImpulse) * me.m_motorJacobian.linear1.x
			b1.m_position.y += (invMass1 * limitImpulse) * me.m_motorJacobian.linear1.y
			' // b1->m_rotation += invI1 * limitImpulse * me.m_motorJacobian.angular1
			b1.m_rotation += invI1 * limitImpulse * me.m_motorJacobian.angular1
			b1.m_R.Set(b1.m_rotation)
			' // b2->m_position += (invMass2 * limitImpulse) * me.m_motorJacobian.linear2
			b2.m_position.x += (invMass2 * limitImpulse) * me.m_motorJacobian.linear2.x
			b2.m_position.y += (invMass2 * limitImpulse) * me.m_motorJacobian.linear2.y
			' // b2->m_rotation += invI2 * limitImpulse * me.m_motorJacobian.angular2
			b2.m_rotation += invI2 * limitImpulse * me.m_motorJacobian.angular2
			b2.m_R.Set(b2.m_rotation)
		return positionError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop
 '' TODO: posible funcion (revisar)

Public 1: new b2Vec2(), as new 2Vec2(),
Public 2: new b2Vec2(), as new 2Vec2(),
Public 1: new b2Vec2(), as new 2Vec2(),
Public 1: new b2Vec2(), as new 2Vec2(),
	m_initialAngle: null
Public n: new b2Jacobian(), as new 2Jacobian(),
	m_linearMass: null
	m_linearImpulse: null
	m_angularMass: null
	m_angularImpulse: null
Public n: new b2Jacobian(), as new 2Jacobian(),
	m_motorMass: null
	m_motorImpulse: null
	m_limitImpulse: null
	m_limitPositionImpulse: null
	m_lowerTranslation: null
	m_upperTranslation: null
	m_maxMotorForce: null
	m_motorSpeed: null
	m_enableLimit: null
	m_enableMotor: null
	m_limitState: 0)
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2Joint  as variant = Class.create()

b2Joint.prototype = 
end

public  sub 	GetType() as variant ''funcion
		return me.m_type
 '' TODO: posible funcion (revisar)

end

public  sub 	GetAnchor1()
return null '' TODO: posible funcion (revisar)

end

public  sub 	GetAnchor2()
return null '' TODO: posible funcion (revisar)

end

public  sub 	GetReactionForce(invTimeStep as variant)
return null '' TODO: posible funcion (revisar)

end

public  sub 	GetReactionTorque(invTimeStep as variant)
return 0.0 '' TODO: posible funcion (revisar)

end

public  sub 	GetBody1() as variant ''funcion
		return me.m_body1
 '' TODO: posible funcion (revisar)

end

public  sub 	GetBody2() as variant ''funcion
		return me.m_body2
 '' TODO: posible funcion (revisar)

end

public  sub 	GetNext() as variant ''funcion
		return me.m_next
 '' TODO: posible funcion (revisar)

end

public  sub 	GetUserData() as variant ''funcion
		return me.m_userData
 '' TODO: posible funcion (revisar)

	' // --------------- Internals Below -------------------
end

public  sub 	initialize(def as variant)

		' //  initialize instance variables for references
		 me.m_node1 = new b2JointNode()
		 me.m_node2 = new b2JointNode()
		' // 
		 me.m_type = def.type
		 me.m_prev = null
		 me.m_next = null
		 me.m_body1 = def.body1
		 me.m_body2 = def.body2
		 me.m_collideConnected = def.collideConnected
		 me.m_islandFlag = false
		 me.m_userData = def.userData
	' // virtual ~b2Joint() 
end

public  sub 	PrepareVelocitySolver()

end

public  sub 	SolveVelocityConstraints(step as variant) as variant ''funcion
	' //  This returns true if the position errors are within tolerance. '' TODO: posible funcion (revisar)

end

public  sub 	PreparePositionSolver()

end

public  sub 	SolvePositionConstraints()
return false '' TODO: posible funcion (revisar)

	m_type: 0
	m_prev: null
	m_next: null
Public 1: new b2JointNode(), as new 2JointNode(),
Public 2: new b2JointNode(), as new 2JointNode(),
	m_body1: null
	m_body2: null
	m_islandFlag: null
	m_collideConnected: null
	m_userData: null
	' //  ENUMS
	' //  enum b2JointType
	' //  enum b2LimitState
end

public  sub Create (def as variant, allocator as variant) as variant ''funcion
dim 		 joint  as variant = null

		switch (def.type)
		case b2Joint.e_distanceJoint:
			
				' // void* mem = allocator->Allocate(sizeof(b2DistanceJoint))
				joint = new b2DistanceJoint(def)
			
			break
		case b2Joint.e_mouseJoint:
			
				' // void* mem = allocator->Allocate(sizeof(b2MouseJoint))
				joint = new b2MouseJoint(def)
			
			break
		case b2Joint.e_prismaticJoint:
			
				' // void* mem = allocator->Allocate(sizeof(b2PrismaticJoint))
				joint = new b2PrismaticJoint(def)
			
			break
		case b2Joint.e_revoluteJoint:
			
				' // void* mem = allocator->Allocate(sizeof(b2RevoluteJoint))
				joint = new b2RevoluteJoint(def)
			
			break
		case b2Joint.e_pulleyJoint:
			
				' // void* mem = allocator->Allocate(sizeof(b2PulleyJoint))
				joint = new b2PulleyJoint(def)
			
			break
		case b2Joint.e_gearJoint:
			
				' // void* mem = allocator->Allocate(sizeof(b2GearJoint))
				joint = new b2GearJoint(def)
			
			break
		default:
			' // b2Settings.b2Assert(false)
			break
		return joint
 '' TODO: posible funcion (revisar)

end

public  sub Destroy (joint as variant, allocator as variant)

		' /* joint->~b2Joint()
		switch (joint.m_type)
		case b2Joint.e_distanceJoint:
			allocator->Free(joint, sizeof(b2DistanceJoint))
			break
		case b2Joint.e_mouseJoint:
			allocator->Free(joint, sizeof(b2MouseJoint))
			break
		case b2Joint.e_prismaticJoint:
			allocator->Free(joint, sizeof(b2PrismaticJoint))
			break
		case b2Joint.e_revoluteJoint:
			allocator->Free(joint, sizeof(b2RevoluteJoint))
			break
		case b2Joint.e_pulleyJoint:
			allocator->Free(joint, sizeof(b2PulleyJoint))
			break
		case b2Joint.e_gearJoint:
			allocator->Free(joint, sizeof(b2GearJoint))
			break
		default:
			b2Assert(false)
			break
		*/
b2Joint.e_unknownJoint = 0
b2Joint.e_revoluteJoint = 1
b2Joint.e_prismaticJoint = 2
b2Joint.e_distanceJoint = 3
b2Joint.e_pulleyJoint = 4
b2Joint.e_mouseJoint = 5
b2Joint.e_gearJoint = 6
b2Joint.e_inactiveLimit = 0
b2Joint.e_atLowerLimit = 1
b2Joint.e_atUpperLimit = 2
b2Joint.e_equalLimits = 3
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2RevoluteJointDef  as variant = Class.create()

inherits , b2JointDef
inherits 
end

public  sub 	initialize()

		' //  The constructor for b2JointDef
		 me.type = b2Joint.e_unknownJoint
		 me.userData = null
		 me.body1 = null
		 me.body2 = null
		 me.collideConnected = false
		' // 
		 me.type = b2Joint.e_revoluteJoint
		 me.anchorPoint = new b2Vec2(0.0, 0.0)
		 me.lowerAngle = 0.0
		 me.upperAngle = 0.0
		 me.motorTorque = 0.0
		 me.motorSpeed = 0.0
		 me.enableLimit = false
		 me.enableMotor = false
	anchorPoint: null
	lowerAngle: null
	upperAngle: null
	motorTorque: null
	motorSpeed: null
	enableLimit: null
	enableMotor: null)
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2PrismaticJointDef  as variant = Class.create()

inherits , b2JointDef
inherits 
end

public  sub 	initialize()

		' //  The constructor for b2JointDef
		 me.type = b2Joint.e_unknownJoint
		 me.userData = null
		 me.body1 = null
		 me.body2 = null
		 me.collideConnected = false
		' // 
		 me.type = b2Joint.e_prismaticJoint
		 me.anchorPoint = new b2Vec2(0.0, 0.0)
		 me.axis = new b2Vec2(0.0, 0.0)
		 me.lowerTranslation = 0.0
		 me.upperTranslation = 0.0
		 me.motorForce = 0.0
		 me.motorSpeed = 0.0
		 me.enableLimit = false
		 me.enableMotor = false
	anchorPoint: null
	axis: null
	lowerTranslation: null
	upperTranslation: null
	motorForce: null
	motorSpeed: null
	enableLimit: null
	enableMotor: null)
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  p = attached point, m = mouse point
' //  C = p - m
' //  Cdot = v
' //       = v + cross(w, r)
' //  J = [I r_skew]
' //  Identity used:
' //  w k % (rx i + ry j) = w * (-ry i + rx j)
dim  b2MouseJoint  as variant = Class.create()

inherits , b2Joint
inherits 
end

public  sub 	GetAnchor1() as variant ''funcion
		return me.m_target
 '' TODO: posible funcion (revisar)

end

public  sub 	GetAnchor2() as variant ''funcion
dim 		 tVec  as variant = b2Math.b2MulMV( me.m_body2.m_R, me.m_localAnchor)

		tVec.Add( me.m_body2.m_position)
		return tVec
 '' TODO: posible funcion (revisar)

end

public  sub 	GetReactionForce(invTimeStep as variant) as variant ''funcion
		' // b2Vec2 F = invTimeStep * me.m_impulse
dim 		 F  as variant = new b2Vec2()

		F.SetV( me.m_impulse)
		F.Multiply(invTimeStep)
		return F
 '' TODO: posible funcion (revisar)

end

public  sub 	GetReactionTorque(invTimeStep as variant) as variant ''funcion
		' // NOT_USED(invTimeStep)
		return 0.0
 '' TODO: posible funcion (revisar)

end

public  sub 	SetTarget(target as variant)

		 me.m_body2.WakeUp()
		 me.m_target = target
	' // --------------- Internals Below -------------------
end

public  sub 	initialize(def as variant)

		' //  The constructor for b2Joint
		' //  initialize instance variables for references
		 me.m_node1 = new b2JointNode()
		 me.m_node2 = new b2JointNode()
		' // 
		 me.m_type = def.type
		 me.m_prev = null
		 me.m_next = null
		 me.m_body1 = def.body1
		 me.m_body2 = def.body2
		 me.m_collideConnected = def.collideConnected
		 me.m_islandFlag = false
		 me.m_userData = def.userData
		' // 
		' //  initialize instance variables for references
		 me.K = new b2Mat22()
		 me.K1 = new b2Mat22()
		 me.K2 = new b2Mat22()
		 me.m_localAnchor = new b2Vec2()
		 me.m_target = new b2Vec2()
		 me.m_impulse = new b2Vec2()
		 me.m_ptpMass = new b2Mat22()
		 me.m_C = new b2Vec2()
		' // 
		' // super(def)
		 me.m_target.SetV(def.target)
		' // me.m_localAnchor = b2Math.b2MulTMV( me.m_body2.m_R, b2Math.SubtractVV( me.m_target, me.m_body2.m_position ) )
dim 		 tX  as variant = me.m_target.x - me.m_body2.m_position.x

dim 		 tY  as variant = me.m_target.y - me.m_body2.m_position.y

		 me.m_localAnchor.x = (tX * me.m_body2.m_R.col1.x + tY * me.m_body2.m_R.col1.y)
		 me.m_localAnchor.y = (tX * me.m_body2.m_R.col2.x + tY * me.m_body2.m_R.col2.y)
		 me.m_maxForce = def.maxForce
		 me.m_impulse.SetZero()
dim 		 mass  as variant = me.m_body2.m_mass

		' //  Frequency
dim 		 omega  as variant = 2.0 * b2Settings.b2_pi * def.frequencyHz

		' //  Damping coefficient
dim 		 d  as variant = 2.0 * mass * def.dampingRatio * omega

		' //  Spring stiffness
dim 		 k  as variant = mass * omega * omega

		' //  magic formulas
		 me.m_gamma = 1.0 / (d + def.timeStep * k)
		 me.m_beta = def.timeStep * k / (d + def.timeStep * k)
	' //  Presolve vars
Public K: new b2Mat22(), as new 2Mat22(),
Public 1: new b2Mat22(), as new 2Mat22(),
Public 2: new b2Mat22(), as new 2Mat22(),
end

public  sub 	PrepareVelocitySolver()

dim 		 b  as variant = me.m_body2

dim 		tMat
 as variant
		' //  Compute the effective mass matrix.
		' // b2Vec2 r = b2Mul(b.m_R, me.m_localAnchor)
		tMat = b.m_R
dim 		 rX  as variant = tMat.col1.x * me.m_localAnchor.x + tMat.col2.x * me.m_localAnchor.y

dim 		 rY  as variant = tMat.col1.y * me.m_localAnchor.x + tMat.col2.y * me.m_localAnchor.y

		' //  me.K    = [(1/m1 + 1/m2) * eye(2) - skew(r1) * invI1 * skew(r1) - skew(r2) * invI2 * skew(r2)]
		' //       = [1/m1+1/m2     0    ] + invI1 * [r1.y*r1.y -r1.x*r1.y] + invI2 * [r1.y*r1.y -r1.x*r1.y]
		' //         [    0     1/m1+1/m2]           [-r1.x*r1.y r1.x*r1.x]           [-r1.x*r1.y r1.x*r1.x]
dim 		 invMass  as variant = b.m_invMass

dim 		 invI  as variant = b.m_invI

		' // b2Mat22 me.K1
		 me.K1.col1.x = invMass
	 me.K1.col2.x = 0.0
		 me.K1.col1.y = 0.0
		 me.K1.col2.y = invMass
		' // b2Mat22 me.K2
		 me.K2.col1.x =  invI * rY * rY
	 me.K2.col2.x = -invI * rX * rY
		 me.K2.col1.y = -invI * rX * rY
	 me.K2.col2.y =  invI * rX * rX
		' // b2Mat22 me.K = me.K1 + me.K2
		 me.K.SetM( me.K1)
		 me.K.AddM( me.K2)
		 me.K.col1.x += me.m_gamma
		 me.K.col2.y += me.m_gamma
		' // me.m_ptpMass = me.K.Invert()
		 me.K.Invert( me.m_ptpMass)
		' // me.m_C = b.m_position + r - me.m_target
		 me.m_C.x = b.m_position.x + rX - me.m_target.x
		 me.m_C.y = b.m_position.y + rY - me.m_target.y
		' //  Cheat with some damping
		b.m_angularVelocity *= 0.98
		' //  Warm starting.
		' // b2Vec2 P = me.m_impulse
dim 		 PX  as variant = me.m_impulse.x

dim 		 PY  as variant = me.m_impulse.y

		' // b.m_linearVelocity += invMass * P
		b.m_linearVelocity.x += invMass * PX
		b.m_linearVelocity.y += invMass * PY
		' // b.m_angularVelocity += invI * b2Cross(r, P)
		b.m_angularVelocity += invI * (rX * PY - rY * PX)
end

public  sub 	SolveVelocityConstraints(step as variant)

dim 		 body  as variant = me.m_body2

dim 		tMat
 as variant
		' //  Compute the effective mass matrix.
		' // b2Vec2 r = b2Mul(body.m_R, me.m_localAnchor)
		tMat = body.m_R
dim 		 rX  as variant = tMat.col1.x * me.m_localAnchor.x + tMat.col2.x * me.m_localAnchor.y

dim 		 rY  as variant = tMat.col1.y * me.m_localAnchor.x + tMat.col2.y * me.m_localAnchor.y

		' //  Cdot = v + cross(w, r)
		' // b2Vec2 Cdot = body->m_linearVelocity + b2Cross(body->m_angularVelocity, r)
dim 		 CdotX  as variant = body.m_linearVelocity.x + (-body.m_angularVelocity * rY)

dim 		 CdotY  as variant = body.m_linearVelocity.y + (body.m_angularVelocity * rX)

		' // b2Vec2 impulse = -b2Mul( me.m_ptpMass, Cdot + ( me.m_beta * step->inv_dt) * me.m_C + me.m_gamma * me.m_impulse)
		tMat = me.m_ptpMass
dim 		 tX  as variant = CdotX + ( me.m_beta * step.inv_dt) * me.m_C.x + me.m_gamma * me.m_impulse.x

dim 		 tY  as variant = CdotY + ( me.m_beta * step.inv_dt) * me.m_C.y + me.m_gamma * me.m_impulse.y

dim 		 impulseX  as variant = -(tMat.col1.x * tX + tMat.col2.x * tY)

dim 		 impulseY  as variant = -(tMat.col1.y * tX + tMat.col2.y * tY)

dim 		 oldImpulseX  as variant = me.m_impulse.x

dim 		 oldImpulseY  as variant = me.m_impulse.y

		' // me.m_impulse += impulse
		 me.m_impulse.x += impulseX
		 me.m_impulse.y += impulseY
dim 		 length  as variant = me.m_impulse.Length()

		if (length > step.dt * me.m_maxForce)
			' // me.m_impulse *= step.dt * me.m_maxForce / length
			 me.m_impulse.Multiply(step.dt * me.m_maxForce / length)
		' // impulse = me.m_impulse - oldImpulse
		impulseX = me.m_impulse.x - oldImpulseX
		impulseY = me.m_impulse.y - oldImpulseY
		' // body.m_linearVelocity += body->m_invMass * impulse
		body.m_linearVelocity.x += body.m_invMass * impulseX
		body.m_linearVelocity.y += body.m_invMass * impulseY
		' // body.m_angularVelocity += body->m_invI * b2Cross(r, impulse)
		body.m_angularVelocity += body.m_invI * (rX * impulseY - rY * impulseX)
end

public  sub 	SolvePositionConstraints() as variant ''funcion
		return true
 '' TODO: posible funcion (revisar)

Public r: new b2Vec2(), as new 2Vec2(),
Public t: new b2Vec2(), as new 2Vec2(),
Public e: new b2Vec2(), as new 2Vec2(),
Public s: new b2Mat22(), as new 2Mat22(),
Public C: new b2Vec2(), as new 2Vec2(),
	m_maxForce: null
	m_beta: null
	m_gamma: null)
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  C = norm(p2 - p1) - L
' //  u = (p2 - p1) / norm(p2 - p1)
' //  Cdot = dot(u, v2 + cross(w2, r2) - v1 - cross(w1, r1))
' //  J = [-u -cross(r1, u) u cross(r2, u)]
' //  K = J * invM * JT
' //    = invMass1 + invI1 * cross(r1, u)^2 + invMass2 + invI2 * cross(r2, u)^2
dim  b2DistanceJoint  as variant = Class.create()

inherits , b2Joint
inherits 
	' // --------------- Internals Below -------------------
end

public  sub 	initialize(def as variant)

		' //  The constructor for b2Joint
		' //  initialize instance variables for references
		 me.m_node1 = new b2JointNode()
		 me.m_node2 = new b2JointNode()
		' // 
		 me.m_type = def.type
		 me.m_prev = null
		 me.m_next = null
		 me.m_body1 = def.body1
		 me.m_body2 = def.body2
		 me.m_collideConnected = def.collideConnected
		 me.m_islandFlag = false
		 me.m_userData = def.userData
		' // 
		' //  initialize instance variables for references
		 me.m_localAnchor1 = new b2Vec2()
		 me.m_localAnchor2 = new b2Vec2()
		 me.m_u = new b2Vec2()
		' // 
		' // super(def)
dim 		tMat
 as variant
dim 		tX
 as variant
dim 		tY
 as variant
		' // me.m_localAnchor1 = b2MulT( me.m_body1->m_R, def->anchorPoint1 - me.m_body1->m_position)
		tMat = me.m_body1.m_R
		tX = def.anchorPoint1.x - me.m_body1.m_position.x
		tY = def.anchorPoint1.y - me.m_body1.m_position.y
		 me.m_localAnchor1.x = tX*tMat.col1.x + tY*tMat.col1.y
		 me.m_localAnchor1.y = tX*tMat.col2.x + tY*tMat.col2.y
		' // me.m_localAnchor2 = b2MulT( me.m_body2->m_R, def->anchorPoint2 - me.m_body2->m_position)
		tMat = me.m_body2.m_R
		tX = def.anchorPoint2.x - me.m_body2.m_position.x
		tY = def.anchorPoint2.y - me.m_body2.m_position.y
		 me.m_localAnchor2.x = tX*tMat.col1.x + tY*tMat.col1.y
		 me.m_localAnchor2.y = tX*tMat.col2.x + tY*tMat.col2.y
		' // b2Vec2 d = def->anchorPoint2 - def->anchorPoint1
		tX = def.anchorPoint2.x - def.anchorPoint1.x
		tY = def.anchorPoint2.y - def.anchorPoint1.y
		' // me.m_length = d.Length()
		 me.m_length = Math.sqrt(tX*tX + tY*tY)
		 me.m_impulse = 0.0
end

public  sub 	PrepareVelocitySolver()

dim 		tMat
 as variant
		' //  Compute the effective mass matrix.
		' // b2Vec2 r1 = b2Mul( me.m_body1->m_R, me.m_localAnchor1)
		tMat = me.m_body1.m_R
dim 		 r1X  as variant = tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y

dim 		 r1Y  as variant = tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y

		' // b2Vec2 r2 = b2Mul( me.m_body2->m_R, me.m_localAnchor2)
		tMat = me.m_body2.m_R
dim 		 r2X  as variant = tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y

dim 		 r2Y  as variant = tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y

		' // me.m_u = me.m_body2->m_position + r2 - me.m_body1->m_position - r1
		 me.m_u.x = me.m_body2.m_position.x + r2X - me.m_body1.m_position.x - r1X
		 me.m_u.y = me.m_body2.m_position.y + r2Y - me.m_body1.m_position.y - r1Y
		' //  Handle singularity.
		' // float32 length = me.m_u.Length()
dim 		 length  as variant = Math.sqrt( me.m_u.x* me.m_u.x + me.m_u.y* me.m_u.y)

		if (length > b2Settings.b2_linearSlop)
			' // me.m_u *= 1.0 / length
			 me.m_u.Multiply( 1.0 / length )
		else
			 me.m_u.SetZero()
		' // float32 cr1u = b2Cross(r1, me.m_u)
dim 		 cr1u  as variant = (r1X * me.m_u.y - r1Y * me.m_u.x)

		' // float32 cr2u = b2Cross(r2, me.m_u)
dim 		 cr2u  as variant = (r2X * me.m_u.y - r2Y * me.m_u.x)

		' // me.m_mass = me.m_body1->m_invMass + me.m_body1->m_invI * cr1u * cr1u + me.m_body2->m_invMass + me.m_body2->m_invI * cr2u * cr2u
		 me.m_mass = me.m_body1.m_invMass + me.m_body1.m_invI * cr1u * cr1u + me.m_body2.m_invMass + me.m_body2.m_invI * cr2u * cr2u
		' // b2Settings.b2Assert( me.m_mass > Number.MIN_VALUE)
		 me.m_mass = 1.0 / me.m_mass
		if (b2World.s_enableWarmStarting)
			' // b2Vec2 P = me.m_impulse * me.m_u
dim 			 PX  as variant = me.m_impulse * me.m_u.x

dim 			 PY  as variant = me.m_impulse * me.m_u.y

			' // me.m_body1.m_linearVelocity -= me.m_body1.m_invMass * P
			 me.m_body1.m_linearVelocity.x -= me.m_body1.m_invMass * PX
			 me.m_body1.m_linearVelocity.y -= me.m_body1.m_invMass * PY
			' // me.m_body1.m_angularVelocity -= me.m_body1.m_invI * b2Cross(r1, P)
			 me.m_body1.m_angularVelocity -= me.m_body1.m_invI * (r1X * PY - r1Y * PX)
			' // me.m_body2.m_linearVelocity += me.m_body2.m_invMass * P
			 me.m_body2.m_linearVelocity.x += me.m_body2.m_invMass * PX
			 me.m_body2.m_linearVelocity.y += me.m_body2.m_invMass * PY
			' // me.m_body2.m_angularVelocity += me.m_body2.m_invI * b2Cross(r2, P)
			 me.m_body2.m_angularVelocity += me.m_body2.m_invI * (r2X * PY - r2Y * PX)
		else
			 me.m_impulse = 0.0
end

public  sub 	SolveVelocityConstraints(step as variant)

dim 		tMat
 as variant
		' // b2Vec2 r1 = b2Mul( me.m_body1->m_R, me.m_localAnchor1)
		tMat = me.m_body1.m_R
dim 		 r1X  as variant = tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y

dim 		 r1Y  as variant = tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y

		' // b2Vec2 r2 = b2Mul( me.m_body2->m_R, me.m_localAnchor2)
		tMat = me.m_body2.m_R
dim 		 r2X  as variant = tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y

dim 		 r2Y  as variant = tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y

		' //  Cdot = dot(u, v + cross(w, r))
		' // b2Vec2 v1 = me.m_body1->m_linearVelocity + b2Cross( me.m_body1->m_angularVelocity, r1)
dim 		 v1X  as variant = me.m_body1.m_linearVelocity.x + (- me.m_body1.m_angularVelocity * r1Y)

dim 		 v1Y  as variant = me.m_body1.m_linearVelocity.y + ( me.m_body1.m_angularVelocity * r1X)

		' // b2Vec2 v2 = me.m_body2->m_linearVelocity + b2Cross( me.m_body2->m_angularVelocity, r2)
dim 		 v2X  as variant = me.m_body2.m_linearVelocity.x + (- me.m_body2.m_angularVelocity * r2Y)

dim 		 v2Y  as variant = me.m_body2.m_linearVelocity.y + ( me.m_body2.m_angularVelocity * r2X)

		' // float32 Cdot = b2Dot( me.m_u, v2 - v1)
dim 		 Cdot  as variant = ( me.m_u.x * (v2X - v1X) + me.m_u.y * (v2Y - v1Y))

		' // float32 impulse = - me.m_mass * Cdot
dim 		 impulse  as variant = - me.m_mass * Cdot

		 me.m_impulse += impulse
		' // b2Vec2 P = impulse * me.m_u
dim 		 PX  as variant = impulse * me.m_u.x

dim 		 PY  as variant = impulse * me.m_u.y

		' // me.m_body1->m_linearVelocity -= me.m_body1->m_invMass * P
		 me.m_body1.m_linearVelocity.x -= me.m_body1.m_invMass * PX
		 me.m_body1.m_linearVelocity.y -= me.m_body1.m_invMass * PY
		' // me.m_body1->m_angularVelocity -= me.m_body1->m_invI * b2Cross(r1, P)
		 me.m_body1.m_angularVelocity -= me.m_body1.m_invI * (r1X * PY - r1Y * PX)
		' // me.m_body2->m_linearVelocity += me.m_body2->m_invMass * P
		 me.m_body2.m_linearVelocity.x += me.m_body2.m_invMass * PX
		 me.m_body2.m_linearVelocity.y += me.m_body2.m_invMass * PY
		' // me.m_body2->m_angularVelocity += me.m_body2->m_invI * b2Cross(r2, P)
		 me.m_body2.m_angularVelocity += me.m_body2.m_invI * (r2X * PY - r2Y * PX)
end

public  sub 	SolvePositionConstraints() as variant ''funcion
dim 		tMat
 as variant
		' // b2Vec2 r1 = b2Mul( me.m_body1->m_R, me.m_localAnchor1)
		tMat = me.m_body1.m_R
dim 		 r1X  as variant = tMat.col1.x * me.m_localAnchor1.x + tMat.col2.x * me.m_localAnchor1.y

dim 		 r1Y  as variant = tMat.col1.y * me.m_localAnchor1.x + tMat.col2.y * me.m_localAnchor1.y

		' // b2Vec2 r2 = b2Mul( me.m_body2->m_R, me.m_localAnchor2)
		tMat = me.m_body2.m_R
dim 		 r2X  as variant = tMat.col1.x * me.m_localAnchor2.x + tMat.col2.x * me.m_localAnchor2.y

dim 		 r2Y  as variant = tMat.col1.y * me.m_localAnchor2.x + tMat.col2.y * me.m_localAnchor2.y

		' // b2Vec2 d = me.m_body2->m_position + r2 - me.m_body1->m_position - r1
dim 		 dX  as variant = me.m_body2.m_position.x + r2X - me.m_body1.m_position.x - r1X

dim 		 dY  as variant = me.m_body2.m_position.y + r2Y - me.m_body1.m_position.y - r1Y

		' // float32 length = d.Normalize()
dim 		 length  as variant = Math.sqrt(dX*dX + dY*dY)

		dX /= length
		dY /= length
		' // float32 C = length - me.m_length
dim 		 C  as variant = length - me.m_length

		C = b2Math.b2Clamp(C, -b2Settings.b2_maxLinearCorrection, b2Settings.b2_maxLinearCorrection)
dim 		 impulse  as variant = - me.m_mass * C

		' // me.m_u = d
		 me.m_u.Set(dX, dY)
		' // b2Vec2 P = impulse * me.m_u
dim 		 PX  as variant = impulse * me.m_u.x

dim 		 PY  as variant = impulse * me.m_u.y

		' // me.m_body1->m_position -= me.m_body1->m_invMass * P
		 me.m_body1.m_position.x -= me.m_body1.m_invMass * PX
		 me.m_body1.m_position.y -= me.m_body1.m_invMass * PY
		' // me.m_body1->m_rotation -= me.m_body1->m_invI * b2Cross(r1, P)
		 me.m_body1.m_rotation -= me.m_body1.m_invI * (r1X * PY - r1Y * PX)
		' // me.m_body2->m_position += me.m_body2->m_invMass * P
		 me.m_body2.m_position.x += me.m_body2.m_invMass * PX
		 me.m_body2.m_position.y += me.m_body2.m_invMass * PY
		' // me.m_body2->m_rotation -= me.m_body2->m_invI * b2Cross(r2, P)
		 me.m_body2.m_rotation += me.m_body2.m_invI * (r2X * PY - r2Y * PX)
		 me.m_body1.m_R.Set( me.m_body1.m_rotation)
		 me.m_body2.m_R.Set( me.m_body2.m_rotation)
		return b2Math.b2Abs(C) < b2Settings.b2_linearSlop
 '' TODO: posible funcion (revisar)

end

public  sub 	GetAnchor1() as variant ''funcion
		return b2Math.AddVV( me.m_body1.m_position , b2Math.b2MulMV( me.m_body1.m_R, me.m_localAnchor1))
 '' TODO: posible funcion (revisar)

end

public  sub 	GetAnchor2() as variant ''funcion
		return b2Math.AddVV( me.m_body2.m_position , b2Math.b2MulMV( me.m_body2.m_R, me.m_localAnchor2))
 '' TODO: posible funcion (revisar)

end

public  sub 	GetReactionForce(invTimeStep as variant) as variant ''funcion
		' // var F = ( me.m_impulse * invTimeStep) * me.m_u
dim 		 F  as variant = new b2Vec2()

		F.SetV( me.m_u)
		F.Multiply( me.m_impulse * invTimeStep)
		return F
 '' TODO: posible funcion (revisar)

end

public  sub 	GetReactionTorque(invTimeStep as variant) as variant ''funcion
		' // NOT_USED(invTimeStep)
		return 0.0
 '' TODO: posible funcion (revisar)

Public 1: new b2Vec2(), as new 2Vec2(),
Public 2: new b2Vec2(), as new 2Vec2(),
Public u: new b2Vec2(), as new 2Vec2(),
	m_impulse: null
	m_mass: null
	m_length: null)