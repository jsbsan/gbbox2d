' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
' you must notv  
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */


inherits  b2Contact

public 	m_manifold as new variant[]= [new b2Manifold()]


public  sub 		initialize(s1 as variant, s2 as variant)  as variant ''funcion
		' //  The constructor for b2Contact
		' //  initialize instance variables for references
		 me.m_node1 = new b2ContactNode()
		 me.m_node2 = new b2ContactNode()
		' // 
		 me.m_flags = 0
		if (not s1 or not s2) then 
			 me.m_shape1 = null
			 me.m_shape2 = null
			return
		endif
		
 

		 me.m_shape1 = s1
		 me.m_shape2 = s2
		 me.m_manifoldCount = 0
		 me.m_friction = sqrt( me.m_shape1.m_friction * me.m_shape2.m_friction)
		 me.m_restitution = b2Math.b2Max( me.m_shape1.m_restitution, me.m_shape2.m_restitution)
		 me.m_prev = null
		 me.m_next = null
		 me.m_node1.contact = null
		 me.m_node1.prev = null
		 me.m_node1.next = null
		 me.m_node1.other = null
		 me.m_node2.contact = null
		 me.m_node2.prev = null
		 me.m_node2.next = null
		 me.m_node2.other = null
		' // 
		' //  initialize instance variables for references
		 me.m_manifold = [new b2Manifold()]
		' // 
		' // super(shape1, shape2)
		' // b2Settings.b2Assert( me.m_shape1.m_type == b2Shape.e_circleShape)
		' // b2Settings.b2Assert( me.m_shape2.m_type == b2Shape.e_circleShape)
		 me.m_manifold[0].pointCount = 0
		 me.m_manifold[0].points[0].normalImpulse = 0.0
		 me.m_manifold[0].points[0].tangentImpulse = 0.0
	' // ~b2CircleContact() 
end

public  sub 	Evaluate()

		b2Collision.b2CollideCircle( me.m_manifold[0], me.m_shape1, me.m_shape2, false)
		if ( me.m_manifold[0].pointCount > 0) then
			 me.m_manifoldCount = 1
		else
			 me.m_manifoldCount = 0
		endif
end

public  sub 	GetManifolds() as variant ''funcion
		return me.m_manifold
end



public  sub Create (shape1 as variant, shape2 as variant, allocator as variant) as variant ''funcion
		return new b2CircleContact(shape1, shape2)
 end

public  sub Destroy (contact as variant, allocator as variant)
end
	