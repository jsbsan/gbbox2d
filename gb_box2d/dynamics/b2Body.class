' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  A rigid body. Internal computation are done in terms
' //  of the center of mass position. The center of mass may
' //  be offset from the body's origin.
dim  b2Body  as variant = Class.create()

b2Body.prototype = 
	' //  Set the position of the body's origin and rotation (radians).
	' //  This breaks any contacts and wakes the other bodies.
end

public  sub 	SetOriginPosition(position as variant, rotation as variant) as variant ''funcion
		if ( me.IsFrozen())
			return
 '' TODO: posible funcion (revisar)

		 me.m_rotation = rotation
		 me.m_R.Set( me.m_rotation)
		 me.m_position = b2Math.AddVV(position , b2Math.b2MulMV( me.m_R, me.m_center))
		 me.m_position0.SetV( me.m_position)
		 me.m_rotation0 = me.m_rotation
		for (var s = me.m_shapeList; s != null; s = s.m_next)
			s.Synchronize( me.m_position, me.m_R, me.m_position, me.m_R)
		 me.m_world.m_broadPhase.Commit()
	' //  Get the position of the body's origin. The body's origin does not
	' //  necessarily coincide with the center of mass. It depends on how the
	' //  shapes are created.
end

public  sub 	GetOriginPosition() as variant ''funcion
		return b2Math.SubtractVV( me.m_position, b2Math.b2MulMV( me.m_R, me.m_center))
 '' TODO: posible funcion (revisar)

	' //  Set the position of the body's center of mass and rotation (radians).
	' //  This breaks any contacts and wakes the other bodies.
end

public  sub 	SetCenterPosition(position as variant, rotation as variant) as variant ''funcion
		if ( me.IsFrozen())
			return
 '' TODO: posible funcion (revisar)

		 me.m_rotation = rotation
		 me.m_R.Set( me.m_rotation)
		 me.m_position.SetV( position )
		 me.m_position0.SetV( me.m_position)
		 me.m_rotation0 = me.m_rotation
		for (var s = me.m_shapeList; s != null; s = s.m_next)
			s.Synchronize( me.m_position, me.m_R, me.m_position, me.m_R)
		 me.m_world.m_broadPhase.Commit()
	' //  Get the position of the body's center of mass. The body's center of mass
	' //  does not necessarily coincide with the body's origin. It depends on how the
	' //  shapes are created.
end

public  sub 	GetCenterPosition() as variant ''funcion
		return me.m_position
 '' TODO: posible funcion (revisar)

	' //  Get the rotation in radians.
end

public  sub 	GetRotation() as variant ''funcion
		return me.m_rotation
 '' TODO: posible funcion (revisar)

end

public  sub 	GetRotationMatrix() as variant ''funcion
		return me.m_R
 '' TODO: posible funcion (revisar)

	' //  Set/Get the linear velocity of the center of mass.
end

public  sub 	SetLinearVelocity(v as variant)

		 me.m_linearVelocity.SetV(v)
end

public  sub 	GetLinearVelocity() as variant ''funcion
		return me.m_linearVelocity
 '' TODO: posible funcion (revisar)

	' //  Set/Get the angular velocity.
end

public  sub 	SetAngularVelocity(w as variant)

		 me.m_angularVelocity = w
end

public  sub 	GetAngularVelocity() as variant ''funcion
		return me.m_angularVelocity
 '' TODO: posible funcion (revisar)

	' //  Apply a force at a world point. Additive.
end

public  sub 	ApplyForce(force as variant, point as variant)

		if ( me.IsSleeping() == false)
			 me.m_force.Add( force )
			 me.m_torque += b2Math.b2CrossVV(b2Math.SubtractVV(point, me.m_position), force)
	' //  Apply a torque. Additive.
end

public  sub 	ApplyTorque(torque as variant)

		if ( me.IsSleeping() == false)
			 me.m_torque += torque
	' //  Apply an impulse at a point. This immediately modifies the velocity.
end

public  sub 	ApplyImpulse(impulse as variant, point as variant)

		if ( me.IsSleeping() == false)
			 me.m_linearVelocity.Add( b2Math.MulFV( me.m_invMass, impulse) )
			 me.m_angularVelocity += ( me.m_invI * b2Math.b2CrossVV( b2Math.SubtractVV(point, me.m_position), impulse)  )
end

public  sub 	GetMass() as variant ''funcion
		return me.m_mass
 '' TODO: posible funcion (revisar)

end

public  sub 	GetInertia() as variant ''funcion
		return me.m_I
 '' TODO: posible funcion (revisar)

	' //  Get the world coordinates of a point give the local coordinates
	' //  relative to the body's center of mass.
end

public  sub 	GetWorldPoint(localPoint as variant) as variant ''funcion
		return b2Math.AddVV( me.m_position , b2Math.b2MulMV( me.m_R, localPoint))
 '' TODO: posible funcion (revisar)

	' //  Get the world coordinates of a vector given the local coordinates.
end

public  sub 	GetWorldVector(localVector as variant) as variant ''funcion
		return b2Math.b2MulMV( me.m_R, localVector)
 '' TODO: posible funcion (revisar)

	' //  Returns a local point relative to the center of mass given a world point.
end

public  sub 	GetLocalPoint(worldPoint as variant) as variant ''funcion
		return b2Math.b2MulTMV( me.m_R, b2Math.SubtractVV(worldPoint, me.m_position))
 '' TODO: posible funcion (revisar)

	' //  Returns a local vector given a world vector.
end

public  sub 	GetLocalVector(worldVector as variant) as variant ''funcion
		return b2Math.b2MulTMV( me.m_R, worldVector)
 '' TODO: posible funcion (revisar)

	' //  Is this body static (immovable)?
end

public  sub 	IsStatic() as variant ''funcion
		return ( me.m_flags & b2Body.e_staticFlag) == b2Body.e_staticFlag
 '' TODO: posible funcion (revisar)

end

public  sub 	IsFrozen() as variant ''funcion
		return ( me.m_flags & b2Body.e_frozenFlag) == b2Body.e_frozenFlag
 '' TODO: posible funcion (revisar)

	' //  Is this body sleeping (not simulating).
end

public  sub 	IsSleeping() as variant ''funcion
		return ( me.m_flags & b2Body.e_sleepFlag) == b2Body.e_sleepFlag
 '' TODO: posible funcion (revisar)

	' //  You can disable sleeping on this particular body.
end

public  sub 	AllowSleeping(flag as variant)

		if (flag)
			 me.m_flags |= b2Body.e_allowSleepFlag
		else
			 me.m_flags &= ~b2Body.e_allowSleepFlag
			 me.WakeUp()
	' //  Wake up this body so it will begin simulating.
end

public  sub 	WakeUp()

		 me.m_flags &= ~b2Body.e_sleepFlag
		 me.m_sleepTime = 0.0
	' //  Get the list of all shapes attached to this body.
end

public  sub 	GetShapeList() as variant ''funcion
		return me.m_shapeList
 '' TODO: posible funcion (revisar)

end

public  sub 	GetContactList() as variant ''funcion
		return me.m_contactList
 '' TODO: posible funcion (revisar)

end

public  sub 	GetJointList() as variant ''funcion
		return me.m_jointList
 '' TODO: posible funcion (revisar)

	' //  Get the next body in the world's body list.
end

public  sub 	GetNext() as variant ''funcion
		return me.m_next
 '' TODO: posible funcion (revisar)

end

public  sub 	GetUserData() as variant ''funcion
		return me.m_userData
 '' TODO: posible funcion (revisar)

	' // --------------- Internals Below -------------------
end

public  sub 	initialize(bd as variant, world as variant)

		' //  initialize instance variables for references
		 me.sMat0 = new b2Mat22()
		 me.m_position = new b2Vec2()
		 me.m_R = new b2Mat22(0)
		 me.m_position0 = new b2Vec2()
		' // 
dim 		 i  as variant = 0

dim 		sd
 as variant
dim 		massData
 as variant
		 me.m_flags = 0
		 me.m_position.SetV( bd.position )
		 me.m_rotation = bd.rotation
		 me.m_R.Set( me.m_rotation)
		 me.m_position0.SetV( me.m_position)
		 me.m_rotation0 = me.m_rotation
		 me.m_world = world
		 me.m_linearDamping = b2Math.b2Clamp(1.0 - bd.linearDamping, 0.0, 1.0)
		 me.m_angularDamping = b2Math.b2Clamp(1.0 - bd.angularDamping, 0.0, 1.0)
		 me.m_force = new b2Vec2(0.0, 0.0)
		 me.m_torque = 0.0
		 me.m_mass = 0.0
dim 		 massDatas  as variant = new Array(b2Settings.b2_maxShapesPerBody)

		for (i = 0; i < b2Settings.b2_maxShapesPerBody; i++)
			massDatas[i] = new b2MassData()
		' //  Compute the shape mass properties, the bodies total mass and COM.
		 me.m_shapeCount = 0
		 me.m_center = new b2Vec2(0.0, 0.0)
		for (i = 0; i < b2Settings.b2_maxShapesPerBody; ++i)
			sd = bd.shapes[i]
			if (sd == null) break
			massData = massDatas[ i ]
			sd.ComputeMass(massData)
			 me.m_mass += massData.mass
			' // me.m_center += massData->mass * (sd->localPosition + massData->center)
			 me.m_center.x += massData.mass * (sd.localPosition.x + massData.center.x)
			 me.m_center.y += massData.mass * (sd.localPosition.y + massData.center.y)
			++ me.m_shapeCount
		' //  Compute center of mass, and shift the origin to the COM.
		if ( me.m_mass > 0.0)
			 me.m_center.Multiply( 1.0 / me.m_mass )
			 me.m_position.Add( b2Math.b2MulMV( me.m_R, me.m_center) )
		else
			 me.m_flags |= b2Body.e_staticFlag
		' //  Compute the moment of inertia.
		 me.m_I = 0.0
		for (i = 0; i < me.m_shapeCount; ++i)
			sd = bd.shapes[i]
			massData = massDatas[ i ]
			 me.m_I += massData.I
dim 			 r  as variant = b2Math.SubtractVV( b2Math.AddVV(sd.localPosition, massData.center), me.m_center )

			 me.m_I += massData.mass * b2Math.b2Dot(r, r)
		if ( me.m_mass > 0.0)
			 me.m_invMass = 1.0 / me.m_mass
		else
			 me.m_invMass = 0.0
		if ( me.m_I > 0.0 && bd.preventRotation == false)
			 me.m_invI = 1.0 / me.m_I
		else
			 me.m_I = 0.0
			 me.m_invI = 0.0
		' //  Compute the center of mass velocity.
		 me.m_linearVelocity = b2Math.AddVV(bd.linearVelocity, b2Math.b2CrossFV(bd.angularVelocity, me.m_center))
		 me.m_angularVelocity = bd.angularVelocity
		 me.m_jointList = null
		 me.m_contactList = null
		 me.m_prev = null
		 me.m_next = null
		' //  Create the shapes.
		 me.m_shapeList = null
		for (i = 0; i < me.m_shapeCount; ++i)
			sd = bd.shapes[i]
dim 			 shape  as variant = b2Shape.Create(sd, this, me.m_center)

			shape.m_next = me.m_shapeList
			 me.m_shapeList = shape
		 me.m_sleepTime = 0.0
		if (bd.allowSleep)
			 me.m_flags |= b2Body.e_allowSleepFlag
		if (bd.isSleeping)
			 me.m_flags |= b2Body.e_sleepFlag
		if (( me.m_flags & b2Body.e_sleepFlag)  || me.m_invMass == 0.0)
			 me.m_linearVelocity.Set(0.0, 0.0)
			 me.m_angularVelocity = 0.0
		 me.m_userData = bd.userData
	' //  does not support destructors
	' /* ~b2Body()
		b2Shape* s = me.m_shapeList
		while (s)
			b2Shape* s0 = s
			s = s-> me.m_next
			b2Shape:: me.Destroy(s0)
	*/
end

public  sub 	Destroy()

dim 		 s  as variant = me.m_shapeList

		while (s)
dim 			 s0  as variant = s

			s = s.m_next
			b2Shape.Destroy(s0)
	' //  Temp mat
Public 0: new b2Mat22(), as new 2Mat22(),
end

public  sub 	SynchronizeShapes()

		' // b2Mat22 R0( me.m_rotation0)
		 me.sMat0.Set( me.m_rotation0)
		for (var s = me.m_shapeList; s != null; s = s.m_next)
			s.Synchronize( me.m_position0, me.sMat0, me.m_position, me.m_R)
end

public  sub 	QuickSyncShapes()

		for (var s = me.m_shapeList; s != null; s = s.m_next)
			s.QuickSync( me.m_position, me.m_R)
	' //  This is used to prevent connected bodies from colliding.
	' //  It may lie, depending on the collideConnected flag.
end

public  sub 	IsConnected(other as variant) as variant ''funcio as variant ''funcion
		for (var jn = me.m_jointList; jn != null; jn = jn.next)
			if (jn.other == other)
				return jn.joint.m_collideConnected == false
 '' TODO: posible funcion (revisar)

		return false
 '' TODO: posible funcion (revisar)

end

public  sub 	Freeze()

		 me.m_flags |= b2Body.e_frozenFlag
		 me.m_linearVelocity.SetZero()
		 me.m_angularVelocity = 0.0
		for (var s = me.m_shapeList; s != null; s = s.m_next)
			s.DestroyProxy()
	m_flags: 0
Public n: new b2Vec2(), as new 2Vec2(),
	m_rotation: null
Public R: new b2Mat22(0), as new 2Mat22(0),
	' //  Conservative advancement data.
Public 0: new b2Vec2(), as new 2Vec2(),
	m_rotation0: null
	m_linearVelocity: null
	m_angularVelocity: null
	m_force: null
	m_torque: null
	m_center: null
	m_world: null
	m_prev: null
	m_next: null
	m_shapeList: null
	m_shapeCount: 0
	m_jointList: null
	m_contactList: null
	m_mass: null
	m_invMass: null
	m_I: null
	m_invI: null
	m_linearDamping: null
	m_angularDamping: null
	m_sleepTime: null
	m_userData: null
b2Body.e_staticFlag = 0x0001
b2Body.e_frozenFlag = 0x0002
b2Body.e_islandFlag = 0x0004
b2Body.e_sleepFlag = 0x0008
b2Body.e_allowSleepFlag = 0x0010
b2Body.e_destroyFlag = 0x0020