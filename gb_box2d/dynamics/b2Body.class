' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
' you must not   
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  A rigid body. Internal computation are done in terms
' //  of the center of mass position. The center of mass may
' //  be offset from the body's origin.
	' //  Set the position of the body's origin and rotation (radians).
	' //  This breaks any contacts and wakes the other bodies.
	' //  Temp mat
Public sMat0 as variant= new b2Mat22()

public m_flags as variant= 0

public m_position as variant= new b2Vec2()
public m_rotation as variant= null
public m_R as variant= new b2Mat22(0)

// Conservative advancement data.
public m_position0 as variant= new b2Vec2()
public m_rotation0 as variant= null

public m_linearVelocity as variant= null
public m_angularVelocity as variant= null

public m_force as variant= null
public m_torque as variant= null

public m_center as variant= null

public m_world as variant= null
public m_prev as variant= null
public m_next as variant= null

public m_shapeList as variant= null
public m_shapeCount as variant= 0

public m_jointList as variant= null
public m_contactList as variant= null

public m_mass as variant= null
public m_invMass as variant= null
public m_I as variant= null
public m_invI as variant= null

public m_linearDamping as variant= null
public m_angularDamping as variant= null

public m_sleepTime as variant= null

public m_userData as variant= null

public e_staticFlag as variant= 0x0001
public e_frozenFlag as variant= 0x0002
public e_islandFlag as variant= 0x0004
public e_sleepFlag as variant= 0x0008
public e_allowSleepFlag as variant= 0x0010
public e_destroyFlag as variant= 0x0020





public  sub 	SetOriginPosition(position as variant, rotation as variant) as variant ''funcion
dim s as variant


		if ( me.IsFrozen()) then 
			return
		endif
		

		 me.m_rotation = rotation
		 me.m_R.Set( me.m_rotation)
		 me.m_position = b2Math.AddVV(position , b2Math.b2MulMV( me.m_R, me.m_center))
		 me.m_position0.SetV( me.m_position)

		 me.m_rotation0 = me.m_rotation
		 
		 s = me.m_shapeList
			while s<>null
			            s = s.m_next)
						s.Synchronize( me.m_position, me.m_R, me.m_position, me.m_R)
					    me.m_world.m_broadPhase.Commit()
			wend

end


				' //  Get the position of the body's origin. The body's origin does not
				' //  necessarily coincide with the center of mass. It depends on how the
				' //  shapes are created

public  sub 	GetOriginPosition() as variant ''funcion
		return b2Math.SubtractVV( me.m_position, b2Math.b2MulMV( me.m_R, me.m_center))
end


	' //  Set the position of the body's center of mass and rotation (radians).
	' //  This breaks any contacts and wakes the other bodies.

public  sub 	SetCenterPosition(position as variant, rotation as variant) as variant ''funcion
	dim s as variant
		if ( me.IsFrozen()) then 
			return
 	    endif

		 me.m_rotation = rotation
		 me.m_R.Set( me.m_rotation)
		 me.m_position.SetV( position )
		 me.m_position0.SetV( me.m_position)
		 me.m_rotation0 = me.m_rotation
		 	 s = me.m_shapeList
			while s<>null
	             s = s.m_next)
			   s.Synchronize( me.m_position, me.m_R, me.m_position, me.m_R)
		 me.m_world.m_broadPhase.Commit()
		wend
		
end


' //  Get the position of the body's center of mass. The body's center of mass
	' //  does not necessarily coincide with the body's origin. It depends on how the
	' //  shapes are created.
public  sub 	GetCenterPosition() as variant ''funcion
		return me.m_position
end

	' //  Get the rotation in radians.
public  sub 	GetRotation() as variant ''funcion
		return me.m_rotation

end

	' //  Set/Get the linear velocity of the center of mass.
public  sub 	GetRotationMatrix() as variant ''funcion
		return me.m_R
end

public  sub 	SetLinearVelocity(v as variant)
		 me.m_linearVelocity.SetV(v)
end

public  sub 	GetLinearVelocity() as variant ''funcion
		return me.m_linearVelocity
end

	' //  Set/Get the angular velocity.
public  sub 	SetAngularVelocity(w as variant)

		 me.m_angularVelocity = w
end

public  sub 	GetAngularVelocity() as variant ''funcion
		return me.m_angularVelocity

end


	' //  Apply a force at a world point. Additive.
public  sub 	ApplyForce(force as variant, point as variant)
		if ( me.IsSleeping() = false) then 
			 me.m_force.Add( force )
			 me.m_torque += b2Math.b2CrossVV(b2Math.SubtractVV(point, me.m_position), force)
	endif
end


' //  Apply a torque. Additive.
public  sub 	ApplyTorque(torque as variant)

		if ( me.IsSleeping() = false)
			 me.m_torque += torque
		endif
end

	' //  Apply an impulse at a point. This immediately modifies the velocity.
public  sub 	ApplyImpulse(impulse as variant, point as variant)
		if ( me.IsSleeping() = false) then 
			 me.m_linearVelocity.Add( b2Math.MulFV( me.m_invMass, impulse) )
			 me.m_angularVelocity += ( me.m_invI * b2Math.b2CrossVV( b2Math.SubtractVV(point, me.m_position), impulse)  )
end

public  sub 	GetMass() as variant ''funcion
		return me.m_mass
end


public  sub 	GetInertia() as variant ''funcion
		return me.m_I
end


	' //  Get the world coordinates of a point give the local coordinates
	' //  relative to the body's center of mass.

public  sub 	GetWorldPoint(localPoint as variant) as variant ''funcion
		return b2Math.AddVV( me.m_position , b2Math.b2MulMV( me.m_R, localPoint))
end


	' //  Get the world coordinates of a vector given the local coordinates.

public  sub 	GetWorldVector(localVector as variant) as variant ''funcion
		return b2Math.b2MulMV( me.m_R, localVector)
end

	' //  Returns a local point relative to the center of mass given a world point.

public  sub 	GetLocalPoint(worldPoint as variant) as variant ''funcion
		return b2Math.b2MulTMV( me.m_R, b2Math.SubtractVV(worldPoint, me.m_position))
end




	' //  Returns a local vector given a world vector.

public  sub 	GetLocalVector(worldVector as variant) as variant ''funcion
		return b2Math.b2MulTMV( me.m_R, worldVector)
end

	' //  Is this body static (immovable)?
public  sub 	IsStatic() as variant ''funcion
		return ( me.m_flags and b2Body.e_staticFlag) = b2Body.e_staticFlag
end

public  sub 	IsFrozen() as variant ''funcion
		return ( me.m_flags and b2Body.e_frozenFlag) = b2Body.e_frozenFlag

	
end

' //  Is this body sleeping (not simulating).
public  sub 	IsSleeping() as variant ''funcion
		return ( me.m_flags and b2Body.e_sleepFlag) = b2Body.e_sleepFlag

	
end


' //  You can disable sleeping on this particular body.
public  sub 	AllowSleeping(flag as variant)
''TODO: Mirar signos especiales

		if (flag) then 
			 me.m_flags |= b2Body.e_allowSleepFlag
		else
			 me.m_flags &= ~b2Body.e_allowSleepFlag
			 me.WakeUp()
		end
	
end


' //  Wake up this body so it will begin simulating.
public  sub 	WakeUp()
''TODO: Mirar signos especiales

		 me.m_flags &= ~b2Body.e_sleepFlag
		 me.m_sleepTime = 0.0
	' //  Get the list of all shapes attached to this body.
end

public  sub 	GetShapeList() as variant ''funcion
		return me.m_shapeList
end

public  sub 	GetContactList() as variant ''funcion
		return me.m_contactList

end

public  sub 	GetJointList() as variant ''funcion
		return me.m_jointList

end

	' //  Get the next body in the world's body list.

public  sub 	GetNext() as variant ''funcion
		return me.m_next

end

public  sub 	GetUserData() as variant ''funcion
		return me.m_userData

end

	' // --------------- Internals Below -------------------

public  sub 	_new(bd as variant, world as variant)
dim 		 i  as variant = 0
dim 		sd  as variant
dim 		massData  as variant
dim 		 massDatas  as variant
dim 			 r  as variant 
dim 			 shape  as variant 
		' //  initialize instance variables for references
		 me.sMat0 = new b2Mat22()
		 me.m_position = new b2Vec2()
		 me.m_R = new b2Mat22(0)
		 me.m_position0 = new b2Vec2()
		' // 
		 me.m_flags = 0
		 me.m_position.SetV( bd.position )
		 me.m_rotation = bd.rotation
		 me.m_R.Set( me.m_rotation)
		 me.m_position0.SetV( me.m_position)
		 me.m_rotation0 = me.m_rotation
		 me.m_world = world
		 me.m_linearDamping = b2Math.b2Clamp(1.0 - bd.linearDamping, 0.0, 1.0)
		 me.m_angularDamping = b2Math.b2Clamp(1.0 - bd.angularDamping, 0.0, 1.0)
		 me.m_force = new b2Vec2(0.0, 0.0)
		 me.m_torque = 0.0
		 me.m_mass = 0.0
		 massDatas  = new Array(b2Settings.b2_maxShapesPerBody)

		for i=0 to  b2Settings.b2_maxShapesPerBody-1
			massDatas[i] = new b2MassData()
		next

		' //  Compute the shape mass properties, the bodies total mass and COM.
		 me.m_shapeCount = 0
		 me.m_center = new b2Vec2(0.0, 0.0)
		
		for i = 0 to b2Settings.b2_maxShapesPerBody-1
			sd = bd.shapes[i]
			if (sd = null) then break
			massData = massDatas[ i ]
			sd.ComputeMass(massData)
			 me.m_mass += massData.mass
			' // me.m_center += massData->mass * (sd->localPosition + massData->center)
			 me.m_center.x += massData.mass * (sd.localPosition.x + massData.center.x)
			 me.m_center.y += massData.mass * (sd.localPosition.y + massData.center.y)
			 me.m_shapeCount +=1
		next
		' //  Compute center of mass, and shift the origin to the COM.
		if ( me.m_mass > 0.0) then 
			 me.m_center.Multiply( 1.0 / me.m_mass )
			 me.m_position.Add( b2Math.b2MulMV( me.m_R, me.m_center) )
		else
			 me.m_flags |= b2Body.e_staticFlag
	    endif
	    
		' //  Compute the moment of inertia.
		 me.m_I = 0.0
		for i = 0 to  me.m_shapeCount-1
			sd = bd.shapes[i]
			massData = massDatas[ i ]
			 me.m_I += massData.I
			 r  = b2Math.SubtractVV( b2Math.AddVV(sd.localPosition, massData.center), me.m_center )
			 me.m_I += massData.mass * b2Math.b2Dot(r, r)
		next
		
		if ( me.m_mass > 0.0) then
			 me.m_invMass = 1.0 / me.m_mass
		else
			 me.m_invMass = 0.0
		if ( me.m_I > 0.0 && bd.preventRotation == false)
			 me.m_invI = 1.0 / me.m_I
		else
			 me.m_I = 0.0
			 me.m_invI = 0.0
		endif
		
		' //  Compute the center of mass velocity.
		 me.m_linearVelocity = b2Math.AddVV(bd.linearVelocity, b2Math.b2CrossFV(bd.angularVelocity, me.m_center))
		 me.m_angularVelocity = bd.angularVelocity
		 me.m_jointList = null
		 me.m_contactList = null
		 me.m_prev = null
		 me.m_next = null
		' //  Create the shapes.
		 me.m_shapeList = null
		 
		for i = 0 to  me.m_shapeCount-1
			sd = bd.shapes[i]
			shape  = b2Shape.Create(sd,me, me.m_center)

			shape.m_next = me.m_shapeList
			 me.m_shapeList = shape
		 me.m_sleepTime = 0.0
		if (bd.allowSleep) then
		''TODO Ve	 signos especiales....
			 me.m_flags |= b2Body.e_allowSleepFlag
		endif
		
		if (bd.isSleeping) then 
			 me.m_flags |= b2Body.e_sleepFlag
		endif
		if (( me.m_flags and b2Body.e_sleepFlag)  or me.m_invMass = 0.0) then 
			 me.m_linearVelocity.Set(0.0, 0.0)
			 me.m_angularVelocity = 0.0
		endif
		
		 me.m_userData = bd.userData
	
end

public  sub 	Destroy()

dim   s  as variant = me.m_shapeList
dim  s0  as variant

		while (s)
            s0  = s
			s = s.m_next
			b2Shape.Destroy(s0)
		wend
end




public  sub 	SynchronizeShapes()
		dim s as variant
		' // b2Mat22 R0( me.m_rotation0)
		 me.sMat0.Set( me.m_rotation0)
		s = me.m_shapeList
		while (s <> null)
		 s = s.m_next)
			s.Synchronize( me.m_position0, me.sMat0, me.m_position, me.m_R)
		wend
end

public  sub 	QuickSyncShapes()
dim s as  variant= me.m_shapeList
		
		while (		 s <> null)
		    s = s.m_next)
			s.QuickSync( me.m_position, me.m_R)
		wend

end


	' //  This is used to prevent connected bodies from colliding.
	' //  It may lie, depending on the collideConnected flag.
public  sub 	IsConnected(other as variant) as variant ''funcio as variant ''funcion
		dim jn as variant= me.m_jointList
		
		while ( jn <> null)
		    jn = jn.next)
			if (jn.other = other) then 
				return jn.joint.m_collideConnected == false
			endiif
		wend
		
 		return false
 
end

public  sub 	Freeze()
dim var s as variant = me.m_shapeList
		 me.m_flags |= b2Body.e_frozenFlag
		 me.m_linearVelocity.SetZero()
		 me.m_angularVelocity = 0.0
		
		while  (s <> null)
		 s = s.m_next)
			s.DestroyProxy()
		wend
end
