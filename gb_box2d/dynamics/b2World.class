
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 ' u must not    
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */



'	//--------------- Internals Below -------------------

public m_blockAllocator as variant= null
public m_stackAllocator as variant= null

public m_broadPhase as variant= null
public m_contactManager as variant= new b2ContactManager()

public m_bodyList as variant= null
public m_contactList as variant= null
public m_jointList as variant= null

public m_bodyCount as variant= 0
public m_contactCount as variant= 0
public m_jointCount as variant= 0

'// These bodies will be destroyed at the next time this.step.
public m_bodyDestroyList as variant= null

public m_gravity as variant= null
public m_allowSleep as variant= null

public m_groundBody as variant= null

public m_listener as variant= null
public m_filter as variant= null

public m_positionIterationCount AS VARIANT= 0
public s_enablePositionCorrection as variant= 1
public s_enableWarmStarting as variant = 1



public  sub _new(worldAABB as variant, gravity as variant, doSleep as variant)
dim 		 bd  as variant
		' //  initialize instance variables for references
		 me.step = new b2TimeStep()
		 me.m_contactManager = new b2ContactManager()
		' // 
		 me.m_listener = null
		 me.m_filter = b2CollisionFilter.b2_defaultFilter
		 me.m_bodyList = null
		 me.m_contactList = null
		 me.m_jointList = null
		 me.m_bodyCount = 0
		 me.m_contactCount = 0
		 me.m_jointCount = 0
		 me.m_bodyDestroyList = null
		 me.m_allowSleep = doSleep
		 me.m_gravity = gravity
		 me.m_contactManager.m_world = this
		 me.m_broadPhase = new b2BroadPhase(worldAABB, me.m_contactManager)
 		 bd = new b2BodyDef()

		 me.m_groundBody = me.CreateBody(bd)

end



	' // ~b2World()
	' // 	 me.DestroyBody( me.m_groundBody)
	' // 	delete me.m_broadPhase
	' // 
	' //  Set a callback to notify you when a joint is implicitly destroyed
	' //  when an attached body is destroyed.

public  sub 	SetListener(listener as variant)

		 me.m_listener = listener
	' //  Register a collision filter to provide specific control over collision.
	' //  Otherwise the default filter is used (b2CollisionFilter).
end

public  sub 	SetFilter(filter as variant)

		 me.m_filter = filter
	' //  Create and destroy rigid bodies. Destruction is deferred until the
	' //  the next call to me.Step. This is done so that bodies may be destroyed
	' //  while you iterate through the contact list.
end

public  sub 	CreateBody(def as variant) as variant ''funcion
		' // void* mem = me.m_blockAllocator.Allocate(sizeof(b2Body))
dim 		 b  as variant = new b2Body(def, this)

		b.m_prev = null
		b.m_next = me.m_bodyList
		if ( me.m_bodyList) then
			 me.m_bodyList.m_prev = b
		endif
		
		 me.m_bodyList = b
		me.m_bodyCount+=1
		return b
 
end


	' //  Body destruction is deferred to make contact processing more robust.
public  sub 	DestroyBody(b as variant) as variant ''funcion
		if (b.m_flags & b2Body.e_destroyFlag)
			return
		endif
		
 

		' //  Remove from normal body list.
		if (b.m_prev) then
			b.m_prev.m_next = b.m_next
		endif
		
		if (b.m_next) then
			b.m_next.m_prev = b.m_prev
		endif
		
		if (b == me.m_bodyList) then
			 me.m_bodyList = b.m_next
		endif
		''TODO: ver |=	
		b.m_flags |= b2Body.e_destroyFlag
		' // b2Settings.b2Assert( me.m_bodyCount > 0)
		 me.m_bodyCount-=1
		' // b->~b2Body()
		' // b.Destroy()
		' //  Add to the deferred destruction list.
		b.m_prev = null
		b.m_next = me.m_bodyDestroyList
		 me.m_bodyDestroyList = b
end

public  sub 	CleanBodyList()
dim 		 b  as variant
dim 			 b0  as variant
dim 			 jn  as variant 
dim 				 jn0  as variant

		 me.m_contactManager.m_destroyImmediate = true
		 b   = me.m_bodyDestroyList

		while (b)
			' // b2Settings.b2Assert((b.m_flags & b2Body.e_destroyFlag) != 0)
			' //  Preserve the next pointer.
			 b0   = b

			b = b.m_next
			' //  Delete the attached joints
			 jn   = b0.m_jointList

			while (jn)
			
				 jn0   = jn

				jn = jn.next
				if ( me.m_listener)
				
					 me.m_listener.NotifyJointDestroyed(jn0.joint)
				 endif
				 me.DestroyJoint(jn0.joint)
			wend
			
			b0.Destroy()
		wend
		
			' // me.m_blockAllocator.Free(b0, sizeof(b2Body))
		' //  Reset the list.
		 me.m_bodyDestroyList = null
		 me.m_contactManager.m_destroyImmediate = false
end

public  sub 	CreateJoint(def as variant) as variant ''funcion
dim 		 j  as variant = b2Joint.Create(def, me.m_blockAllocator)
dim 			 b  as variant 
dim  s  as variante

		' //  Connect to the world list.
		j.m_prev = null
		j.m_next = me.m_jointList
		if ( me.m_jointList)
			 me.m_jointList.m_prev = j
		 me.m_jointList = j
		++ me.m_jointCount
		' //  Connect to the bodies
		j.m_node1.joint = j
		j.m_node1.other = j.m_body2
		j.m_node1.prev = null
		j.m_node1.nextt = j.m_body1.m_jointList
		if (j.m_body1.m_jointList) then j.m_body1.m_jointList.prev = j.m_node1
		j.m_body1.m_jointList = j.m_node1
		j.m_node2.joint = j
		j.m_node2.other = j.m_body1
		j.m_node2.prev = null
		j.m_node2.nextt = j.m_body2.m_jointList
		if (j.m_body2.m_jointList)  then j.m_body2.m_jointList.prev = j.m_node2
		j.m_body2.m_jointList = j.m_node2
		' //  If the joint prevents collisions, then reset collision filtering.
		if (def.collideConnected = false) then
			' //  Reset the proxies on the body with the minimum number of shapes.
			 b   =iif() def.body1.m_shapeCount < def.body2.m_shapeCount , def.body1 , def.body2)
''TODO: IMPORTANTE esto no se como traducirlo...
		'for  s = b.m_shapeList; s; s = s.m_next)
		'			s.ResetProxy( me.m_broadPhase)
	    'next
		s=	 b.m_shapeList '¿?
		s = s.m_next	'¿?
		s.ResetProxy( me.m_broadPhase)	'¿?
			
		endif
		
		
		return j

end

public  sub 	DestroyJoint(j as variant)
dim 		 body1  as variant
dim 		 body2  as variant
dim 		 collideConnected  as variant = j.m_collideConnected
dim 			 b  as variant 
		' //  Remove from the world.
		if (j.m_prev) then 
			j.m_prev.m_next = j.m_next
		endif
		
		
		if (j.m_next) then 
			j.m_next.m_prev = j.m_prev
		endif
		
		if (j = me.m_jointList) then 
			 me.m_jointList = j.m_next
		endif
		
		' //  Disconnect from island graph.
		 body1  = j.m_body1

 		 body2   = j.m_body2

		' //  Wake up touching bodies.
		body1.WakeUp()
		body2.WakeUp()
		' //  Remove from body 1
		if (j.m_node1.prev) then 
			j.m_node1.prev.nextt = j.m_node1.nextt
		endif
		
		if (j.m_node1.nextt)
			j.m_node1.nextt.prev = j.m_node1.prev
		endif
		
		if (j.m_node1 == body1.m_jointList) then 
			body1.m_jointList = j.m_node1.nextt
		endif
		
		j.m_node1.prev = null
		j.m_node1.nextt = null
		
		' //  Remove from body 2
		if (j.m_node2.prev) then
			j.m_node2.prev.nextt = j.m_node2.nextt
		endif
		
		if (j.m_node2.nextt) then 
			j.m_node2.nextt.prev = j.m_node2.prev
		endif
		
		
		if (j.m_node2 = body2.m_jointList) then
					body2.m_jointList = j.m_node2.nextt
		endif
		
		j.m_node2.prev = null
		j.m_node2.nextt = null
		b2Joint.Destroy(j, me.m_blockAllocator)
		' // b2Settings.b2Assert( me.m_jointCount > 0)
		me.m_jointCount-=1
		' //  If the joint prevents collisions, then reset collision filtering.
		if (collideConnected = false) then 
			' //  Reset the proxies on the body with the minimum number of shapes.
		 	b  = iff(body1.m_shapeCount < body2.m_shapeCount , body1, body2)
''TODO: IMPORTANTE esto no se como traducirlo...
		'for  s = b.m_shapeList; s; s = s.m_next)
		'			s.ResetProxy( me.m_broadPhase)
	    'next
			s=	 b.m_shapeList '¿?
		s = s.m_next	'¿?
		s.ResetProxy( me.m_broadPhase)	'¿?
	' //  The world provides a single ground body with no collision shapes. You
	' //  can use this to simplify the creation of joints.
end

public  sub 	GetGroundBody() as variant ''funcion
		return me.m_groundBody
end

Public step =new  b2TimeStep()
	

public  sub 	Step(dt as variant, iterations as variant) as variant ''funcion
dim b as variant
dim other  as variant

dim 		 island  as variant
dim 		 stackSize  as variant
dim 		 stack  as variant 
dim 			 stackCount  as variant
dim 					 response  as variant
dim 	cn as variant
dim  jn as variant
dim i  as variant
dim j as variant
dim c as variant
dim b as variant
DIM K AS variant
dim seed as varaint


		 me.step.dt = dt
		 me.step.iterations	= iterations
		if (dt > 0.0) then 
			 me.step.inv_dt = 1.0 / dt
		else
			 me.step.inv_dt = 0.0
		endif
		
		 me.m_positionIterationCount = 0
		' //  Handle deferred contact destruction.
		 me.m_contactManager.CleanContactList()
		' //  Handle deferred body destruction.
		 me.CleanBodyList()
		' //  Update contacts.
		 me.m_contactManager.Collide()
		' //  Size the island for the worst case.
 		 island = new b2Island( me.m_bodyCount, me.m_contactCount, me.m_jointCount, me.m_stackAllocator)

		' //  Clear all the island flags.
		
		b = me.m_bodyList
		WHILE  (b <> null)
			b = b.m_next
			''TODO: comprobar
			b.m_flags &= ~b2Body.e_islandFlag
		WEND
		
		c = me.m_contactList
		while ( c <> null)
		    c = c.m_next
		''TODO: comprobar
			c.m_flags &= ~b2Contact.e_islandFlag
		wend
		
		
		j = me.m_jointList
		while (j <> null)
		    j = j.m_next
			j.m_islandFlag = false
		wend
		
		' //  Build and simulate all awake islands.
		 stackSize   = me.m_bodyCount

		' // var stack = (b2Body**) me.m_stackAllocator.Allocate(stackSize * sizeof(b2Body*))
		 'stack   = new Array( me.m_bodyCount)

		for  k = 0 to me.m_bodyCount-1
			stack.add(			 null)
		next
		
		seed = me.m_bodyList
		
		while sedd != null
		    seed = seed.m_next
			if (seed.m_flags and (b2Body.e_staticFlag or b2Body.e_islandFlag or b2Body.e_sleepFlag or b2Body.e_frozenFlag)) then 
				continue
			endif
			
			' //  Reset island and stack.
			island.Clear()
			 stackCount   = 0

			stackCount+=1
			stack[stackCount] = seed
			'' TODO: MIRAR este simbolo....
			seed.m_flags |= b2Body.e_islandFlag

			' //  Perform a depth first search (DFS) on the constraint graph.
			while (stackCount > 0)
				' //  Grab the next body off the stack and add it to the island.
				''--stackCount
				stackCount -=1
				b = stack[stackCount]
				island.AddBody(b)
				' //  Make sure the body is awake.
					'' TODO: MIRAR este simbolo....
				b.m_flags &= ~b2Body.e_sleepFlag
				' //  To keep islands, we don't
				' //  propagate islands across static bodies.
				if (b.m_flags and b2Body.e_staticFlag) then 
							continue
				endif
				' //  Search all contacts connected to this body.
				cn = b.m_contactList
				while  cn <> null
				    cn = cn.next
				
					if (cn.contact.m_flags and  b2Contact.e_islandFlag) then 
						continue
					endif
					
					island.AddContact(cn.contact)
						'' TODO: MIRAR este simbolo....
					cn.contact.m_flags |= b2Contact.e_islandFlag
					other = cn.other
					if (other.m_flags and  b2Body.e_islandFlag) then 
						continue
					endif
					
					' // b2Settings.b2Assert(stackCount < stackSize)
					stack[stackCount++] = other
					other.m_flags |= b2Body.e_islandFlag
				
				' //  Search all joints connect to this body.
				 jn = b.m_jointList
				 
				while jn <> null
				jn = jn.next
				
					if (jn.joint.m_islandFlag = true) then 
											continue
					endif
					
					island.AddJoint(jn.joint)
					jn.joint.m_islandFlag = true
					other = jn.other
					
					if (other.m_flags and  b2Body.e_islandFlag) then
					
						continue
					next
					' // b2Settings.b2Assert(stackCount < stackSize)
					stack[stackCount++] = other
					other.m_flags |= b2Body.e_islandFlag
				wend
			
			island.Solve( me.step, me.m_gravity)
			 me.m_positionIterationCount = b2Math.b2Max( me.m_positionIterationCount, b2Island.m_positionIterationCount)
		
			if ( me.m_allowSleep) then 
				island.UpdateSleep(dt)
			endif
			' //  Post solve cleanup.
			for i = 0 to island.m_bodyCount-1
			
				' //  Allow static bodies to participate in other islands.
				b = island.m_bodies[i]
				if (b.m_flags and b2Body.e_staticFlag) then 
				''TODO: 
					b.m_flags &= ~b2Body.e_islandFlag
				endif
				
				' //  Handle newly frozen bodies.
				if (b.IsFrozen() and me.m_listener) then 
				
					 response   = me.m_listener.NotifyBoundaryViolated(b)

					if (response = b2WorldListener.b2_destroyBody) THEN 
					
						 me.DestroyBody(b)
						b = null
						island.m_bodies[i] = null
					endif
				endif
			next	
		next			
		 me.m_broadPhase.Commit()
end


' // me.m_stackAllocator.Free(stack)
' //  me.Query the world for all shapes that potentially overlap the
' //  provided AABB. You provide a shape pointer buffer of specified
' //  size. The number of shapes found is returned. '' TODO: posible funcion (revisar)

public  sub 	Query(aabb as variant, shapes as variant, maxCount as variant) as variant ''funcion
		' // void** results = (void**) me.m_stackAllocator.Allocate(maxCount * sizeof(void*))
	dim 		 results  as new variant[]
	dim 		 count  as variant = me.m_broadPhase.QueryAABB(aabb, results, maxCount)
	dim i as integer

		for  i = 0 to count-1
			shapes[i] = results[i]
		next
		' // me.m_stackAllocator.Free(results)
	return count
end


	' //  You can use these to iterate over all the bodies, joints, and contacts.
public  sub 	GetBodyList() as variant ''funcion
		return me.m_bodyList
 end

public  sub 	GetJointList() as variant ''funcion
		return me.m_jointList
 end

public  sub 	GetContactList() as variant ''funcion
		return me.m_contactList
 end
 
