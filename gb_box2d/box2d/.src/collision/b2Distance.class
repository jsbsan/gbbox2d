' Gambas class file

' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
'you must not  
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */

' //  GJK using Voronoi regions (Christer Ericson) and region selection
' //  optimizations (Casey Muratori).
' //  The origin is either in the region of points[1] or in the edge region. The origin is
' //  not in region of points[0] because that is the old point.
' //  Possible regions:
' //  - points[2]
' //  - edge points[0]-points[2]
' //  - edge points[1]-points[2]
' //  - inside the triangle

Public g_GJK_Iterations As Integer = 0

Public Sub ProcessTwo(p1Out As Variant, p2Out As Variant, p1s As Variant, p2s As Variant, points As Variant) As Integer ''funcio as variant ''funcion
  ' //  If in point[1] region
  ' // b2Vec2 r = -points[1]
  
  Dim rX As Variant = - points[1].x
  
  Dim rY As Variant = - points[1].y
  
  ' // b2Vec2 d = points[1] - points[0]
  Dim dX As Variant = points[0].x - points[1].x
  
  Dim dY As Variant = points[0].y - points[1].y
  
  ' // float32 length = d.Normalize()
  Dim length As Variant = Math.sqrt(dX * dX + dY * dY)
  Dim lambda As Variant
  
  dX /= length
  dY /= length
  ' // float32 lambda = b2Dot(r, d)
  lambda = rX * dX + rY * dY
  
  If (lambda <= 0.0 And length < Number.MIN_VALUE) Then 
    ' //  The simplex is reduced to a point.
    ' // *p1Out = p1s[1]
    p1Out.SetV(p1s[1])
    ' // *p2Out = p2s[1]
    p2Out.SetV(p2s[1])
    ' // p1s[0] = p1s[1]
    p1s[0].SetV(p1s[1])
    ' // p2s[0] = p2s[1]
    p2s[0].SetV(p2s[1])
    points[0].SetV(points[1])
    Return 1
  Endif 
  
  ' //  Else in edge region
  lambda /= length
  ' // *p1Out = p1s[1] + lambda * (p1s[0] - p1s[1])
  p1Out.x = p1s[1].x + lambda * (p1s[0].x - p1s[1].x)
  p1Out.y = p1s[1].y + lambda * (p1s[0].y - p1s[1].y)
  ' // *p2Out = p2s[1] + lambda * (p2s[0] - p2s[1])
  p2Out.x = p2s[1].x + lambda * (p2s[0].x - p2s[1].x)
  p2Out.y = p2s[1].y + lambda * (p2s[0].y - p2s[1].y)
  Return 2
  
End

Public Sub ProcessThree(p1Out As Variant, p2Out As Variant, p1s As Variant, p2s As Variant, points As Variant) As Integer ''funcio as variant ''funcio as variant ''funcio as variant ''funcion
  ' // b2Vec2 a = points[0]
  
  Dim aX As Variant = points[0].x
  
  Dim aY As Variant = points[0].y
  
  ' // b2Vec2 b = points[1]
  Dim bX As Variant = points[1].x
  
  Dim bY As Variant = points[1].y
  
  ' // b2Vec2 c = points[2]
  Dim cX As Variant = points[2].x
  
  Dim cY As Variant = points[2].y
  
  ' // b2Vec2 ab = b - a
  Dim abX As Variant = bX - aX
  
  Dim abY As Variant = bY - aY
  
  ' // b2Vec2 ac = c - a
  Dim acX As Variant = cX - aX
  
  Dim acY As Variant = cY - aY
  
  ' // b2Vec2 bc = c - b
  Dim bcX As Variant = cX - bX
  
  Dim bcY As Variant = cY - bY
  
  ' // float32 sn = -b2Dot(a, ab), sd = b2Dot(b, ab)
  Dim sn As Variant = - (aX * abX + aY * abY)
  
  Dim sd As Variant = (bX * abX + bY * abY)
  
  ' // float32 tn = -b2Dot(a, ac), td = b2Dot(c, ac)
  Dim tn As Variant = - (aX * acX + aY * acY)
  
  Dim td As Variant = (cX * acX + cY * acY)
  
  ' // float32 un = -b2Dot(b, bc), ud = b2Dot(c, bc)
  Dim un As Variant = - (bX * bcX + bY * bcY)
  
  Dim ud As Variant = (cX * bcX + cY * bcY)
  
  Dim n As Variant
  Dim vc As Variant 
  Dim vc As Variant 
  Dim lambda As Variant 
  Dim vb As Variant
  
  Dim denom As Variant 
  Dim u As Variant
  Dim v As Variant
  Dim w As Variant
  
  ' //  In vertex c region?
  If (td <= 0.0 And ud <= 0.0) Then 
    ' //  Single point
    ' // *p1Out = p1s[2]
    p1Out.SetV(p1s[2])
    ' // *p2Out = p2s[2]
    p2Out.SetV(p2s[2])
    ' // p1s[0] = p1s[2]
    p1s[0].SetV(p1s[2])
    ' // p2s[0] = p2s[2]
    p2s[0].SetV(p2s[2])
    points[0].SetV(points[2])
    Return 1
  Endif
  
  ' //  Should not be in vertex a or b region.
  ' // b2Settings.b2Assert(sn > 0.0 || tn > 0.0)
  ' // b2Settings.b2Assert(sd > 0.0 || un > 0.0)
  ' // float32 n = b2Cross(ab, ac)
  n = abX * acY - abY * acX
  
  ' //  Should not be in edge ab region.
  ' // float32 vc = n * b2Cross(a, b)
  vc = n * (aX * bY - aY * bX)
  
  ' // b2Settings.b2Assert(vc > 0.0 || sn > 0.0 || sd > 0.0)
  ' //  In edge bc region?
  ' // float32 va = n * b2Cross(b, c)
  vc = n * (bX * cY - bY * cX)
  
  If (va <= 0.0 & & un >= 0.0 & & ud >= 0.0)
    ' // b2Settings.b2Assert(un + ud > 0.0)
    ' // float32 lambda = un / (un + ud)
    lambda = un / (un + ud)
    
    ' // *p1Out = p1s[1] + lambda * (p1s[2] - p1s[1])
    p1Out.x = p1s[1].x + lambda * (p1s[2].x - p1s[1].x)
    p1Out.y = p1s[1].y + lambda * (p1s[2].y - p1s[1].y)
    ' // *p2Out = p2s[1] + lambda * (p2s[2] - p2s[1])
    p2Out.x = p2s[1].x + lambda * (p2s[2].x - p2s[1].x)
    p2Out.y = p2s[1].y + lambda * (p2s[2].y - p2s[1].y)
    ' // p1s[0] = p1s[2]
    p1s[0].SetV(p1s[2])
    ' // p2s[0] = p2s[2]
    p2s[0].SetV(p2s[2])
    ' // points[0] = points[2]
    points[0].SetV(points[2])
    Return 2
  Endif
  ' //  In edge ac region?
  ' // float32 vb = n * b2Cross(c, a)
  vb = n * (cX * aY - cY * aX)
  
  If (vb <= 0.0 And tn >= 0.0 And td >= 0.0)
    ' // b2Settings.b2Assert(tn + td > 0.0)
    ' // float32 lambda = tn / (tn + td)
    lambda = tn / (tn + td)
    
    ' // *p1Out = p1s[0] + lambda * (p1s[2] - p1s[0])
    p1Out.x = p1s[0].x + lambda * (p1s[2].x - p1s[0].x)
    p1Out.y = p1s[0].y + lambda * (p1s[2].y - p1s[0].y)
    ' // *p2Out = p2s[0] + lambda * (p2s[2] - p2s[0])
    p2Out.x = p2s[0].x + lambda * (p2s[2].x - p2s[0].x)
    p2Out.y = p2s[0].y + lambda * (p2s[2].y - p2s[0].y)
    ' // p1s[1] = p1s[2]
    p1s[1].SetV(p1s[2])
    ' // p2s[1] = p2s[2]
    p2s[1].SetV(p2s[2])
    ' // points[1] = points[2]
    points[1].SetV(points[2])
    Return 2
  Endif
  
  '' TODO: posible funcion (revisar)
  
  ' //  Inside the triangle, compute barycentric coordinates
  ' // float32 denom = va + vb + vc
  denom = va + vb + vc
  
  ' // b2Settings.b2Assert(denom > 0.0)
  denom = 1.0 / denom
  ' // float32 u = va * denom
  u = va * denom
  
  ' // float32 v = vb * denom
  v = vb * denom
  
  ' // float32 w = 1.0f - u - v
  w = 1.0 - u - v
  
  ' // *p1Out = u * p1s[0] + v * p1s[1] + w * p1s[2]
  p1Out.x = u * p1s[0].x + v * p1s[1].x + w * p1s[2].x
  p1Out.y = u * p1s[0].y + v * p1s[1].y + w * p1s[2].y
  ' // *p2Out = u * p2s[0] + v * p2s[1] + w * p2s[2]
  p2Out.x = u * p2s[0].x + v * p2s[1].x + w * p2s[2].x
  p2Out.y = u * p2s[0].y + v * p2s[1].y + w * p2s[2].y
  Return 3
Endif

End

Public Sub InPoinsts(w As Variant, points As Variant, pointCount As Variant) As Boolean ''funcio as variant ''funcion
  
  Dim i As Integer
  
  For i = 0 To pointCount - 1
    If (w.x = points[i].x And w.y = points[i].y) Then 
      Return True
    Endif
  Next
  
  Return False
  
End

Public Sub Distance(p1Out As Variant, p2Out As Variant, shape1 As Variant, shape2 As Variant) As Variant ''funcio as variant ''funcio as variant ''funcio as variant ''funcion
  ' // b2Vec2 p1s[3], p2s[3]
  
  Dim p1s As New Variant = [Null, Null, Null]
  
  Dim p2s As New Variant = [Null, Null, Null]
  
  ' // b2Vec2 points[3]
  Dim points As New Variant = [Null, Null, Null]
  
  ' // int32 pointCount = 0
  Dim pointCount As Variant = 0
  
  Dim vSqr As Variant = 0.0
  
  Dim maxIterations As Variant = 20
  
  Dim iter As Integer
  
  Dim vX As Variant 
  Dim vY As Variant
  Dim w1 As Variant
  Dim w2 As Variant 
  Dim wX As Variant
  Dim wY As Variant 
  Dim vw As Variant 
  Dim maxSqr As Variant
  
  Dim i As Integer
  ' // *p1Out = shape1->m_position
  p1Out.SetV(shape1.m_position)
  ' // *p2Out = shape2->m_position
  p2Out.SetV(shape2.m_position)
  
  For iter = 0 To maxIterations
    ' // b2Vec2 v = *p2Out - *p1Out
    vX = p2Out.x - p1Out.x
    
    vY = p2Out.y - p1Out.y
    
    ' // b2Vec2 w1 = shape1->Support(v)
    w1 = shape1.Support(vX, vY)
    
    ' // b2Vec2 w2 = shape2->Support(-v)
    w2 = shape2.Support(- vX, - vY)
    
    ' // float32 vSqr = b2Dot(v, v)
    vSqr = (vX * vX + vY * vY)
    ' // b2Vec2 w = w2 - w1
    wX = w2.x - w1.x
    
    wY = w2.y - w1.y
    
    ' // float32 vw = b2Dot(v, w)
    vw = (vX * wX + vY * wY)
    
    ' // if (vSqr - b2Dot(v, w) <= 0.01f * vSqr)
    If (vSqr - b2Dot(vX * wX + vY * wY) <= 0.01 * vSqr)
      
      If (pointCount = 0) Then 
        
        ' // *p1Out = w1
        p1Out.SetV(w1)
        ' // *p2Out = w2
        p2Out.SetV(w2)
      Endif
      b2Distance.g_GJK_Iterations = iter
      Return Math.sqrt(vSqr)
    Endif
    
    Select Case pointCount
      Case 0
        ' // p1s[0] = w1
        p1s[0].SetV(w1)
        ' // p2s[0] = w2
        p2s[0].SetV(w2)
        points[0] = w
        ' // *p1Out = p1s[0]
        p1Out.SetV(p1s[0])
        ' // *p2Out = p2s[0]
        p2Out.SetV(p2s[0])
        + + pointCount
        Break
      Case 1
        ' // p1s[1] = w1
        p1s[1].SetV(w1)
        ' // p2s[1] = w2
        p2s[1].SetV(w2)
        ' // points[1] = w
        points[1].x = wX
        points[1].y = wY
        pointCount = b2Distance.ProcessTwo(p1Out, p2Out, p1s, p2s, points)
        Break
      Case 2
        ' // p1s[2] = w1
        p1s[2].SetV(w1)
        ' // p2s[2] = w2
        p2s[2].SetV(w2)
        ' // points[2] = w
        points[2].x = wX
        points[2].y = wY
        pointCount = b2Distance.ProcessThree(p1Out, p2Out, p1s, p2s, points)
        Break
    End Select
    ' //  If we have three points, then the origin is in the corresponding triangle.
    If (pointCount = 3) Then 
      Me.g_GJK_Iterations = iter
      Return 0.0
    Endif
    
    ' // float32 maxSqr = -FLT_MAX
    maxSqr = - Number.MAX_VALUE
    
    For i = 0 To pointCount - 1
      
      ' // maxSqr = b2Math.b2Max(maxSqr, b2Dot(points[i], points[i]))
      maxSqr = b2Math.b2Max(maxSqr, (points[i].x * points[i].x + points[i].y * points[i].y))
    Next
    
    If (pointCount = 3 Or vSqr <= 100.0 * Number.MIN_VALUE * maxSqr) Then 
      Me.g_GJK_Iterations = iter
      Return Math.sqrt(vSqr)
    Endif
    
  Next
  
  Me.g_GJK_Iterations = maxIterations
  Return sqrt(vSqr)
  
End
