' Gambas class file

' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
'you must not  
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  C = norm(p2 - p1) - L
' //  u = (p2 - p1) / norm(p2 - p1)
' //  Cdot = dot(u, v2 + cross(w2, r2) - v1 - cross(w1, r1))
' //  J = [-u -cross(r1, u) u cross(r2, u)]
' //  K = J * invM * JT
' //    = invMass1 + invI1 * cross(r1, u)^2 + invMass2 + invI2 * cross(r2, u)^2

Inherits B2Joint

Public m_localAnchor1 As New B2Vec2()
Public m_localAnchor2 As New B2Vec2()
Public m_u As New B2Vec2()
Public m_impulse As Variant = Null
Public m_mass As Variant = Null
Public m_length As Variant = Null

' // --------------- Internals Below -------------------

Public Sub _new(def As Variant)
  ' // super(def)
  
  Dim tMat As Variant
  Dim tX As Variant
  Dim tY As Variant
  ' //  The constructor for b2Joint
  ' //  initialize instance variables for references
  Me.m_node1 = New B2JointNode()
  Me.m_node2 = New B2JointNode()
  ' // 
  Me.m_type = def.type
  Me.m_prev = Null
  Me.m_next = Null
  Me.m_body1 = def.body1
  Me.m_body2 = def.body2
  Me.m_collideConnected = def.collideConnected
  Me.m_islandFlag = False
  Me.m_userData = def.userData
  ' // 
  ' //  initialize instance variables for references
  Me.m_localAnchor1 = New B2Vec2()
  Me.m_localAnchor2 = New B2Vec2()
  Me.m_u = New B2Vec2()
  ' // 
  
  ' // me.m_localAnchor1 = b2MulT( me.m_body1->m_R, def->anchorPoint1 - me.m_body1->m_position)
  tMat = Me.m_body1.m_R
  tX = def.anchorPoint1.x - Me.m_body1.m_position.x
  tY = def.anchorPoint1.y - Me.m_body1.m_position.y
  Me.m_localAnchor1.x = tX * tMat.col1.x + tY * tMat.col1.y
  Me.m_localAnchor1.y = tX * tMat.col2.x + tY * tMat.col2.y
  ' // me.m_localAnchor2 = b2MulT( me.m_body2->m_R, def->anchorPoint2 - me.m_body2->m_position)
  tMat = Me.m_body2.m_R
  tX = def.anchorPoint2.x - Me.m_body2.m_position.x
  tY = def.anchorPoint2.y - Me.m_body2.m_position.y
  Me.m_localAnchor2.x = tX * tMat.col1.x + tY * tMat.col1.y
  Me.m_localAnchor2.y = tX * tMat.col2.x + tY * tMat.col2.y
  ' // b2Vec2 d = def->anchorPoint2 - def->anchorPoint1
  tX = def.anchorPoint2.x - def.anchorPoint1.x
  tY = def.anchorPoint2.y - def.anchorPoint1.y
  ' // me.m_length = d.Length()
  Me.m_length = sqrt(tX * tX + tY * tY)
  Me.m_impulse = 0.0
  
End

Public Sub PrepareVelocitySolver()
  
  Dim length As Variant
  Dim tMat As Variant = Me.m_body1.m_R
  Dim r1X As Variant = tMat.col1.x * Me.m_localAnchor1.x + tMat.col2.x * Me.m_localAnchor1.y
  
  Dim r1Y As Variant = tMat.col1.y * Me.m_localAnchor1.x + tMat.col2.y * Me.m_localAnchor1.y
  
  Dim r2X As Variant
  Dim r2Y As Variant
  ' // b2Vec2 r2 = b2Mul( me.m_body2->m_R, me.m_localAnchor2)
  
  Dim cr1u As Variant 
  Dim cr2u As Variant
  Dim PX As Variant 
  Dim PY As Variant
  
  tMat = Me.m_body2.m_R
  r2X = tMat.col1.x * Me.m_localAnchor2.x + tMat.col2.x * Me.m_localAnchor2.y
  
  r2Y = tMat.col1.y * Me.m_localAnchor2.x + tMat.col2.y * Me.m_localAnchor2.y
  
  ' // me.m_u = me.m_body2->m_position + r2 - me.m_body1->m_position - r1
  Me.m_u.x = Me.m_body2.m_position.x + r2X - Me.m_body1.m_position.x - r1X
  Me.m_u.y = Me.m_body2.m_position.y + r2Y - Me.m_body1.m_position.y - r1Y
  ' //  Handle singularity.
  ' // float32 length = me.m_u.Length()
  length = sqrt(Me.m_u.x * Me.m_u.x + Me.m_u.y * Me.m_u.y)
  
  If (length > b2Settings.b2_linearSlop) Then
    ' // me.m_u *= 1.0 / length
    Me.m_u.Multiply(1.0 / length)
  Else
    Me.m_u.SetZero()
  Endif
  
  ' // float32 cr1u = b2Cross(r1, me.m_u)
  cr1u = (r1X * Me.m_u.y - r1Y * Me.m_u.x)
  
  ' // float32 cr2u = b2Cross(r2, me.m_u)
  cr2u = (r2X * Me.m_u.y - r2Y * Me.m_u.x)
  
  ' // me.m_mass = me.m_body1->m_invMass + me.m_body1->m_invI * cr1u * cr1u + me.m_body2->m_invMass + me.m_body2->m_invI * cr2u * cr2u
  Me.m_mass = Me.m_body1.m_invMass + Me.m_body1.m_invI * cr1u * cr1u + Me.m_body2.m_invMass + Me.m_body2.m_invI * cr2u * cr2u
  ' // b2Settings.b2Assert( me.m_mass > Number.MIN_VALUE)
  Me.m_mass = 1.0 / Me.m_mass
  If (b2World.s_enableWarmStarting) Then 
    ' // b2Vec2 P = me.m_impulse * me.m_u
    PX = Me.m_impulse * Me.m_u.x
    
    PY = Me.m_impulse * Me.m_u.y
    
    ' // me.m_body1.m_linearVelocity -= me.m_body1.m_invMass * P
    Me.m_body1.m_linearVelocity.x -= Me.m_body1.m_invMass * PX
    Me.m_body1.m_linearVelocity.y -= Me.m_body1.m_invMass * PY
    ' // me.m_body1.m_angularVelocity -= me.m_body1.m_invI * b2Cross(r1, P)
    Me.m_body1.m_angularVelocity -= Me.m_body1.m_invI * (r1X * PY - r1Y * PX)
    ' // me.m_body2.m_linearVelocity += me.m_body2.m_invMass * P
    Me.m_body2.m_linearVelocity.x += Me.m_body2.m_invMass * PX
    Me.m_body2.m_linearVelocity.y += Me.m_body2.m_invMass * PY
    ' // me.m_body2.m_angularVelocity += me.m_body2.m_invI * b2Cross(r2, P)
    Me.m_body2.m_angularVelocity += Me.m_body2.m_invI * (r2X * PY - r2Y * PX)
  Else
    Me.m_impulse = 0.0
  Endif
  
End

Public Sub SolveVelocityConstraints( Step As Variant)
  
  Dim r1X As Variant
  Dim r1Y As Variant 
  Dim tMat As Variant
  Dim r2X As Variant 
  Dim r2Y As Variant
  
  Dim r2X As Variant
  
  Dim r2Y As Variant
  Dim v1X As Variant
  Dim v1Y As Variant
  Dim v2X As Variant
  Dim v2Y As Variant
  Dim Cdot As Variant
  Dim impulse As Variant 
  Dim PX As Variant
  Dim PY As Variant
  ' // b2Vec2 r1 = b2Mul( me.m_body1->m_R, me.m_localAnchor1)
  tMat = Me.m_body1.m_R
  r1X = tMat.col1.x * Me.m_localAnchor1.x + tMat.col2.x * Me.m_localAnchor1.y
  
  r1Y = tMat.col1.y * Me.m_localAnchor1.x + tMat.col2.y * Me.m_localAnchor1.y
  
  ' // b2Vec2 r2 = b2Mul( me.m_body2->m_R, me.m_localAnchor2)
  tMat = Me.m_body2.m_R
  r2X = tMat.col1.x * Me.m_localAnchor2.x + tMat.col2.x * Me.m_localAnchor2.y
  
  r2Y = tMat.col1.y * Me.m_localAnchor2.x + tMat.col2.y * Me.m_localAnchor2.y
  
  ' //  Cdot = dot(u, v + cross(w, r))
  ' // b2Vec2 v1 = me.m_body1->m_linearVelocity + b2Cross( me.m_body1->m_angularVelocity, r1)
  v1X = Me.m_body1.m_linearVelocity.x + (- Me.m_body1.m_angularVelocity * r1Y)
  
  v1Y = Me.m_body1.m_linearVelocity.y + (Me.m_body1.m_angularVelocity * r1X)
  
  ' // b2Vec2 v2 = me.m_body2->m_linearVelocity + b2Cross( me.m_body2->m_angularVelocity, r2)
  v2X = Me.m_body2.m_linearVelocity.x + (- Me.m_body2.m_angularVelocity * r2Y)
  
  v2Y = Me.m_body2.m_linearVelocity.y + (Me.m_body2.m_angularVelocity * r2X)
  
  ' // float32 Cdot = b2Dot( me.m_u, v2 - v1)
  Cdot = (Me.m_u.x * (v2X - v1X) + Me.m_u.y * (v2Y - v1Y))
  
  ' // float32 impulse = - me.m_mass * Cdot
  impuiant = - Me.m_mass * Cdot
  
  Me.m_impulse += impulse
  ' // b2Vec2 P = impulse * me.m_u
  PX = impulse * Me.m_u.x
  
  PY = impulse * Me.m_u.y
  
  ' // me.m_body1->m_linearVelocity -= me.m_body1->m_invMass * P
  Me.m_body1.m_linearVelocity.x -= Me.m_body1.m_invMass * PX
  Me.m_body1.m_linearVelocity.y -= Me.m_body1.m_invMass * PY
  ' // me.m_body1->m_angularVelocity -= me.m_body1->m_invI * b2Cross(r1, P)
  Me.m_body1.m_angularVelocity -= Me.m_body1.m_invI * (r1X * PY - r1Y * PX)
  ' // me.m_body2->m_linearVelocity += me.m_body2->m_invMass * P
  Me.m_body2.m_linearVelocity.x += Me.m_body2.m_invMass * PX
  Me.m_body2.m_linearVelocity.y += Me.m_body2.m_invMass * PY
  ' // me.m_body2->m_angularVelocity += me.m_body2->m_invI * b2Cross(r2, P)
  Me.m_body2.m_angularVelocity += Me.m_body2.m_invI * (r2X * PY - r2Y * PX)
  
End

Public Sub SolvePositionConstraints() As Boolean ''funcion
  
  Dim tMat As Variant
  Dim r1X As Variant
  Dim r1Y As Variant 
  Dim r2X As Variant 
  Dim r2Y As Variant
  Dim dX As Variant
  Dim dY As Variant 
  Dim length As Variant
  Dim C As Variant
  
  Dim impulse As Variant
  Dim PX As Variant 
  Dim PY As Variant
  ' // b2Vec2 r1 = b2Mul( me.m_body1->m_R, me.m_localAnchor1)
  tMat = Me.m_body1.m_R
  r1X = tMat.col1.x * Me.m_localAnchor1.x + tMat.col2.x * Me.m_localAnchor1.y
  
  r1Y = tMat.col1.y * Me.m_localAnchor1.x + tMat.col2.y * Me.m_localAnchor1.y
  
  ' // b2Vec2 r2 = b2Mul( me.m_body2->m_R, me.m_localAnchor2)
  tMat = Me.m_body2.m_R
  r2X = tMat.col1.x * Me.m_localAnchor2.x + tMat.col2.x * Me.m_localAnchor2.y
  
  r2Y = tMat.col1.y * Me.m_localAnchor2.x + tMat.col2.y * Me.m_localAnchor2.y
  
  ' // b2Vec2 d = me.m_body2->m_position + r2 - me.m_body1->m_position - r1
  dX = Me.m_body2.m_position.x + r2X - Me.m_body1.m_position.x - r1X
  
  dY = Me.m_body2.m_position.y + r2Y - Me.m_body1.m_position.y - r1Y
  
  ' // float32 length = d.Normalize()
  length = sqrt(dX * dX + dY * dY)
  
  dX /= length
  dY /= length
  ' // float32 C = length - me.m_length
  C = length - Me.m_length
  
  C = b2Math.b2Clamp(C, - b2Settings.b2_maxLinearCorrection, b2Settings.b2_maxLinearCorrection)
  impulse = - Me.m_mass * C
  
  ' // me.m_u = d
  Me.m_u.Set(dX, dY)
  ' // b2Vec2 P = impulse * me.m_u
  PX = impulse * Me.m_u.x
  
  PY = impulse * Me.m_u.y
  
  ' // me.m_body1->m_position -= me.m_body1->m_invMass * P
  Me.m_body1.m_position.x -= Me.m_body1.m_invMass * PX
  Me.m_body1.m_position.y -= Me.m_body1.m_invMass * PY
  ' // me.m_body1->m_rotation -= me.m_body1->m_invI * b2Cross(r1, P)
  Me.m_body1.m_rotation -= Me.m_body1.m_invI * (r1X * PY - r1Y * PX)
  ' // me.m_body2->m_position += me.m_body2->m_invMass * P
  Me.m_body2.m_position.x += Me.m_body2.m_invMass * PX
  Me.m_body2.m_position.y += Me.m_body2.m_invMass * PY
  ' // me.m_body2->m_rotation -= me.m_body2->m_invI * b2Cross(r2, P)
  Me.m_body2.m_rotation += Me.m_body2.m_invI * (r2X * PY - r2Y * PX)
  Me.m_body1.m_R.Set(Me.m_body1.m_rotation)
  Me.m_body2.m_R.Set(Me.m_body2.m_rotation)
  Return (b2Math.b2Abs(C) < b2Settings.b2_linearSlop)
  
End

Public Sub GetAnchor1() As Variant ''funcion
  
  Return b2Math.AddVV(Me.m_body1.m_position, b2Math.b2MulMV(Me.m_body1.m_R, Me.m_localAnchor1))
  
End

Public Sub GetAnchor2() As Variant ''funcion
  
  Return b2Math.AddVV(Me.m_body2.m_position, b2Math.b2MulMV(Me.m_body2.m_R, Me.m_localAnchor2))
  
End

Public Sub GetReactionForce(invTimeStep As Variant) As B2Vec2() ''funcion
  
  Dim F As Variant = New B2Vec2()
  
  F.SetV(Me.m_u)
  F.Multiply(Me.m_impulse * invTimeStep)
  Return F
  
End

Public Sub GetReactionTorque(invTimeStep As Variant) As Float ''funcion
  ' // NOT_USED(invTimeStep)
  
  Return 0.0
Endif
