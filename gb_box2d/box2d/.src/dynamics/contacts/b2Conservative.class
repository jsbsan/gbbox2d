' Gambas class file

' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
'  you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */

Public R1 As New B2Mat22()
Public R2 As New B2Mat22()
Public x1 As New B2Vec2()
Public x2 As New B2Vec2()

Public Sub _new()
  
End

Public Sub Conservative(shape1 As Variant, shape2 As Variant) As Variant ''funcio as variant ''funcion
  
  di body1 As Variant = shape1.GetBody()
  
  Dim body2 As Variant = shape2.GetBody()
  
  ' // b2Vec2 v1 = body1->m_position - body1->m_position0
  Dim v1X As Variant = body1.m_position.x - body1.m_position0.x
  
  Dim v1Y As Variant = body1.m_position.y - body1.m_position0.y
  
  ' // float32 omega1 = body1->m_rotation - body1->m_rotation0
  Dim omega1 As Variant = body1.m_rotation - body1.m_rotation0
  
  ' // b2Vec2 v2 = body2->m_position - body2->m_position0
  Dim v2X As Variant = body2.m_position.x - body2.m_position0.x
  
  Dim v2Y As Variant = body2.m_position.y - body2.m_position0.y
  
  ' // float32 omega2 = body2->m_rotation - body2->m_rotation0
  Dim omega2 As Variant = body2.m_rotation - body2.m_rotation0
  
  ' // float32 r1 = shape1->GetMaxRadius()
  Dim r1 As Variant = shape1.GetMaxRadius()
  
  ' // float32 r2 = shape2->GetMaxRadius()
  Dim r2 As Variant = shape2.GetMaxRadius()
  
  ' // b2Vec2 p1Start = body1->m_position0
  Dim p1StartX As Variant = body1.m_position0.x
  
  Dim p1StartY As Variant = body1.m_position0.y
  
  ' // float32 a1Start = body1->m_rotation0
  Dim a1Start As Variant = body1.m_rotation0
  
  ' // b2Vec2 p2Start = body2->m_position0
  Dim p2StartX As Variant = body2.m_position0.x
  
  Dim p2StartY As Variant = body2.m_position0.y
  
  ' // float32 a2Start = body2->m_rotation0
  Dim a2Start As Variant = body2.m_rotation0
  
  ' // b2Vec2 p1 = p1Start
  Dim p1X As Variant = p1StartX
  
  Dim p1Y As Variant = p1StartY
  
  ' // float32 a1 = a1Start
  Dim a1 As Variant = a1Start
  
  ' // b2Vec2 p2 = p2Start
  Dim p2X As Variant = p2StartX
  
  Dim p2Y As Variant = p2StartY
  
  ' // float32 a2 = a2Start
  Dim a2 As Variant = a2Start
  
  ' // float32 s1 = 0.0f
  Dim s1 As Variant = 0.0
  
  ' // const int32 maxIterations = 10
  Dim maxIterations As Variant = 10
  
  ' // b2Vec2 d
  Dim dX As Variant
  Dim dY As Variant
  ' // float32 invRelativeVelocity = 0.0f
  Dim invRelativeVelocity As Variant = 0.0
  
  ' // bool hit = true
  Dim hit As Variant = True
  Dim distance As Variant
  
  Dim iter As Integer
  
  Dim dLen As Variant
  Dim relativeVelocity As Variant
  Dim ds As Variant 
  Dim s2 As Variant 
  Dim length As Variant
  
  ' // b2Mat22 b2Conservative.R1(a1), b2Conservative.R2(a2)
  b2Conservative.R1.Set(a1)
  b2Conservative.R2.Set(a2)
  ' // shape1->QuickSync(p1, b2Conservative.R1)
  shape1.QuickSync(p1, b2Conservative.R1)
  ' // shape2->QuickSync(p2, b2Conservative.R2)
  shape2.QuickSync(p2, b2Conservative.R2)
  ' // b2Vec2 b2Conservative.x1, b2Conservative.x2  moved to static var
  For iter To maxIterations
    ' //  Get the accurate distance between shapes.
    ' // float32 distance = b2Distance.Distance(&b2Conservative.x1, &b2Conservative.x2, shape1, shape2)
    distance = b2Distance.Distance(b2Conservative.x1, b2Conservative.x2, shape1, shape2)
    
    If (distance < b2Settings.b2_linearSlop) Then 
      
      If (iter == 0)
        
        hit = False
        
      Else
        
        hit = True
        
        Break
      Endif
    Endif
    
    If (iter = 0) Then 
      
      ' // b2Vec2 d = b2Conservative.x2 - b2Conservative.x1
      dX = b2Conservative.x2.x - b2Conservative.x1.x
      dY = b2Conservative.x2.y - b2Conservative.x1.y
      ' // d.Normalize()
      dLen = Math.sqrt(dX * dX + dY * dY)
      
      ' // float32 relativeVelocity = b2Dot(d, v1 - v2) + b2Abs(omega1) * r1 + b2Abs(omega2) * r2
      relativeVelocity = (dX * (v1X - v2X) + dY * (v1Y - v2Y)) + Math.abs(omega1) * r1 + Math.abs(omega2) * r2
      
      If (Math.abs(relativeVelocity) < Number.MIN_VALUE)
        
        hit = False
        Break
      Endif
      
      invRelativeVelocity = 1.0 / relativeVelocity
    Endif
    
    ' //  Get the conservative movement.
    ' // float32 ds = distance * invRelativeVelocity
    ds = distance * invRelativeVelocity
    
    ' // float32 s2 = s1 + ds
    s2 = s1 + ds
    
    If (s2 < 0.0 Or | 1.0 < s2)
      
      hit = False
      Break
    Endif
    If (s2 < (1.0 + 100.0 * Number.MIN_VALUE) * s1)
      
      hit = True
      Break
    Endif
    
    s1 = s2
    ' //  Move forward conservatively.
    ' // p1 = p1Start + s1 * v1
    p1X = p1StartX + s1 * v1.x
    p1Y = p1StartY + s1 * v1.y
    ' // a1 = a1Start + s1 * omega1
    a1 = a1Start + s1 * omega1
    ' // p2 = p2Start + s1 * v2
    p2X = p2StartX + s1 * v2.x
    p2Y = p2StartY + s1 * v2.y
    ' // a2 = a2Start + s1 * omega2
    a2 = a2Start + s1 * omega2
    b2Conservative.R1.Set(a1)
    b2Conservative.R2.Set(a2)
    shape1.QuickSync(p1, b2Conservative.R1)
    shape2.QuickSync(p2, b2Conservative.R2)
  Next
  
  If (hit) Then
    ' //  Hit, move bodies to safe position and re-sync shapes.
    ' // b2Vec2 d = b2Conservative.x2 - b2Conservative.x1
    dX = b2Conservative.x2.x - b2Conservative.x1.x
    dY = b2Conservative.x2.y - b2Conservative.x1.y
    ' // float32 length = d.Length()
    length = sqrt(dX * dX + dY * dY)
    
    If (length > FLT_EPSILON)
      
      d *= b2_linearSlop / length
    Endif
    If (body1.IsStatic()) Then 
      
      ' // body1.m_position = p1
      body1.m_position.x = p1X
      body1.m_position.y = p1Y
      
    Else
      
      ' // body1.m_position = p1 - d
      body1.m_position.x = p1X - dX
      body1.m_position.y = p1Y - dY
    Endif
    
    body1.m_rotation = a1
    body1.m_R.Set(a1)
    body1.QuickSyncShapes()
    
    If (body2.IsStatic()) Then 
      
      ' // body2->m_position = p2
      body2.m_position.x = p2X
      body2.m_position.y = p2Y
      
    Else
      
      ' // body2->m_position = p2 + d
      body2.m_position.x = p2X + dX
      body2.m_position.y = p2Y + dY
    Endif
    
    ' // body2.m_position = p2 + d
    body2.m_position.x = p2X + dX
    body2.m_position.y = p2Y + dY
    body2.m_rotation = a2
    body2.m_R.Set(a2)
    body2.QuickSyncShapes()
    Return True
  Endif
  
  ' //  No hit, restore shapes.
  shape1.QuickSync(body1.m_position, body1.m_R)
  shape2.QuickSync(body2.m_position, body2.m_R)
  Return False
  
End
