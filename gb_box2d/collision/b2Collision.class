' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2Math  as variant = Class.create()

b2Math.prototype = 
	' /* static public function b2InvSqrt(x)
		float32 xhalf = 0.5f * x
		int32 i = *(int32*)&x
		i = 0x5f3759df - (i >> 1)
		x = *(float32*)&i
		x = x * (1.5f - xhalf * x * x)
		return x
 '' TODO: posible funcion (revisar)

	*/
	' //  A * B
	' //  A^T * B
	' //  b2Math.b2Random number in range [-1,1]
	' /* inline float32 b2Math.b2Random(float32 lo, float32 hi)
		float32 r = (float32)rand()
		r /= RAND_MAX
		r = (hi - lo) * r + lo
		return r
 '' TODO: posible funcion (revisar)

	*/
	' //  "Next Largest Power of 2
	' //  Given a binary integer value x, the next largest power of 2 can be computed by a SWAR algorithm
	' //  that recursively "folds" the upper bits into the lower bits. This process yields a bit vector with
	' //  the same most significant 1, but all 1's below it. Adding 1 to that value yields the next
	' //  largest power of 2. For a 32-bit value:"
	' //  Temp vector functions to reduce calls to 'new'
	' /* static public var tempVec = new b2Vec2()
	static public var tempAABB = new b2AABB()
	*/
public  sub 	initialize()
 
public  sub b2IsValid (x as variant) as variant ''funcion
		return isFinite(x)
 '' TODO: posible funcion (revisar)

end

public  sub b2Dot (a as variant, b as variant) as variant ''funcion
		return a.x * b.x + a.y * b.y
 '' TODO: posible funcion (revisar)

end

public  sub b2CrossVV (a as variant, b as variant) as variant ''funcion
		return a.x * b.y - a.y * b.x
 '' TODO: posible funcion (revisar)

end

public  sub b2CrossVF (a as variant, s as variant) as variant ''funcion
dim 		 v  as variant = new b2Vec2(s * a.y, -s * a.x)

		return v
 '' TODO: posible funcion (revisar)

end

public  sub b2CrossFV (s as variant, a as variant) as variant ''funcion
dim 		 v  as variant = new b2Vec2(-s * a.y, s * a.x)

		return v
 '' TODO: posible funcion (revisar)

end

public  sub b2MulMV (A as variant, v as variant) as variant ''funcion
dim 		 u  as variant = new b2Vec2(A.col1.x * v.x + A.col2.x * v.y, A.col1.y * v.x + A.col2.y * v.y)

		return u
 '' TODO: posible funcion (revisar)

end

public  sub b2MulTMV (A as variant, v as variant) as variant ''funcion
dim 		 u  as variant = new b2Vec2(b2Math.b2Dot(v, A.col1), b2Math.b2Dot(v, A.col2))

		return u
 '' TODO: posible funcion (revisar)

end

public  sub AddVV (a as variant, b as variant) as variant ''funcion
dim 		 v  as variant = new b2Vec2(a.x + b.x, a.y + b.y)

		return v
 '' TODO: posible funcion (revisar)

end

public  sub SubtractVV (a as variant, b as variant) as variant ''funcion
dim 		 v  as variant = new b2Vec2(a.x - b.x, a.y - b.y)

		return v
 '' TODO: posible funcion (revisar)

end

public  sub MulFV (s as variant, a as variant) as variant ''funcion
dim 		 v  as variant = new b2Vec2(s * a.x, s * a.y)

		return v
 '' TODO: posible funcion (revisar)

end

public  sub AddMM (A as variant, B as variant) as variant ''funcion
dim 		 C  as variant = new b2Mat22(0, b2Math.AddVV(A.col1, B.col1), b2Math.AddVV(A.col2, B.col2))

		return C
 '' TODO: posible funcion (revisar)

end

public  sub b2MulMM (A as variant, B as variant) as variant ''funcion
dim 		 C  as variant = new b2Mat22(0, b2Math.b2MulMV(A, B.col1), b2Math.b2MulMV(A, B.col2))

		return C
 '' TODO: posible funcion (revisar)

end

public  sub b2MulTMM (A as variant, B as variant) as variant ''funcion
dim 		 c1  as variant = new b2Vec2(b2Math.b2Dot(A.col1, B.col1), b2Math.b2Dot(A.col2, B.col1))

dim 		 c2  as variant = new b2Vec2(b2Math.b2Dot(A.col1, B.col2), b2Math.b2Dot(A.col2, B.col2))

dim 		 C  as variant = new b2Mat22(0, c1, c2)

		return C
 '' TODO: posible funcion (revisar)

end

public  sub b2Abs (a as variant) as variant ''funcion
		return a > 0.0 ? a : -a
 '' TODO: posible funcion (revisar)

end

public  sub b2AbsV (a as variant) as variant ''funcion
dim 		 b  as variant = new b2Vec2(b2Math.b2Abs(a.x), b2Math.b2Abs(a.y))

		return b
 '' TODO: posible funcion (revisar)

end

public  sub b2AbsM (A as variant) as variant ''funcion
dim 		 B  as variant = new b2Mat22(0, b2Math.b2AbsV(A.col1), b2Math.b2AbsV(A.col2))

		return B
 '' TODO: posible funcion (revisar)

end

public  sub b2Min (a as variant, b as variant) as variant ''funcion
		return a < b ? a : b
 '' TODO: posible funcion (revisar)

end

public  sub b2MinV (a as variant, b as variant) as variant ''funcion
dim 		 c  as variant = new b2Vec2(b2Math.b2Min(a.x, b.x), b2Math.b2Min(a.y, b.y))

		return c
 '' TODO: posible funcion (revisar)

end

public  sub b2Max (a as variant, b as variant) as variant ''funcion
		return a > b ? a : b
 '' TODO: posible funcion (revisar)

end

public  sub b2MaxV (a as variant, b as variant) as variant ''funcion
dim 		 c  as variant = new b2Vec2(b2Math.b2Max(a.x, b.x), b2Math.b2Max(a.y, b.y))

		return c
 '' TODO: posible funcion (revisar)

end

public  sub b2Clamp (a as variant, low as variant, high as variant) as variant ''funcion
		return b2Math.b2Max(low, b2Math.b2Min(a, high))
 '' TODO: posible funcion (revisar)

end

public  sub b2ClampV (a as variant, low as variant, high as variant) as variant ''funcion
		return b2Math.b2MaxV(low, b2Math.b2MinV(a, high))
 '' TODO: posible funcion (revisar)

end

public  sub b2Swap (a as variant, b as variant)

dim 		 tmp  as variant = a[0]

		a[0] = b[0]
		b[0] = tmp
end

public  sub b2Random () as variant ''funcion
		return Math.random() * 2 - 1
 '' TODO: posible funcion (revisar)

end

public  sub b2NextPowerOfTwo (x as variant) as variant ''funcion
		x |= (x >> 1) & 0x7FFFFFFF
		x |= (x >> 2) & 0x3FFFFFFF
		x |= (x >> 4) & 0x0FFFFFFF
		x |= (x >> 8) & 0x00FFFFFF
		x |= (x >> 16)& 0x0000FFFF
		return x + 1
 '' TODO: posible funcion (revisar)

end

public  sub b2IsPowerOfTwo (x as variant) as variant ''funcion
dim 		 result  as variant = x > 0 && (x & (x - 1)) == 0

		return result
 '' TODO: posible funcion (revisar)

b2Math.tempVec2 = new b2Vec2()
b2Math.tempVec3 = new b2Vec2()
b2Math.tempVec4 = new b2Vec2()
b2Math.tempVec5 = new b2Vec2()
b2Math.tempMat = new b2Mat22()
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2Mat22  as variant = Class.create()

b2Mat22.prototype = 
end

public  sub 	initialize(angle as variant, c1 as variant, c2 as variant)

		if (angle==null) angle = 0
		' //  initialize instance variables for references
		 me.col1 = new b2Vec2()
		 me.col2 = new b2Vec2()
		' // 
		if (c1!=null && c2!=null)
			 me.col1.SetV(c1)
			 me.col2.SetV(c2)
		else
dim 			 c  as variant = Math.cos(angle)

dim 			 s  as variant = Math.sin(angle)

			 me.col1.x = c
 me.col2.x = -s
			 me.col1.y = s
 me.col2.y = c
end

public  sub 	Set(angle as variant)

dim 		 c  as variant = Math.cos(angle)

dim 		 s  as variant = Math.sin(angle)

		 me.col1.x = c
 me.col2.x = -s
		 me.col1.y = s
 me.col2.y = c
end

public  sub 	SetVV(c1 as variant, c2 as variant)

		 me.col1.SetV(c1)
		 me.col2.SetV(c2)
end

public  sub 	Copy() as variant ''funcion
		return new b2Mat22(0, me.col1, me.col2)
 '' TODO: posible funcion (revisar)

end

public  sub 	SetM(m as variant)

		 me.col1.SetV(m.col1)
		 me.col2.SetV(m.col2)
end

public  sub 	AddM(m as variant)

		 me.col1.x += m.col1.x
		 me.col1.y += m.col1.y
		 me.col2.x += m.col2.x
		 me.col2.y += m.col2.y
end

public  sub 	SetIdentity()

		 me.col1.x = 1.0
 me.col2.x = 0.0
		 me.col1.y = 0.0
 me.col2.y = 1.0
end

public  sub 	SetZero()

		 me.col1.x = 0.0
 me.col2.x = 0.0
		 me.col1.y = 0.0
 me.col2.y = 0.0
end

public  sub 	Invert(out as variant) as variant ''funcion
dim 		 a  as variant = me.col1.x

dim 		 b  as variant = me.col2.x

dim 		 c  as variant = me.col1.y

dim 		 d  as variant = me.col2.y

		' // var B = new b2Mat22()
dim 		 det  as variant = a * d - b * c

		' // b2Settings.b2Assert(det != 0.0)
		det = 1.0 / det
		out.col1.x =  det * d
	out.col2.x = -det * b
		out.col1.y = -det * c
	out.col2.y =  det * a
		return out
 '' TODO: posible funcion (revisar)

	' //  me.Solve A * x = b
end

public  sub 	Solve(out as variant, bX as variant, bY as variant) as variant ''funcion
		' // float32 a11 = me.col1.x, a12 = me.col2.x, a21 = me.col1.y, a22 = me.col2.y
dim 		 a11  as variant = me.col1.x

dim 		 a12  as variant = me.col2.x

dim 		 a21  as variant = me.col1.y

dim 		 a22  as variant = me.col2.y

		' // float32 det = a11 * a22 - a12 * a21
dim 		 det  as variant = a11 * a22 - a12 * a21

		' // b2Settings.b2Assert(det != 0.0)
		det = 1.0 / det
		out.x = det * (a22 * bX - a12 * bY)
		out.y = det * (a11 * bY - a21 * bX)
		return out
 '' TODO: posible funcion (revisar)

end

public  sub 	Abs()

		 me.col1.Abs()
		 me.col2.Abs()
Public 1: new b2Vec2(), as new 2Vec2(),
Public 2: new b2Vec2()
 as new 2Vec2()

﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  b2Vec2 has no constructor so that it
' //  can be placed in a union.
dim  b2Vec2  as variant = Class.create()

b2Vec2.prototype = 
end

public  sub 	initialize(x_ as variant, y_ as variant)
  me.x=x_
 me.y=y_
end

public  sub 	SetZero()
  me.x = 0.0
 me.y = 0.0
 
end

public  sub 	Set(x_ as variant, y_ as variant)
  me.x=x_
 me.y=y_
end

public  sub 	SetV(v as variant)
  me.x=v.x
 me.y=v.y
end

public  sub 	Negative()
 return new b2Vec2(- me.x, - me.y)
  '' TODO: posible funcion (revisar)

end

public  sub 	Copy() as variant ''funcion
		return new b2Vec2( me.x, me.y)
 '' TODO: posible funcion (revisar)

end

public  sub 	Add(v as variant)

		 me.x += v.x
 me.y += v.y
end

public  sub 	Subtract(v as variant)

		 me.x -= v.x
 me.y -= v.y
end

public  sub 	Multiply(a as variant)

		 me.x *= a
 me.y *= a
end

public  sub 	MulM(A as variant)

dim 		 tX  as variant = me.x

		 me.x = A.col1.x * tX + A.col2.x * me.y
		 me.y = A.col1.y * tX + A.col2.y * me.y
end

public  sub 	MulTM(A as variant)

dim 		 tX  as variant = b2Math.b2Dot(this, A.col1)

		 me.y = b2Math.b2Dot(this, A.col2)
		 me.x = tX
end

public  sub 	CrossVF(s as variant)

dim 		 tX  as variant = me.x

		 me.x = s * me.y
		 me.y = -s * tX
end

public  sub 	CrossFV(s as variant)

dim 		 tX  as variant = me.x

		 me.x = -s * me.y
		 me.y = s * tX
end

public  sub 	MinV(b as variant)

		 me.x = me.x < b.x ? me.x : b.x
		 me.y = me.y < b.y ? me.y : b.y
end

public  sub 	MaxV(b as variant)

		 me.x = me.x > b.x ? me.x : b.x
		 me.y = me.y > b.y ? me.y : b.y
end

public  sub 	Abs()

		 me.x = Math.abs( me.x)
		 me.y = Math.abs( me.y)
end

public  sub 	Length() as variant ''funcion
		return Math.sqrt( me.x * me.x + me.y * me.y)
 '' TODO: posible funcion (revisar)

end

public  sub 	Normalize() as variant ''funcio as variant ''funcion
dim 		 length  as variant = me.Length()

		if (length < Number.MIN_VALUE)
			return 0.0
 '' TODO: posible funcion (revisar)

dim 		 invLength  as variant = 1.0 / length

		 me.x *= invLength
		 me.y *= invLength
		return length
 '' TODO: posible funcion (revisar)

end

public  sub 	IsValid() as variant ''funcion
		return b2Math.b2IsValid( me.x) && b2Math.b2IsValid( me.y)
 '' TODO: posible funcion (revisar)

	x: null
	y: null
end

public  sub Make (x_ as variant, y_ as variant) as variant ''funcion
		return new b2Vec2(x_, y_)
 '' TODO: posible funcion (revisar)

﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2Settings  as variant = Class.create()

b2Settings.prototype = 
	' //  Define your unit system here. The default system is
	' //  meters-kilograms-seconds. For the tuning to work well
	' //  your dynamic objects should be bigger than a pebble and smaller
	' //  than a house.
	' // static public const b2Settings.b2_lengthUnitsPerMeter = 1.0
	' //  Use this for pixels:
	' //  Global tuning constants based on MKS units.
	' //  Collision
	' //  Dynamics
	' //  Sleep
	' //  assert
end

public  sub 	initialize()
 
b2Settings.USHRT_MAX = 0x0000ffff
b2Settings.b2_pi = Math.PI
b2Settings.b2_massUnitsPerKilogram = 1.0
b2Settings.b2_timeUnitsPerSecond = 1.0
b2Settings.b2_lengthUnitsPerMeter = 30.0
b2Settings.b2_maxManifoldPoints = 2
b2Settings.b2_maxShapesPerBody = 64
b2Settings.b2_maxPolyVertices = 8
b2Settings.b2_maxProxies = 1024
b2Settings.b2_maxPairs = 8 * b2Settings.b2_maxProxies
b2Settings.b2_linearSlop = 0.005 * b2Settings.b2_lengthUnitsPerMeter
b2Settings.b2_angularSlop = 2.0 / 180.0 * b2Settings.b2_pi
b2Settings.b2_velocityThreshold = 1.0 * b2Settings.b2_lengthUnitsPerMeter / b2Settings.b2_timeUnitsPerSecond
b2Settings.b2_maxLinearCorrection = 0.2 * b2Settings.b2_lengthUnitsPerMeter
b2Settings.b2_maxAngularCorrection = 8.0 / 180.0 * b2Settings.b2_pi
b2Settings.b2_contactBaumgarte = 0.2
b2Settings.b2_timeToSleep = 0.5 * b2Settings.b2_timeUnitsPerSecond
b2Settings.b2_linearSleepTolerance = 0.01 * b2Settings.b2_lengthUnitsPerMeter / b2Settings.b2_timeUnitsPerSecond
b2Settings.b2_angularSleepTolerance = 2.0 / 180.0 / b2Settings.b2_timeUnitsPerSecond
end

public  sub b2Assert (a as variant)

		if (!a)
dim 			nullVec
 as variant
			nullVec.x++
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2CircleDef  as variant = Class.create()

inherits , b2ShapeDef
inherits 
end

public  sub 	initialize()

		' //  The constructor for b2ShapeDef
		 me.type = b2Shape.e_unknownShape
		 me.userData = null
		 me.localPosition = new b2Vec2(0.0, 0.0)
		 me.localRotation = 0.0
		 me.friction = 0.2
		 me.restitution = 0.0
		 me.density = 0.0
		 me.categoryBits = 0x0001
		 me.maskBits = 0xFFFF
		 me.groupIndex = 0
	
		' // 
		 me.type = b2Shape.e_circleShape
		 me.radius = 1.0
	radius: null)
' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  A convex polygon. The position of the polygon (m_position) is the
' //  position of the centroid. The vertices of the incoming polygon are pre-rotated
' //  according to the local rotation. The vertices are also shifted to be centered
' //  on the centroid. Since the local rotation is absorbed into the vertex
' //  coordinates, the polygon rotation is equal to the body rotation. However
' //  the polygon position is centered on the polygon centroid. This simplifies
' //  some collision algorithms.
dim  b2PolyShape  as variant = Class.create()

inherits , b2Shape
inherits 
end

public  sub 	TestPoint(p as variant) as variant ''funcio as variant ''funcion
		' // var pLocal = b2Math.b2MulTMV( me.m_R, b2Math.SubtractVV(p, me.m_position))
dim 		 pLocal  as variant = new b2Vec2()

		pLocal.SetV(p)
		pLocal.Subtract( me.m_position)
		pLocal.MulTM( me.m_R)
		for (var i = 0; i < me.m_vertexCount; ++i)
			' // var dot = b2Math.b2Dot( me.m_normals[i], b2Math.SubtractVV(pLocal, me.m_vertices[i]))
dim 			 tVec  as variant = new b2Vec2()

			tVec.SetV(pLocal)
			tVec.Subtract( me.m_vertices[i])
dim 			 dot  as variant = b2Math.b2Dot( me.m_normals[i], tVec)

			if (dot > 0.0)
			
				return false
 '' TODO: posible funcion (revisar)

			
		return true
 '' TODO: posible funcion (revisar)

	' // --------------- Internals Below -------------------
	' //  Temp vec for b2Shape.PolyCentroid
end

public  sub 	initialize(def as variant, body as variant, newOrigin as variant)

		' //  initialize instance variables for references
		 me.m_R = new b2Mat22()
		 me.m_position = new b2Vec2()
		' // 
		' //  The constructor for b2Shape
		 me.m_userData = def.userData
		 me.m_friction = def.friction
		 me.m_restitution = def.restitution
		 me.m_body = body
		 me.m_proxyId = b2Pair.b2_nullProxy
		 me.m_maxRadius = 0.0
		 me.m_categoryBits = def.categoryBits
		 me.m_maskBits = def.maskBits
		 me.m_groupIndex = def.groupIndex
		' // 
		' //  initialize instance variables for references
		 me.syncAABB = new b2AABB()
		 me.syncMat = new b2Mat22()
		 me.m_localCentroid = new b2Vec2()
		 me.m_localOBB = new b2OBB()
		' // 
		' // super(def, body)
dim 		 i  as variant = 0

dim 		hX
 as variant
dim 		hY
 as variant
dim 		tVec
 as variant
dim 		 aabb  as variant = new b2AABB()

		' //  Vertices
		 me.m_vertices = new Array(b2Settings.b2_maxPolyVertices)
		 me.m_coreVertices = new Array(b2Settings.b2_maxPolyVertices)
		' // for (i = 0; i < b2Settings.b2_maxPolyVertices; i++)
		' // 	 me.m_vertices[i] = new b2Vec2()
		' //  Normals
		 me.m_normals = new Array(b2Settings.b2_maxPolyVertices)
		' // for (i = 0; i < b2Settings.b2_maxPolyVertices; i++)
		' // 	 me.m_normals[i] = new b2Vec2()
		' // b2Settings.b2Assert(def.type == b2Shape.e_boxShape || def.type == b2Shape.e_polyShape)
		 me.m_type = b2Shape.e_polyShape
dim 		 localR  as variant = new b2Mat22(def.localRotation)

		' //  Get the vertices transformed into the body frame.
		if (def.type == b2Shape.e_boxShape)
			' // me.m_localCentroid = def.localPosition - newOrigin
			 me.m_localCentroid.x = def.localPosition.x - newOrigin.x
			 me.m_localCentroid.y = def.localPosition.y - newOrigin.y
dim 			 box  as variant = def

			 me.m_vertexCount = 4
			hX = box.extents.x
			hY = box.extents.y
			' // hc.x = b2Max(0.0f, h.x - 2.0f * b2_linearSlop)
dim 			 hcX  as variant = Math.max(0.0, hX - 2.0 * b2Settings.b2_linearSlop)

			' // hc.y = b2Max(0.0f, h.y - 2.0f * b2_linearSlop)
dim 			 hcY  as variant = Math.max(0.0, hY - 2.0 * b2Settings.b2_linearSlop)

			' // me.m_vertices[0] = b2Mul(localR, b2Vec2(h.x, h.y))
			tVec = me.m_vertices[0] = new b2Vec2()
			tVec.x = localR.col1.x * hX + localR.col2.x * hY
			tVec.y = localR.col1.y * hX + localR.col2.y * hY
			' // me.m_vertices[1] = b2Mul(localR, b2Vec2(-h.x, h.y))
			tVec = me.m_vertices[1] = new b2Vec2()
			tVec.x = localR.col1.x * -hX + localR.col2.x * hY
			tVec.y = localR.col1.y * -hX + localR.col2.y * hY
			' // me.m_vertices[2] = b2Mul(localR, b2Vec2(-h.x, -h.y))
			tVec = me.m_vertices[2] = new b2Vec2()
			tVec.x = localR.col1.x * -hX + localR.col2.x * -hY
			tVec.y = localR.col1.y * -hX + localR.col2.y * -hY
			' // me.m_vertices[3] = b2Mul(localR, b2Vec2(h.x, -h.y))
			tVec = me.m_vertices[3] = new b2Vec2()
			tVec.x = localR.col1.x * hX + localR.col2.x * -hY
			tVec.y = localR.col1.y * hX + localR.col2.y * -hY
			' // me.m_coreVertices[0] = b2Mul(localR, b2Vec2(hc.x, hc.y))
			tVec = me.m_coreVertices[0] = new b2Vec2()
			tVec.x = localR.col1.x * hcX + localR.col2.x * hcY
			tVec.y = localR.col1.y * hcX + localR.col2.y * hcY
			' // me.m_coreVertices[1] = b2Mul(localR, b2Vec2(-hc.x, hc.y))
			tVec = me.m_coreVertices[1] = new b2Vec2()
			tVec.x = localR.col1.x * -hcX + localR.col2.x * hcY
			tVec.y = localR.col1.y * -hcX + localR.col2.y * hcY
			' // me.m_coreVertices[2] = b2Mul(localR, b2Vec2(-hc.x, -hc.y))
			tVec = me.m_coreVertices[2] = new b2Vec2()
			tVec.x = localR.col1.x * -hcX + localR.col2.x * -hcY
			tVec.y = localR.col1.y * -hcX + localR.col2.y * -hcY
			' // me.m_coreVertices[3] = b2Mul(localR, b2Vec2(hc.x, -hc.y))
			tVec = me.m_coreVertices[3] = new b2Vec2()
			tVec.x = localR.col1.x * hcX + localR.col2.x * -hcY
			tVec.y = localR.col1.y * hcX + localR.col2.y * -hcY
		else
dim 			 poly  as variant = def

			 me.m_vertexCount = poly.vertexCount
			' // b2Settings.b2Assert(3 <= me.m_vertexCount && me.m_vertexCount <= b2Settings.b2_maxPolyVertices)
			' // b2Vec2 centroid = b2Shape.PolyCentroid(poly->vertices, poly->vertexCount)
			b2Shape.PolyCentroid(poly.vertices, poly.vertexCount, b2PolyShape.tempVec)
dim 			 centroidX  as variant = b2PolyShape.tempVec.x

dim 			 centroidY  as variant = b2PolyShape.tempVec.y

			' // me.m_localCentroid = def->localPosition + b2Mul(localR, centroid) - newOrigin
			 me.m_localCentroid.x = def.localPosition.x + (localR.col1.x * centroidX + localR.col2.x * centroidY) - newOrigin.x
			 me.m_localCentroid.y = def.localPosition.y + (localR.col1.y * centroidX + localR.col2.y * centroidY) - newOrigin.y
			for (i = 0; i < me.m_vertexCount; ++i)
			
				 me.m_vertices[i] = new b2Vec2()
				 me.m_coreVertices[i] = new b2Vec2()
				' // me.m_vertices[i] = b2Mul(localR, poly->vertices[i] - centroid)
				hX = poly.vertices[i].x - centroidX
				hY = poly.vertices[i].y - centroidY
				 me.m_vertices[i].x = localR.col1.x * hX + localR.col2.x * hY
				 me.m_vertices[i].y = localR.col1.y * hX + localR.col2.y * hY
				' // b2Vec2 u = me.m_vertices[i]
dim 				 uX  as variant = me.m_vertices[i].x

dim 				 uY  as variant = me.m_vertices[i].y

				' // float32 length = u.Length()
dim 				 length  as variant = Math.sqrt(uX*uX + uY*uY)

				if (length > Number.MIN_VALUE)
				
					uX *= 1.0 / length
					uY *= 1.0 / length
				
				' // me.m_coreVertices[i] = me.m_vertices[i] - 2.0f * b2_linearSlop * u
				 me.m_coreVertices[i].x = me.m_vertices[i].x - 2.0 * b2Settings.b2_linearSlop * uX
				 me.m_coreVertices[i].y = me.m_vertices[i].y - 2.0 * b2Settings.b2_linearSlop * uY
			
		' //  Compute bounding box. TODO_ERIN optimize OBB
		' // var minVertex = new b2Vec2(Number.MAX_VALUE, Number.MAX_VALUE)
dim 		 minVertexX  as variant = Number.MAX_VALUE

dim 		 minVertexY  as variant = Number.MAX_VALUE

dim 		 maxVertexX  as variant = -Number.MAX_VALUE

dim 		 maxVertexY  as variant = -Number.MAX_VALUE

		 me.m_maxRadius = 0.0
		for (i = 0; i < me.m_vertexCount; ++i)
dim 			 v  as variant = me.m_vertices[i]

			' // minVertex = b2Math.b2MinV(minVertex, me.m_vertices[i])
			minVertexX = Math.min(minVertexX, v.x)
			minVertexY = Math.min(minVertexY, v.y)
			' // maxVertex = b2Math.b2MaxV(maxVertex, me.m_vertices[i])
			maxVertexX = Math.max(maxVertexX, v.x)
			maxVertexY = Math.max(maxVertexY, v.y)
			' // me.m_maxRadius = b2Max( me.m_maxRadius, v.Length())
			 me.m_maxRadius = Math.max( me.m_maxRadius, v.Length())
		 me.m_localOBB.R.SetIdentity()
		' // me.m_localOBB.center = 0.5 * (minVertex + maxVertex)
		 me.m_localOBB.center.Set((minVertexX + maxVertexX) * 0.5, (minVertexY + maxVertexY) * 0.5)
		' // me.m_localOBB.extents = 0.5 * (maxVertex - minVertex)
		 me.m_localOBB.extents.Set((maxVertexX - minVertexX) * 0.5, (maxVertexY - minVertexY) * 0.5)
		' //  Compute the edge normals and next index map.
dim 		 i1  as variant = 0

dim 		 i2  as variant = 0

		for (i = 0; i < me.m_vertexCount; ++i)
			 me.m_normals[i] =  new b2Vec2()
			i1 = i
			i2 = i + 1 < me.m_vertexCount ? i + 1 : 0
			' // b2Vec2 edge = me.m_vertices[i2] - me.m_vertices[i1]
			' // var edgeX = me.m_vertices[i2].x - me.m_vertices[i1].x
			' // var edgeY = me.m_vertices[i2].y - me.m_vertices[i1].y
			' // me.m_normals[i] = b2Cross(edge, 1.0f)
			 me.m_normals[i].x = me.m_vertices[i2].y - me.m_vertices[i1].y
			 me.m_normals[i].y = -( me.m_vertices[i2].x - me.m_vertices[i1].x)
			 me.m_normals[i].Normalize()
		' //  Ensure the polygon in convex. TODO_ERIN compute convex hull.
		for (i = 0; i < me.m_vertexCount; ++i)
			i1 = i
			i2 = i + 1 < me.m_vertexCount ? i + 1 : 0
			' // b2Settings.b2Assert(b2Math.b2CrossVV( me.m_normals[i1], me.m_normals[i2]) > Number.MIN_VALUE)
		 me.m_R.SetM( me.m_body.m_R)
		' // me.m_position.SetV( me.m_body.m_position  + b2Mul( me.m_body-> me.m_R, me.m_localCentroid) )
		 me.m_position.x = me.m_body.m_position.x + ( me.m_R.col1.x * me.m_localCentroid.x + me.m_R.col2.x * me.m_localCentroid.y)
		 me.m_position.y = me.m_body.m_position.y + ( me.m_R.col1.y * me.m_localCentroid.x + me.m_R.col2.y * me.m_localCentroid.y)
		' // var R = b2Math.b2MulMM( me.m_R, me.m_localOBB.R)
			' // R.col1 = b2MulMV( me.m_R, me.m_localOBB.R.col1)
			b2PolyShape.tAbsR.col1.x = me.m_R.col1.x * me.m_localOBB.R.col1.x + me.m_R.col2.x * me.m_localOBB.R.col1.y
			b2PolyShape.tAbsR.col1.y = me.m_R.col1.y * me.m_localOBB.R.col1.x + me.m_R.col2.y * me.m_localOBB.R.col1.y
			' // R.col2 = b2MulMV( me.m_R, me.m_localOBB.R.col2)
			b2PolyShape.tAbsR.col2.x = me.m_R.col1.x * me.m_localOBB.R.col2.x + me.m_R.col2.x * me.m_localOBB.R.col2.y
			b2PolyShape.tAbsR.col2.y = me.m_R.col1.y * me.m_localOBB.R.col2.x + me.m_R.col2.y * me.m_localOBB.R.col2.y
		' // var absR = b2Math.b2AbsM(R)
		b2PolyShape.tAbsR.Abs()
		' // h = b2Math.b2MulMV(b2PolyShape.tAbsR, me.m_localOBB.extents)
		hX = b2PolyShape.tAbsR.col1.x * me.m_localOBB.extents.x + b2PolyShape.tAbsR.col2.x * me.m_localOBB.extents.y
		hY = b2PolyShape.tAbsR.col1.y * me.m_localOBB.extents.x + b2PolyShape.tAbsR.col2.y * me.m_localOBB.extents.y
		' // var position = me.m_position + b2Mul( me.m_R, me.m_localOBB.center)
dim 		 positionX  as variant = me.m_position.x + ( me.m_R.col1.x * me.m_localOBB.center.x + me.m_R.col2.x * me.m_localOBB.center.y)

dim 		 positionY  as variant = me.m_position.y + ( me.m_R.col1.y * me.m_localOBB.center.x + me.m_R.col2.y * me.m_localOBB.center.y)

		' // aabb.minVertex = b2Math.SubtractVV( me.m_position, h)
		aabb.minVertex.x = positionX - hX
		aabb.minVertex.y = positionY - hY
		' // aabb.maxVertex = b2Math.AddVV( me.m_position, h)
		aabb.maxVertex.x = positionX + hX
		aabb.maxVertex.y = positionY + hY
dim 		 broadPhase  as variant = me.m_body.m_world.m_broadPhase

		if (broadPhase.InRange(aabb))
			 me.m_proxyId = broadPhase.CreateProxy(aabb, this)
		else
			 me.m_proxyId = b2Pair.b2_nullProxy
		if ( me.m_proxyId == b2Pair.b2_nullProxy)
			 me.m_body.Freeze()
	' //  Temp AABB for Synch function
Public B: new b2AABB(), as new 2AABB(),
Public t: new b2Mat22(), as new 2Mat22(),
end

public  sub 	Synchronize(position1 as variant, R1 as variant, position2 as variant, R2 as variant) as variant ''funcion
		' //  The body transform is copied for convenience.
		 me.m_R.SetM(R2)
		' // me.m_position = me.m_body-> me.m_position + b2Mul( me.m_body-> me.m_R, me.m_localCentroid)
		 me.m_position.x = me.m_body.m_position.x + (R2.col1.x * me.m_localCentroid.x + R2.col2.x * me.m_localCentroid.y)
		 me.m_position.y = me.m_body.m_position.y + (R2.col1.y * me.m_localCentroid.x + R2.col2.y * me.m_localCentroid.y)
		if ( me.m_proxyId == b2Pair.b2_nullProxy)
			return
 '' TODO: posible funcion (revisar)

		' // b2AABB aabb1, aabb2
dim 		hX
 as variant
dim 		hY
 as variant
		' // b2Mat22 obbR = b2Mul(R1, me.m_localOBB.R)
dim 			 v1  as variant = R1.col1

dim 			 v2  as variant = R1.col2

dim 			 v3  as variant = me.m_localOBB.R.col1

dim 			 v4  as variant = me.m_localOBB.R.col2

			' // me.syncMat.col1 = b2MulMV(R1, me.m_localOBB.R.col1)
			 me.syncMat.col1.x = v1.x * v3.x + v2.x * v3.y
			 me.syncMat.col1.y = v1.y * v3.x + v2.y * v3.y
			' // me.syncMat.col2 = b2MulMV(R1, me.m_localOBB.R.col2)
			 me.syncMat.col2.x = v1.x * v4.x + v2.x * v4.y
			 me.syncMat.col2.y = v1.y * v4.x + v2.y * v4.y
		' // b2Mat22 absR = b2Abs(obbR)
		 me.syncMat.Abs()
		' // b2Vec2 center = position1 + b2Mul(R1, me.m_localCentroid + me.m_localOBB.center)
		hX = me.m_localCentroid.x + me.m_localOBB.center.x
		hY = me.m_localCentroid.y + me.m_localOBB.center.y
dim 		 centerX  as variant = position1.x + (R1.col1.x * hX + R1.col2.x * hY)

dim 		 centerY  as variant = position1.y + (R1.col1.y * hX + R1.col2.y * hY)

		' // b2Vec2 h = b2Mul( me.syncMat, me.m_localOBB.extents)
		hX = me.syncMat.col1.x * me.m_localOBB.extents.x + me.syncMat.col2.x * me.m_localOBB.extents.y
		hY = me.syncMat.col1.y * me.m_localOBB.extents.x + me.syncMat.col2.y * me.m_localOBB.extents.y
		' // aabb1.minVertex = center - h
		 me.syncAABB.minVertex.x = centerX - hX
		 me.syncAABB.minVertex.y = centerY - hY
		' // aabb1.maxVertex = center + h
		 me.syncAABB.maxVertex.x = centerX + hX
		 me.syncAABB.maxVertex.y = centerY + hY
		' // b2Mat22 obbR = b2Mul(R2, me.m_localOBB.R)
			v1 = R2.col1
			v2 = R2.col2
			v3 = me.m_localOBB.R.col1
			v4 = me.m_localOBB.R.col2
			' // me.syncMat.col1 = b2MulMV(R1, me.m_localOBB.R.col1)
			 me.syncMat.col1.x = v1.x * v3.x + v2.x * v3.y
			 me.syncMat.col1.y = v1.y * v3.x + v2.y * v3.y
			' // me.syncMat.col2 = b2MulMV(R1, me.m_localOBB.R.col2)
			 me.syncMat.col2.x = v1.x * v4.x + v2.x * v4.y
			 me.syncMat.col2.y = v1.y * v4.x + v2.y * v4.y
		' // b2Mat22 absR = b2Abs(obbR)
		 me.syncMat.Abs()
		' // b2Vec2 center = position2 + b2Mul(R2, me.m_localCentroid + me.m_localOBB.center)
		hX = me.m_localCentroid.x + me.m_localOBB.center.x
		hY = me.m_localCentroid.y + me.m_localOBB.center.y
		centerX = position2.x + (R2.col1.x * hX + R2.col2.x * hY)
		centerY = position2.y + (R2.col1.y * hX + R2.col2.y * hY)
		' // b2Vec2 h = b2Mul(absR, me.m_localOBB.extents)
		hX = me.syncMat.col1.x * me.m_localOBB.extents.x + me.syncMat.col2.x * me.m_localOBB.extents.y
		hY = me.syncMat.col1.y * me.m_localOBB.extents.x + me.syncMat.col2.y * me.m_localOBB.extents.y
		' // aabb2.minVertex = center - h
		' // aabb2.maxVertex = center + h
		' // aabb.minVertex = b2Min(aabb1.minVertex, aabb2.minVertex)
		 me.syncAABB.minVertex.x = Math.min( me.syncAABB.minVertex.x, centerX - hX)
		 me.syncAABB.minVertex.y = Math.min( me.syncAABB.minVertex.y, centerY - hY)
		' // aabb.maxVertex = b2Max(aabb1.maxVertex, aabb2.maxVertex)
		 me.syncAABB.maxVertex.x = Math.max( me.syncAABB.maxVertex.x, centerX + hX)
		 me.syncAABB.maxVertex.y = Math.max( me.syncAABB.maxVertex.y, centerY + hY)
dim 		 broadPhase  as variant = me.m_body.m_world.m_broadPhase

		if (broadPhase.InRange( me.syncAABB))
			broadPhase.MoveProxy( me.m_proxyId, me.syncAABB)
		else
			 me.m_body.Freeze()
end

public  sub 	QuickSync(position as variant, R as variant)

		' // me.m_R = R
		 me.m_R.SetM(R)
		' // me.m_position = position + b2Mul(R, me.m_localCentroid)
		 me.m_position.x = position.x + (R.col1.x * me.m_localCentroid.x + R.col2.x * me.m_localCentroid.y)
		 me.m_position.y = position.y + (R.col1.y * me.m_localCentroid.x + R.col2.y * me.m_localCentroid.y)
end

public  sub 	ResetProxy(broadPhase as variant) as variant ''funcion
		if ( me.m_proxyId == b2Pair.b2_nullProxy)
			return
 '' TODO: posible funcion (revisar)

dim 		 proxy  as variant = broadPhase.GetProxy( me.m_proxyId)

		broadPhase.DestroyProxy( me.m_proxyId)
		proxy = null
dim 		 R  as variant = b2Math.b2MulMM( me.m_R, me.m_localOBB.R)

dim 		 absR  as variant = b2Math.b2AbsM(R)

dim 		 h  as variant = b2Math.b2MulMV(absR, me.m_localOBB.extents)

		' // var position = me.m_position + b2Mul( me.m_R, me.m_localOBB.center)
dim 		 position  as variant = b2Math.b2MulMV( me.m_R, me.m_localOBB.center)

		position.Add( me.m_position)
dim 		 aabb  as variant = new b2AABB()

		' // aabb.minVertex = position - h
		aabb.minVertex.SetV(position)
		aabb.minVertex.Subtract(h)
		' // aabb.maxVertex = position + h
		aabb.maxVertex.SetV(position)
		aabb.maxVertex.Add(h)
		if (broadPhase.InRange(aabb))
			 me.m_proxyId = broadPhase.CreateProxy(aabb, this)
		else
			 me.m_proxyId = b2Pair.b2_nullProxy
		if ( me.m_proxyId == b2Pair.b2_nullProxy)
			 me.m_body.Freeze()
end

public  sub 	Support(dX as variant, dY as variant, out as variant) as variant ''funcion
		' // b2Vec2 dLocal = b2MulT( me.m_R, d)
dim 		 dLocalX  as variant = (dX* me.m_R.col1.x + dY* me.m_R.col1.y)

dim 		 dLocalY  as variant = (dX* me.m_R.col2.x + dY* me.m_R.col2.y)

dim 		 bestIndex  as variant = 0

		' // float32 bestValue = b2Dot( me.m_vertices[0], dLocal)
dim 		 bestValue  as variant = ( me.m_coreVertices[0].x * dLocalX + me.m_coreVertices[0].y * dLocalY)

		for (var i = 1; i < me.m_vertexCount; ++i)
			' // float32 value = b2Dot( me.m_vertices[i], dLocal)
dim 			 value  as variant = ( me.m_coreVertices[i].x * dLocalX + me.m_coreVertices[i].y * dLocalY)

			if (value > bestValue)
			
				bestIndex = i
				bestValue = value
			
		' // return me.m_position + b2Mul( me.m_R, me.m_vertices[bestIndex])
 '' TODO: posible funcion (revisar)

		out.Set(	 me.m_position.x + ( me.m_R.col1.x * me.m_coreVertices[bestIndex].x + me.m_R.col2.x * me.m_coreVertices[bestIndex].y)
					 me.m_position.y + ( me.m_R.col1.y * me.m_coreVertices[bestIndex].x + me.m_R.col2.y * me.m_coreVertices[bestIndex].y))
	' //  Local position of the shape centroid in parent body frame.
Public d: new b2Vec2(), as new 2Vec2(),
	' //  Local position oriented bounding box. The OBB center is relative to
	' //  shape centroid.
Public B: new b2OBB(), as new 2OBB(),
	m_vertices: null
	m_coreVertices: null
	m_vertexCount: 0
	m_normals: null)
b2PolyShape.tempVec = new b2Vec2()
b2PolyShape.tAbsR = new b2Mat22()
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2PolyDef  as variant = Class.create()

inherits , b2ShapeDef
inherits 
end

public  sub 	initialize()

		' //  The constructor for b2ShapeDef
		 me.type = b2Shape.e_unknownShape
		 me.userData = null
		 me.localPosition = new b2Vec2(0.0, 0.0)
		 me.localRotation = 0.0
		 me.friction = 0.2
		 me.restitution = 0.0
		 me.density = 0.0
		 me.categoryBits = 0x0001
		 me.maskBits = 0xFFFF
		 me.groupIndex = 0
	
		' // 
		' //  initialize instance variables for references
		 me.vertices = new Array(b2Settings.b2_maxPolyVertices)
		' // 
		 me.type = b2Shape.e_polyShape
		 me.vertexCount = 0
		for (var i = 0; i < b2Settings.b2_maxPolyVertices; i++)
			 me.vertices[i] = new b2Vec2()
Public s: new Array(b2Settings.b2_maxPolyVertices), as new rray(b2Settings.b2_maxPolyVertices),
	vertexCount: 0)
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2BoxDef  as variant = Class.create()

inherits , b2ShapeDef
inherits 
end

public  sub 	initialize()

		' //  The constructor for b2ShapeDef
		 me.type = b2Shape.e_unknownShape
		 me.userData = null
		 me.localPosition = new b2Vec2(0.0, 0.0)
		 me.localRotation = 0.0
		 me.friction = 0.2
		 me.restitution = 0.0
		 me.density = 0.0
		 me.categoryBits = 0x0001
		 me.maskBits = 0xFFFF
		 me.groupIndex = 0
	
		' // 
		 me.type = b2Shape.e_boxShape
		 me.extents = new b2Vec2(1.0, 1.0)
	extents: null)
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2ShapeDef  as variant = Class.create()

b2ShapeDef.prototype = 
end

public  sub 	initialize()

		 me.type = b2Shape.e_unknownShape
		 me.userData = null
		 me.localPosition = new b2Vec2(0.0, 0.0)
		 me.localRotation = 0.0
		 me.friction = 0.2
		 me.restitution = 0.0
		 me.density = 0.0
		 me.categoryBits = 0x0001
		 me.maskBits = 0xFFFF
		 me.groupIndex = 0
	' // virtual ~b2ShapeDef() 
end

public  sub 	ComputeMass(massData as variant)

		massData.center = new b2Vec2(0.0, 0.0)
		if ( me.density == 0.0)
			massData.mass = 0.0
			massData.center.Set(0.0, 0.0)
			massData.I = 0.0
		switch ( me.type)
		case b2Shape.e_circleShape:
			
dim 				 circle  as variant = this

				massData.mass = me.density * b2Settings.b2_pi * circle.radius * circle.radius
				massData.center.Set(0.0, 0.0)
				massData.I = 0.5 * (massData.mass) * circle.radius * circle.radius
			
			break
		case b2Shape.e_boxShape:
			
dim 				 box  as variant = this

				massData.mass = 4.0 * me.density * box.extents.x * box.extents.y
				massData.center.Set(0.0, 0.0)
				massData.I = massData.mass / 3.0 * b2Math.b2Dot(box.extents, box.extents)
			
			break
		case b2Shape.e_polyShape:
			
dim 				 poly  as variant = this

				b2Shape.PolyMass(massData, poly.vertices, poly.vertexCount, me.density)
			
			break
		default:
			massData.mass = 0.0
			massData.center.Set(0.0, 0.0)
			massData.I = 0.0
			break
	type: 0
	userData: null
	localPosition: null
	localRotation: null
	friction: null
	restitution: null
	density: null
	' //  The collision category bits. Normally you would just set one bit.
	categoryBits: 0
	' //  The collision mask bits. This states the categories that this
	' //  shape would accept for collision.
	maskBits: 0
	' //  Collision groups allow a certain group of objects to never collide (negative)
	' //  or always collide (positive). Zero means no collision group. Non-zero group
	' //  filtering always wins against the mask bits.
	groupIndex: 0
' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  Shapes are created automatically when a body is created.
' //  Client code does not normally interact with shapes.
dim  b2Shape  as variant = Class.create()

b2Shape.prototype = 
end

public  sub 	TestPoint(p as variant)
return false '' TODO: posible funcion (revisar)

end

public  sub 	GetUserData()
return me.m_userData
 '' TODO: posible funcion (revisar)

end

public  sub 	GetType() as variant ''funcion
		return me.m_type
 '' TODO: posible funcion (revisar)

	' //  Get the parent body of this shape.
end

public  sub 	GetBody() as variant ''funcion
		return me.m_body
 '' TODO: posible funcion (revisar)

end

public  sub 	GetPosition() as variant ''funcion
		return me.m_position
 '' TODO: posible funcion (revisar)

end

public  sub 	GetRotationMatrix() as variant ''funcion
		return me.m_R
 '' TODO: posible funcion (revisar)

	' //  Remove and then add proxy from the broad-phase.
	' //  This is used to refresh the collision filters.
end

public  sub 	ResetProxy(broadPhase as variant)

	' //  Get the next shape in the parent body's shape list.
end

public  sub 	GetNext() as variant ''funcion
		return me.m_next
 '' TODO: posible funcion (revisar)

	' // --------------- Internals Below -------------------
end

public  sub 	initialize(def as variant, body as variant)

		' //  initialize instance variables for references
		 me.m_R = new b2Mat22()
		 me.m_position = new b2Vec2()
		' // 
		 me.m_userData = def.userData
		 me.m_friction = def.friction
		 me.m_restitution = def.restitution
		 me.m_body = body
		 me.m_proxyId = b2Pair.b2_nullProxy
		 me.m_maxRadius = 0.0
		 me.m_categoryBits = def.categoryBits
		 me.m_maskBits = def.maskBits
		 me.m_groupIndex = def.groupIndex
	' //  Internal use only. Do not call.
	' // b2Shape::~b2Shape()
	' // 
	' // 	 me.m_body->m_world->m_broadPhase-> me.DestroyProxy( me.m_proxyId)
	' // 
end

public  sub 	DestroyProxy()

		if ( me.m_proxyId != b2Pair.b2_nullProxy)
			 me.m_body.m_world.m_broadPhase.DestroyProxy( me.m_proxyId)
			 me.m_proxyId = b2Pair.b2_nullProxy
	' //  Internal use only. Do not call.
end

public  sub 	Synchronize(position1 as variant, R1 as variant, position2 as variant, R2 as variant)

end

public  sub 	QuickSync(position as variant, R as variant)

end

public  sub 	Support(dX as variant, dY as variant, out as variant)

end

public  sub 	GetMaxRadius() as variant ''funcion
		return me.m_maxRadius
 '' TODO: posible funcion (revisar)

	m_next: null
Public R: new b2Mat22(), as new 2Mat22(),
Public n: new b2Vec2(), as new 2Vec2(),
	m_type: 0
	m_userData: null
	m_body: null
	m_friction: null
	m_restitution: null
	m_maxRadius: null
	m_proxyId: 0
	m_categoryBits: 0
	m_maskBits: 0
	m_groupIndex: 0
	' //  b2ShapeType
end

public  sub Create (def as variant, body as variant, center as variant) as variant ''funcio as variant ''funcio as variant ''funcion
		switch (def.type)
		case b2Shape.e_circleShape:
			
				' // void* mem = body->m_world->m_blockAllocator.Allocate(sizeof(b2CircleShape))
				return new b2CircleShape(def, body, center)
 '' TODO: posible funcion (revisar)

			
		case b2Shape.e_boxShape:
		case b2Shape.e_polyShape:
			
				' // void* mem = body->m_world->m_blockAllocator.Allocate(sizeof(b2PolyShape))
				return new b2PolyShape(def, body, center)
 '' TODO: posible funcion (revisar)

			
		' // b2Settings.b2Assert(false)
		return null
 '' TODO: posible funcion (revisar)

end

public  sub Destroy (shape as variant)

		' /* b2BlockAllocator& allocator = shape->m_body->m_world->m_blockAllocator
		switch (shape.m_type)
		case b2Shape.e_circleShape:
			shape->~b2Shape()
			allocator.Free(shape, sizeof(b2CircleShape))
			break
		case b2Shape.e_polyShape:
			shape->~b2Shape()
			allocator.Free(shape, sizeof(b2PolyShape))
			break
		default:
			b2Assert(false)
		shape = NULL
*/
		' //  FROM DESTRUCTOR
		if (shape.m_proxyId != b2Pair.b2_nullProxy)
			shape.m_body.m_world.m_broadPhase.DestroyProxy(shape.m_proxyId)
b2Shape.e_unknownShape = -1
b2Shape.e_circleShape = 0
b2Shape.e_boxShape = 1
b2Shape.e_polyShape = 2
b2Shape.e_meshShape = 3
b2Shape.e_shapeTypeCount = 4
end

public  sub PolyMass (massData as variant, vs as variant, count as variant, rho as variant)

		' // b2Settings.b2Assert(count >= 3)
		' // var center = new b2Vec2(0.0, 0.0)
dim 		 center  as variant = new b2Vec2()

		center.SetZero()
dim 		 area  as variant = 0.0

dim 		 I  as variant = 0.0

		' //  pRef is the reference point for forming triangles.
		' //  It's location doesn't change the result (except for rounding error).
dim 		 pRef  as variant = new b2Vec2(0.0, 0.0)

dim 		 inv3  as variant = 1.0 / 3.0

		for (var i = 0; i < count; ++i)
			' //  Triangle vertices.
dim 			 p1  as variant = pRef

dim 			 p2  as variant = vs[i]

dim 			 p3  as variant = i + 1 < count ? vs[i+1] : vs[0]

dim 			 e1  as variant = b2Math.SubtractVV(p2, p1)

dim 			 e2  as variant = b2Math.SubtractVV(p3, p1)

dim 			 D  as variant = b2Math.b2CrossVV(e1, e2)

dim 			 triangleArea  as variant = 0.5 * D

			area += triangleArea
			' //  Area weighted centroid
			' //  center += triangleArea * inv3 * (p1 + p2 + p3)
dim 			 tVec  as variant = new b2Vec2()

			tVec.SetV(p1)
			tVec.Add(p2)
			tVec.Add(p3)
			tVec.Multiply(inv3*triangleArea)
			center.Add(tVec)
dim 			 px  as variant = p1.x

dim 			 py  as variant = p1.y

dim 			 ex1  as variant = e1.x

dim 			 ey1  as variant = e1.y

dim 			 ex2  as variant = e2.x

dim 			 ey2  as variant = e2.y

dim 			 intx2  as variant = inv3 * (0.25 * (ex1*ex1 + ex2*ex1 + ex2*ex2) + (px*ex1 + px*ex2)) + 0.5*px*px

dim 			 inty2  as variant = inv3 * (0.25 * (ey1*ey1 + ey2*ey1 + ey2*ey2) + (py*ey1 + py*ey2)) + 0.5*py*py

			I += D * (intx2 + inty2)
		' //  Total mass
		massData.mass = rho * area
		' //  Center of mass
		' // b2Settings.b2Assert(area > Number.MIN_VALUE)
		center.Multiply( 1.0 / area )
		massData.center = center
		' //  Inertia tensor relative to the center.
		I = rho * (I - area * b2Math.b2Dot(center, center))
		massData.I = I
end

public  sub PolyCentroid (vs as variant, count as variant, out as variant) as variant ''funcio as variant ''funcion
		' // b2Settings.b2Assert(count >= 3)
		' // b2Vec2 c
 c.Set(0.0f, 0.0f)
dim 		 cX  as variant = 0.0

dim 		 cY  as variant = 0.0

		' // float32 area = 0.0f
dim 		 area  as variant = 0.0

		' //  pRef is the reference point for forming triangles.
		' //  It's location doesn't change the result (except for rounding error).
		' // b2Vec2 pRef(0.0f, 0.0f)
dim 		 pRefX  as variant = 0.0

dim 		 pRefY  as variant = 0.0

	' /* 
		' //  This code would put the reference point inside the polygon.
		for (var i = 0; i < count; ++i)
			' // pRef += vs[i]
			pRef.x += vs[i].x
			pRef.y += vs[i].y
		pRef.x *= 1.0 / count
		pRef.y *= 1.0 / count
' 	*/
		' // const float32 inv3 = 1.0f / 3.0f
dim 		 inv3  as variant = 1.0 / 3.0

		for (var i = 0; i < count; ++i)
			' //  Triangle vertices.
			' // b2Vec2 p1 = pRef
dim 			 p1X  as variant = pRefX

dim 			 p1Y  as variant = pRefY

			' // b2Vec2 p2 = vs[i]
dim 			 p2X  as variant = vs[i].x

dim 			 p2Y  as variant = vs[i].y

			' // b2Vec2 p3 = i + 1 < count ? vs[i+1] : vs[0]
dim 			 p3X  as variant = i + 1 < count ? vs[i+1].x : vs[0].x

dim 			 p3Y  as variant = i + 1 < count ? vs[i+1].y : vs[0].y

			' // b2Vec2 e1 = p2 - p1
dim 			 e1X  as variant = p2X - p1X

dim 			 e1Y  as variant = p2Y - p1Y

			' // b2Vec2 e2 = p3 - p1
dim 			 e2X  as variant = p3X - p1X

dim 			 e2Y  as variant = p3Y - p1Y

			' // float32 D = b2Cross(e1, e2)
dim 			 D  as variant = (e1X * e2Y - e1Y * e2X)

			' // float32 triangleArea = 0.5f * D
dim 			 triangleArea  as variant = 0.5 * D

			area += triangleArea
			' //  Area weighted centroid
			' // c += triangleArea * inv3 * (p1 + p2 + p3)
			cX += triangleArea * inv3 * (p1X + p2X + p3X)
			cY += triangleArea * inv3 * (p1Y + p2Y + p3Y)
		' //  Centroid
		' // b2Settings.b2Assert(area > Number.MIN_VALUE)
		cX *= 1.0 / area
		cY *= 1.0 / area
		' //  Replace return with 'out' vector '' TODO: posible funcion (revisar)

		' // return c
 '' TODO: posible funcion (revisar)

		out.Set(cX, cY)
' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2CircleShape  as variant = Class.create()

inherits , b2Shape
inherits 
end

public  sub 	TestPoint(p as variant) as variant ''funcion
		' // var d = b2Math.SubtractVV(p, me.m_position)
dim 		 d  as variant = new b2Vec2()

		d.SetV(p)
		d.Subtract( me.m_position)
		return b2Math.b2Dot(d, d) <= me.m_radius * me.m_radius
 '' TODO: posible funcion (revisar)

	' // --------------- Internals Below -------------------
end

public  sub 	initialize(def as variant, body as variant, localCenter as variant)

		' //  initialize instance variables for references
		 me.m_R = new b2Mat22()
		 me.m_position = new b2Vec2()
		' // 
		' //  The constructor for b2Shape
		 me.m_userData = def.userData
		 me.m_friction = def.friction
		 me.m_restitution = def.restitution
		 me.m_body = body
		 me.m_proxyId = b2Pair.b2_nullProxy
		 me.m_maxRadius = 0.0
		 me.m_categoryBits = def.categoryBits
		 me.m_maskBits = def.maskBits
		 me.m_groupIndex = def.groupIndex
		' // 
		' //  initialize instance variables for references
		 me.m_localPosition = new b2Vec2()
		' // 
		' // super(def, body)
		' // b2Settings.b2Assert(def.type == b2Shape.e_circleShape)
dim 		 circle  as variant = def

		' // me.m_localPosition = def.localPosition - localCenter
		 me.m_localPosition.Set(def.localPosition.x - localCenter.x, def.localPosition.y - localCenter.y)
		 me.m_type = b2Shape.e_circleShape
		 me.m_radius = circle.radius
		 me.m_R.SetM( me.m_body.m_R)
		' // b2Vec2 r = b2Mul( me.m_body-> me.m_R, me.m_localPosition)
dim 		 rX  as variant = me.m_R.col1.x * me.m_localPosition.x + me.m_R.col2.x * me.m_localPosition.y

dim 		 rY  as variant = me.m_R.col1.y * me.m_localPosition.x + me.m_R.col2.y * me.m_localPosition.y

		' // me.m_position = me.m_body-> me.m_position + r
		 me.m_position.x = me.m_body.m_position.x + rX
		 me.m_position.y = me.m_body.m_position.y + rY
		' // me.m_maxRadius = r.Length() + me.m_radius
		 me.m_maxRadius = Math.sqrt(rX*rX+rY*rY) + me.m_radius
dim 		 aabb  as variant = new b2AABB()

		aabb.minVertex.Set( me.m_position.x - me.m_radius, me.m_position.y - me.m_radius)
		aabb.maxVertex.Set( me.m_position.x + me.m_radius, me.m_position.y + me.m_radius)
dim 		 broadPhase  as variant = me.m_body.m_world.m_broadPhase

		if (broadPhase.InRange(aabb))
			 me.m_proxyId = broadPhase.CreateProxy(aabb, this)
		else
			 me.m_proxyId = b2Pair.b2_nullProxy
		if ( me.m_proxyId == b2Pair.b2_nullProxy)
			 me.m_body.Freeze()
end

public  sub 	Synchronize(position1 as variant, R1 as variant, position2 as variant, R2 as variant) as variant ''funcion
		 me.m_R.SetM(R2)
		' // me.m_position = position2 + b2Mul(R2, me.m_localPosition)
		 me.m_position.x = (R2.col1.x * me.m_localPosition.x + R2.col2.x * me.m_localPosition.y) + position2.x
		 me.m_position.y = (R2.col1.y * me.m_localPosition.x + R2.col2.y * me.m_localPosition.y) + position2.y
		if ( me.m_proxyId == b2Pair.b2_nullProxy)
			return
 '' TODO: posible funcion (revisar)

		' //  Compute an AABB that covers the swept shape (may miss some rotation effect).
		' // b2Vec2 p1 = position1 + b2Mul(R1, me.m_localPosition)
dim 		 p1X  as variant = position1.x + (R1.col1.x * me.m_localPosition.x + R1.col2.x * me.m_localPosition.y)

dim 		 p1Y  as variant = position1.y + (R1.col1.y * me.m_localPosition.x + R1.col2.y * me.m_localPosition.y)

		' // b2Vec2 lower = b2Min(p1, me.m_position)
dim 		 lowerX  as variant = Math.min(p1X, me.m_position.x)

dim 		 lowerY  as variant = Math.min(p1Y, me.m_position.y)

		' // b2Vec2 upper = b2Max(p1, me.m_position)
dim 		 upperX  as variant = Math.max(p1X, me.m_position.x)

dim 		 upperY  as variant = Math.max(p1Y, me.m_position.y)

dim 		 aabb  as variant = new b2AABB()

		aabb.minVertex.Set(lowerX - me.m_radius, lowerY - me.m_radius)
		aabb.maxVertex.Set(upperX + me.m_radius, upperY + me.m_radius)
dim 		 broadPhase  as variant = me.m_body.m_world.m_broadPhase

		if (broadPhase.InRange(aabb))
			broadPhase.MoveProxy( me.m_proxyId, aabb)
		else
			 me.m_body.Freeze()
end

public  sub 	QuickSync(position as variant, R as variant)

		 me.m_R.SetM(R)
		' // me.m_position = position + b2Mul(R, me.m_localPosition)
		 me.m_position.x = (R.col1.x * me.m_localPosition.x + R.col2.x * me.m_localPosition.y) + position.x
		 me.m_position.y = (R.col1.y * me.m_localPosition.x + R.col2.y * me.m_localPosition.y) + position.y
end

public  sub 	ResetProxy(broadPhase as variant) as variant ''funcion
		if ( me.m_proxyId == b2Pair.b2_nullProxy)
			return
 '' TODO: posible funcion (revisar)

dim 		 proxy  as variant = broadPhase.GetProxy( me.m_proxyId)

		broadPhase.DestroyProxy( me.m_proxyId)
		proxy = null
dim 		 aabb  as variant = new b2AABB()

		aabb.minVertex.Set( me.m_position.x - me.m_radius, me.m_position.y - me.m_radius)
		aabb.maxVertex.Set( me.m_position.x + me.m_radius, me.m_position.y + me.m_radius)
		if (broadPhase.InRange(aabb))
			 me.m_proxyId = broadPhase.CreateProxy(aabb, this)
		else
			 me.m_proxyId = b2Pair.b2_nullProxy
		if ( me.m_proxyId == b2Pair.b2_nullProxy)
			 me.m_body.Freeze()
end

public  sub 	Support(dX as variant, dY as variant, out as variant) as variant ''funcion
		' // b2Vec2 u = d
		' // u.Normalize()
dim 		 len  as variant = Math.sqrt(dX*dX + dY*dY)

		dX /= len
		dY /= len
		' // return me.m_position + me.m_radius * u
 '' TODO: posible funcion (revisar)

		out.Set(	 me.m_position.x + me.m_radius*dX
					 me.m_position.y + me.m_radius*dY)
	' //  Local position in parent body
Public n: new b2Vec2(), as new 2Vec2(),
	m_radius: null)
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2MassData  as variant = Class.create()

b2MassData.prototype = 
	mass: 0.0
Public r: new b2Vec2(0,0), as new 2Vec2(0,0),
	I: 0.0
end

public  sub 	initialize()
 
		' //  initialize instance variables for references
		 me.center = new b2Vec2(0,0)
		' // 
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  The pair manager is used by the broad-phase to quickly add/remove/find pairs
' //  of overlapping proxies. It is based closely on code provided by Pierre Terdiman.
' //  http:
dim  b2Pair  as variant = Class.create()

b2Pair.prototype = 
end

public  sub 	SetBuffered()
	 me.status |= b2Pair.e_pairBuffered
 
end

public  sub 	ClearBuffered()
	 me.status &= ~b2Pair.e_pairBuffered
 
end

public  sub 	IsBuffered()
 return ( me.status & b2Pair.e_pairBuffered) == b2Pair.e_pairBuffered
  '' TODO: posible funcion (revisar)

end

public  sub 	SetRemoved()
		 me.status |= b2Pair.e_pairRemoved
 
end

public  sub 	ClearRemoved()
	 me.status &= ~b2Pair.e_pairRemoved
 
end

public  sub 	IsRemoved()
 return ( me.status & b2Pair.e_pairRemoved) == b2Pair.e_pairRemoved
  '' TODO: posible funcion (revisar)

end

public  sub 	SetFinal()
		 me.status |= b2Pair.e_pairFinal
 
end

public  sub 	IsFinal()
 return ( me.status & b2Pair.e_pairFinal) == b2Pair.e_pairFinal
  '' TODO: posible funcion (revisar)

	userData: null
	proxyId1: 0
	proxyId2: 0
	next: 0
	status: 0
	' //  STATIC
	' //  enum
end

public  sub 	initialize()
 
b2Pair.b2_nullPair = b2Settings.USHRT_MAX
b2Pair.b2_nullProxy = b2Settings.USHRT_MAX
b2Pair.b2_tableCapacity = b2Settings.b2_maxPairs
b2Pair.b2_tableMask = b2Pair.b2_tableCapacity - 1
b2Pair.e_pairBuffered = 0x0001
b2Pair.e_pairRemoved = 0x0002
b2Pair.e_pairFinal = 0x0004
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2BoundValues  as variant = Class.create()

b2BoundValues.prototype = 
	lowerValues: [0,0]
	upperValues: [0,0]
end

public  sub 	initialize()
 
		' //  initialize instance variables for references
		 me.lowerValues = [0,0]
		 me.upperValues = [0,0]
		' // 
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2BufferedPair  as variant = Class.create()

b2BufferedPair.prototype = 
	proxyId1: 0
	proxyId2: 0
end

public  sub 	initialize()
 
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  ClipVertex  as variant = Class.create()

ClipVertex.prototype = 
Public v: new b2Vec2(), as new 2Vec2(),
Public d: new b2ContactID(), as new 2ContactID(),
end

public  sub 	initialize()
 
		' //  initialize instance variables for references
		 me.v = new b2Vec2()
		 me.id = new b2ContactID()
		' // 
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  We use contact ids to facilitate warm starting.
dim  b2ContactPoint  as variant = Class.create()

b2ContactPoint.prototype = 
Public n: new b2Vec2(), as new 2Vec2(),
	separation: null
	normalImpulse: null
	tangentImpulse: null
Public d: new b2ContactID(), as new 2ContactID(),
end

public  sub 	initialize()
 
		' //  initialize instance variables for references
		 me.position = new b2Vec2()
		 me.id = new b2ContactID()
		' // 
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  A manifold for two touching convex shapes.
dim  b2AABB  as variant = Class.create()

b2AABB.prototype = 
end

public  sub 	IsValid() as variant ''funcion
		' // var d = b2Math.SubtractVV( me.maxVertex, me.minVertex)
dim 		 dX  as variant = me.maxVertex.x

dim 		 dY  as variant = me.maxVertex.y

		dX = me.maxVertex.x
		dY = me.maxVertex.y
		dX -= me.minVertex.x
		dY -= me.minVertex.y
dim 		 valid  as variant = dX >= 0.0 && dY >= 0.0

		valid = valid && me.minVertex.IsValid() && me.maxVertex.IsValid()
		return valid
 '' TODO: posible funcion (revisar)

Public x: new b2Vec2(), as new 2Vec2(),
Public x: new b2Vec2(), as new 2Vec2(),
end

public  sub 	initialize()
 
		' //  initialize instance variables for references
		 me.minVertex = new b2Vec2()
		 me.maxVertex = new b2Vec2()
		' // 
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2Proxy  as variant = Class.create()

b2Proxy.prototype = 
end

public  sub 	GetNext()
 return me.lowerBounds[0]
  '' TODO: posible funcion (revisar)

end

public  sub 	SetNext(next as variant)
  me.lowerBounds[0] = next ' /* & 0x0000ffff*/
 
end

public  sub 	IsValid()
 return me.overlapCount != b2BroadPhase.b2_invalid
  '' TODO: posible funcion (revisar)

	lowerBounds: [' /* uint*/(0), ' /* uint*/(0)]
	upperBounds: [' /* uint*/(0), ' /* uint*/(0)]
	overlapCount: 0
	timeStamp: 0
	userData: null
end

public  sub 	initialize()
 
		' //  initialize instance variables for references
		 me.lowerBounds = [' /* uint*/(0), ' /* uint*/(0)]
		 me.upperBounds = [' /* uint*/(0), ' /* uint*/(0)]
		' // 
' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2Distance  as variant = Class.create()

b2Distance.prototype = 
	' //  GJK using Voronoi regions (Christer Ericson) and region selection
	' //  optimizations (Casey Muratori).
	' //  The origin is either in the region of points[1] or in the edge region. The origin is
	' //  not in region of points[0] because that is the old point.
	' //  Possible regions:
	' //  - points[2]
	' //  - edge points[0]-points[2]
	' //  - edge points[1]-points[2]
	' //  - inside the triangle
end

public  sub 	initialize()
 
end

public  sub ProcessTwo (p1Out as variant, p2Out as variant, p1s as variant, p2s as variant, points as variant) as variant ''funcio as variant ''funcion
		' //  If in point[1] region
		' // b2Vec2 r = -points[1]
dim 		 rX  as variant = -points[1].x

dim 		 rY  as variant = -points[1].y

		' // b2Vec2 d = points[1] - points[0]
dim 		 dX  as variant = points[0].x - points[1].x

dim 		 dY  as variant = points[0].y - points[1].y

		' // float32 length = d.Normalize()
dim 		 length  as variant = Math.sqrt(dX*dX + dY*dY)

		dX /= length
		dY /= length
		' // float32 lambda = b2Dot(r, d)
dim 		 lambda  as variant = rX * dX + rY * dY

		if (lambda <= 0.0 || length < Number.MIN_VALUE)
			' //  The simplex is reduced to a point.
			' // *p1Out = p1s[1]
			p1Out.SetV(p1s[1])
			' // *p2Out = p2s[1]
			p2Out.SetV(p2s[1])
			' // p1s[0] = p1s[1]
			p1s[0].SetV(p1s[1])
			' // p2s[0] = p2s[1]
			p2s[0].SetV(p2s[1])
			points[0].SetV(points[1])
			return 1
 '' TODO: posible funcion (revisar)

		' //  Else in edge region
		lambda /= length
		' // *p1Out = p1s[1] + lambda * (p1s[0] - p1s[1])
		p1Out.x = p1s[1].x + lambda * (p1s[0].x - p1s[1].x)
		p1Out.y = p1s[1].y + lambda * (p1s[0].y - p1s[1].y)
		' // *p2Out = p2s[1] + lambda * (p2s[0] - p2s[1])
		p2Out.x = p2s[1].x + lambda * (p2s[0].x - p2s[1].x)
		p2Out.y = p2s[1].y + lambda * (p2s[0].y - p2s[1].y)
		return 2
 '' TODO: posible funcion (revisar)

end

public  sub ProcessThree (p1Out as variant, p2Out as variant, p1s as variant, p2s as variant, points as variant) as variant ''funcio as variant ''funcio as variant ''funcio as variant ''funcion
		' // b2Vec2 a = points[0]
dim 		 aX  as variant = points[0].x

dim 		 aY  as variant = points[0].y

		' // b2Vec2 b = points[1]
dim 		 bX  as variant = points[1].x

dim 		 bY  as variant = points[1].y

		' // b2Vec2 c = points[2]
dim 		 cX  as variant = points[2].x

dim 		 cY  as variant = points[2].y

		' // b2Vec2 ab = b - a
dim 		 abX  as variant = bX - aX

dim 		 abY  as variant = bY - aY

		' // b2Vec2 ac = c - a
dim 		 acX  as variant = cX - aX

dim 		 acY  as variant = cY - aY

		' // b2Vec2 bc = c - b
dim 		 bcX  as variant = cX - bX

dim 		 bcY  as variant = cY - bY

		' // float32 sn = -b2Dot(a, ab), sd = b2Dot(b, ab)
dim 		 sn  as variant = -(aX * abX + aY * abY)

dim 		 sd  as variant = (bX * abX + bY * abY)

		' // float32 tn = -b2Dot(a, ac), td = b2Dot(c, ac)
dim 		 tn  as variant = -(aX * acX + aY * acY)

dim 		 td  as variant = (cX * acX + cY * acY)

		' // float32 un = -b2Dot(b, bc), ud = b2Dot(c, bc)
dim 		 un  as variant = -(bX * bcX + bY * bcY)

dim 		 ud  as variant = (cX * bcX + cY * bcY)

		' //  In vertex c region?
		if (td <= 0.0 && ud <= 0.0)
			' //  Single point
			' // *p1Out = p1s[2]
			p1Out.SetV(p1s[2])
			' // *p2Out = p2s[2]
			p2Out.SetV(p2s[2])
			' // p1s[0] = p1s[2]
			p1s[0].SetV(p1s[2])
			' // p2s[0] = p2s[2]
			p2s[0].SetV(p2s[2])
			points[0].SetV(points[2])
			return 1
 '' TODO: posible funcion (revisar)

		' //  Should not be in vertex a or b region.
		' // b2Settings.b2Assert(sn > 0.0 || tn > 0.0)
		' // b2Settings.b2Assert(sd > 0.0 || un > 0.0)
		' // float32 n = b2Cross(ab, ac)
dim 		 n  as variant = abX * acY - abY * acX

		' //  Should not be in edge ab region.
		' // float32 vc = n * b2Cross(a, b)
dim 		 vc  as variant = n * (aX * bY - aY * bX)

		' // b2Settings.b2Assert(vc > 0.0 || sn > 0.0 || sd > 0.0)
		' //  In edge bc region?
		' // float32 va = n * b2Cross(b, c)
dim 		 va  as variant = n * (bX * cY - bY * cX)

		if (va <= 0.0 && un >= 0.0 && ud >= 0.0)
			' // b2Settings.b2Assert(un + ud > 0.0)
			' // float32 lambda = un / (un + ud)
dim 			 lambda  as variant = un / (un + ud)

			' // *p1Out = p1s[1] + lambda * (p1s[2] - p1s[1])
			p1Out.x = p1s[1].x + lambda * (p1s[2].x - p1s[1].x)
			p1Out.y = p1s[1].y + lambda * (p1s[2].y - p1s[1].y)
			' // *p2Out = p2s[1] + lambda * (p2s[2] - p2s[1])
			p2Out.x = p2s[1].x + lambda * (p2s[2].x - p2s[1].x)
			p2Out.y = p2s[1].y + lambda * (p2s[2].y - p2s[1].y)
			' // p1s[0] = p1s[2]
			p1s[0].SetV(p1s[2])
			' // p2s[0] = p2s[2]
			p2s[0].SetV(p2s[2])
			' // points[0] = points[2]
			points[0].SetV(points[2])
			return 2
 '' TODO: posible funcion (revisar)

		' //  In edge ac region?
		' // float32 vb = n * b2Cross(c, a)
dim 		 vb  as variant = n * (cX * aY - cY * aX)

		if (vb <= 0.0 && tn >= 0.0 && td >= 0.0)
			' // b2Settings.b2Assert(tn + td > 0.0)
			' // float32 lambda = tn / (tn + td)
dim 			 lambda  as variant = tn / (tn + td)

			' // *p1Out = p1s[0] + lambda * (p1s[2] - p1s[0])
			p1Out.x = p1s[0].x + lambda * (p1s[2].x - p1s[0].x)
			p1Out.y = p1s[0].y + lambda * (p1s[2].y - p1s[0].y)
			' // *p2Out = p2s[0] + lambda * (p2s[2] - p2s[0])
			p2Out.x = p2s[0].x + lambda * (p2s[2].x - p2s[0].x)
			p2Out.y = p2s[0].y + lambda * (p2s[2].y - p2s[0].y)
			' // p1s[1] = p1s[2]
			p1s[1].SetV(p1s[2])
			' // p2s[1] = p2s[2]
			p2s[1].SetV(p2s[2])
			' // points[1] = points[2]
			points[1].SetV(points[2])
			return 2
 '' TODO: posible funcion (revisar)

		' //  Inside the triangle, compute barycentric coordinates
		' // float32 denom = va + vb + vc
dim 		 denom  as variant = va + vb + vc

		' // b2Settings.b2Assert(denom > 0.0)
		denom = 1.0 / denom
		' // float32 u = va * denom
dim 		 u  as variant = va * denom

		' // float32 v = vb * denom
dim 		 v  as variant = vb * denom

		' // float32 w = 1.0f - u - v
dim 		 w  as variant = 1.0 - u - v

		' // *p1Out = u * p1s[0] + v * p1s[1] + w * p1s[2]
		p1Out.x = u * p1s[0].x + v * p1s[1].x + w * p1s[2].x
		p1Out.y = u * p1s[0].y + v * p1s[1].y + w * p1s[2].y
		' // *p2Out = u * p2s[0] + v * p2s[1] + w * p2s[2]
		p2Out.x = u * p2s[0].x + v * p2s[1].x + w * p2s[2].x
		p2Out.y = u * p2s[0].y + v * p2s[1].y + w * p2s[2].y
		return 3
 '' TODO: posible funcion (revisar)

end

public  sub InPoinsts (w as variant, points as variant, pointCount as variant) as variant ''funcio as variant ''funcion
		for (var i = 0; i < pointCount; ++i)
			if (w.x == points[i].x && w.y == points[i].y)
			
				return true
 '' TODO: posible funcion (revisar)

			
		return false
 '' TODO: posible funcion (revisar)

end

public  sub Distance (p1Out as variant, p2Out as variant, shape1 as variant, shape2 as variant) as variant ''funcio as variant ''funcio as variant ''funcio as variant ''funcio as variant ''funcion
		' // b2Vec2 p1s[3], p2s[3]
dim 		 p1s  as variant = new Array(3)

dim 		 p2s  as variant = new Array(3)

		' // b2Vec2 points[3]
dim 		 points  as variant = new Array(3)

		' // int32 pointCount = 0
dim 		 pointCount  as variant = 0

		' // *p1Out = shape1->m_position
		p1Out.SetV(shape1.m_position)
		' // *p2Out = shape2->m_position
		p2Out.SetV(shape2.m_position)
dim 		 vSqr  as variant = 0.0

dim 		 maxIterations  as variant = 20

		for (var iter = 0; iter < maxIterations; ++iter)
			' // b2Vec2 v = *p2Out - *p1Out
dim 			 vX  as variant = p2Out.x - p1Out.x

dim 			 vY  as variant = p2Out.y - p1Out.y

			' // b2Vec2 w1 = shape1->Support(v)
dim 			 w1  as variant = shape1.Support(vX, vY)

			' // b2Vec2 w2 = shape2->Support(-v)
dim 			 w2  as variant = shape2.Support(-vX, -vY)

			' // float32 vSqr = b2Dot(v, v)
			vSqr = (vX*vX + vY*vY)
			' // b2Vec2 w = w2 - w1
dim 			 wX  as variant = w2.x - w1.x

dim 			 wY  as variant = w2.y - w1.y

			' // float32 vw = b2Dot(v, w)
dim 			 vw  as variant = (vX*wX + vY*wY)

			' // if (vSqr - b2Dot(v, w) <= 0.01f * vSqr)
			if (vSqr - b2Dot(vX * wX + vY * wY) <= 0.01 * vSqr)
			
				if (pointCount == 0)
				
					' // *p1Out = w1
					p1Out.SetV(w1)
					' // *p2Out = w2
					p2Out.SetV(w2)
				
				b2Distance.g_GJK_Iterations = iter
				return Math.sqrt(vSqr)
 '' TODO: posible funcion (revisar)

			
			switch (pointCount)
			
			case 0:
				' // p1s[0] = w1
				p1s[0].SetV(w1)
				' // p2s[0] = w2
				p2s[0].SetV(w2)
				points[0] = w
				' // *p1Out = p1s[0]
				p1Out.SetV(p1s[0])
				' // *p2Out = p2s[0]
				p2Out.SetV(p2s[0])
				++pointCount
				break
			case 1:
				' // p1s[1] = w1
				p1s[1].SetV(w1)
				' // p2s[1] = w2
				p2s[1].SetV(w2)
				' // points[1] = w
				points[1].x = wX
				points[1].y = wY
				pointCount = b2Distance.ProcessTwo(p1Out, p2Out, p1s, p2s, points)
				break
			case 2:
				' // p1s[2] = w1
				p1s[2].SetV(w1)
				' // p2s[2] = w2
				p2s[2].SetV(w2)
				' // points[2] = w
				points[2].x = wX
				points[2].y = wY
				pointCount = b2Distance.ProcessThree(p1Out, p2Out, p1s, p2s, points)
				break
			
			' //  If we have three points, then the origin is in the corresponding triangle.
			if (pointCount == 3)
			
				b2Distance.g_GJK_Iterations = iter
				return 0.0
 '' TODO: posible funcion (revisar)

			
			' // float32 maxSqr = -FLT_MAX
dim 			 maxSqr  as variant = -Number.MAX_VALUE

			for (var i = 0; i < pointCount; ++i)
			
				' // maxSqr = b2Math.b2Max(maxSqr, b2Dot(points[i], points[i]))
				maxSqr = b2Math.b2Max(maxSqr, (points[i].x*points[i].x + points[i].y*points[i].y))
			
			if (pointCount == 3 || vSqr <= 100.0 * Number.MIN_VALUE * maxSqr)
			
				b2Distance.g_GJK_Iterations = iter
				return Math.sqrt(vSqr)
 '' TODO: posible funcion (revisar)

			
		b2Distance.g_GJK_Iterations = maxIterations
		return Math.sqrt(vSqr)
 '' TODO: posible funcion (revisar)

b2Distance.g_GJK_Iterations = 0
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2PairCallback  as variant = Class.create()

b2PairCallback.prototype = 
	' // virtual ~b2PairCallback() 
	' //  This returns the new pair user data. '' TODO: posible funcion (revisar)

end

public  sub 	PairAdded(proxyUserData1 as variant, proxyUserData2 as variant)
return null '' TODO: posible funcion (revisar)

	' //  This should free the pair's user data. In extreme circumstances, it is possible
	' //  this will be called with null pairUserData because the pair never existed.
end

public  sub 	PairRemoved(proxyUserData1 as variant, proxyUserData2 as variant, pairUserData as variant)

end

public  sub 	initialize()
 
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  A manifold for two touching convex shapes.
dim  b2OBB  as variant = Class.create()

b2OBB.prototype = 
Public R: new b2Mat22(), as new 2Mat22(),
Public r: new b2Vec2(), as new 2Vec2(),
Public s: new b2Vec2(), as new 2Vec2(),
end

public  sub 	initialize()
 
		' //  initialize instance variables for references
		 me.R = new b2Mat22()
		 me.center = new b2Vec2()
		 me.extents = new b2Vec2()
		' // 
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2Bound  as variant = Class.create()

b2Bound.prototype = 
end

public  sub 	IsLower()
 return ( me.value & 1) == 0
  '' TODO: posible funcion (revisar)

end

public  sub 	IsUpper()
 return ( me.value & 1) == 1
  '' TODO: posible funcion (revisar)

end

public  sub 	Swap(b as variant)

dim 		 tempValue  as variant = me.value

dim 		 tempProxyId  as variant = me.proxyId

dim 		 tempStabbingCount  as variant = me.stabbingCount

		 me.value = b.value
		 me.proxyId = b.proxyId
		 me.stabbingCount = b.stabbingCount
		b.value = tempValue
		b.proxyId = tempProxyId
		b.stabbingCount = tempStabbingCount
	value: 0
	proxyId: 0
	stabbingCount: 0
end

public  sub 	initialize()
 
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  A manifold for two touching convex shapes.
dim  b2Manifold  as variant = Class.create()

b2Manifold.prototype = 
end

public  sub 	initialize()

		 me.points = new Array(b2Settings.b2_maxManifoldPoints)
		for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++)
			 me.points[i] = new b2ContactPoint()
		 me.normal = new b2Vec2()
	points: null
	normal: null
	pointCount: 0
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  The pair manager is used by the broad-phase to quickly add/remove/find pairs
' //  of overlapping proxies. It is based closely on code provided by Pierre Terdiman.
' //  http:
dim  b2PairManager  as variant = Class.create()

b2PairManager.prototype = 
' // public:
end

public  sub 	initialize()

dim 		 i  as variant = 0

		' // b2Settings.b2Assert(b2Math.b2IsPowerOfTwo(b2Pair.b2_tableCapacity) == true)
		' // b2Settings.b2Assert(b2Pair.b2_tableCapacity >= b2Settings.b2_maxPairs)
		 me.m_hashTable = new Array(b2Pair.b2_tableCapacity)
		for (i = 0; i < b2Pair.b2_tableCapacity; ++i)
			 me.m_hashTable[i] = b2Pair.b2_nullPair
		 me.m_pairs = new Array(b2Settings.b2_maxPairs)
		for (i = 0; i < b2Settings.b2_maxPairs; ++i)
			 me.m_pairs[i] = new b2Pair()
		 me.m_pairBuffer = new Array(b2Settings.b2_maxPairs)
		for (i = 0; i < b2Settings.b2_maxPairs; ++i)
			 me.m_pairBuffer[i] = new b2BufferedPair()
		for (i = 0; i < b2Settings.b2_maxPairs; ++i)
			 me.m_pairs[i].proxyId1 = b2Pair.b2_nullProxy
			 me.m_pairs[i].proxyId2 = b2Pair.b2_nullProxy
			 me.m_pairs[i].userData = null
			 me.m_pairs[i].status = 0
			 me.m_pairs[i].next = (i + 1)
		 me.m_pairs[b2Settings.b2_maxPairs-1].next = b2Pair.b2_nullPair
		 me.m_pairCount = 0
	' // ~b2PairManager()
end

public  sub 	Initialize(broadPhase as variant, callback as variant)

		 me.m_broadPhase = broadPhase
		 me.m_callback = callback
	' /* 
	As proxies are created and moved, many pairs are created and destroyed. Even worse, the same
	pair may be added and removed multiple times in a single time step of the physics engine. To reduce
	traffic in the pair manager, we try to avoid destroying pairs in the pair manager until the
	end of the physics step. This is done by buffering all the me.RemovePair requests. me.AddPair
	requests are processed immediately because we need the hash table entry for quick lookup.
	All user user callbacks are delayed until the buffered pairs are confirmed in me.Commit.
	This is very important because the user callbacks may be very expensive and client logic
	may be harmed if pairs are added and removed within the same time step.
	Buffer a pair for addition.
	We may add a pair that is not in the pair manager or pair buffer.
	We may add a pair that is already in the pair manager and pair buffer.
	If the added pair is not a new pair, then it must be in the pair buffer (because me.RemovePair was called).
' 	*/
end

public  sub 	AddBufferedPair(proxyId1 as variant, proxyId2 as variant)

		' // b2Settings.b2Assert(id1 != b2_nullProxy && id2 != b2_nullProxy)
		' // b2Settings.b2Assert( me.m_pairBufferCount < b2_maxPairs)
dim 		 pair  as variant = me.AddPair(proxyId1, proxyId2)

		' //  If this pair is not in the pair buffer ...
		if (pair.IsBuffered() == false)
			' //  This must be a newly added pair.
			' // b2Settings.b2Assert(pair.IsFinal() == false)
			' //  Add it to the pair buffer.
			pair.SetBuffered()
			 me.m_pairBuffer[ me.m_pairBufferCount].proxyId1 = pair.proxyId1
			 me.m_pairBuffer[ me.m_pairBufferCount].proxyId2 = pair.proxyId2
			++ me.m_pairBufferCount
			' // b2Settings.b2Assert( me.m_pairBufferCount <= me.m_pairCount)
		' //  Confirm this pair for the subsequent call to me.Commit.
		pair.ClearRemoved()
		if (b2BroadPhase.s_validate)
			 me.ValidateBuffer()
	' //  Buffer a pair for removal.
end

public  sub 	RemoveBufferedPair(proxyId1 as variant, proxyId2 as variant) as variant ''funcion
		' // b2Settings.b2Assert(id1 != b2_nullProxy && id2 != b2_nullProxy)
		' // b2Settings.b2Assert( me.m_pairBufferCount < b2_maxPairs)
dim 		 pair  as variant = me.Find(proxyId1, proxyId2)

		if (pair == null)
			' //  The pair never existed. This is legal (due to collision filtering).
			return
 '' TODO: posible funcion (revisar)

		' //  If this pair is not in the pair buffer ...
		if (pair.IsBuffered() == false)
			' //  This must be an old pair.
			' // b2Settings.b2Assert(pair.IsFinal() == true)
			pair.SetBuffered()
			 me.m_pairBuffer[ me.m_pairBufferCount].proxyId1 = pair.proxyId1
			 me.m_pairBuffer[ me.m_pairBufferCount].proxyId2 = pair.proxyId2
			++ me.m_pairBufferCount
			' // b2Settings.b2Assert( me.m_pairBufferCount <= me.m_pairCount)
		pair.SetRemoved()
		if (b2BroadPhase.s_validate)
			 me.ValidateBuffer()
end

public  sub 	Commit() as variant ''funcio as variant ''funcion
dim 		 i  as variant = 0

dim 		 removeCount  as variant = 0

dim 		 proxies  as variant = me.m_broadPhase.m_proxyPool

		for (i = 0; i < me.m_pairBufferCount; ++i)
dim 			 pair  as variant = me.Find( me.m_pairBuffer[i].proxyId1, me.m_pairBuffer[i].proxyId2)

			' // b2Settings.b2Assert(pair.IsBuffered())
			pair.ClearBuffered()
			' // b2Settings.b2Assert(pair.proxyId1 < b2Settings.b2_maxProxies && pair.proxyId2 < b2Settings.b2_maxProxies)
dim 			 proxy1  as variant = proxies[ pair.proxyId1 ]

dim 			 proxy2  as variant = proxies[ pair.proxyId2 ]

			' // b2Settings.b2Assert(proxy1.IsValid())
			' // b2Settings.b2Assert(proxy2.IsValid())
			if (pair.IsRemoved())
			
				' //  It is possible a pair was added then removed before a commit. Therefore
				' //  we should be careful not to tell the user the pair was removed when the
				' //  the user didn't receive a matching add.
				if (pair.IsFinal() == true)
				
					 me.m_callback.PairRemoved(proxy1.userData, proxy2.userData, pair.userData)
				
				' //  Store the ids so we can actually remove the pair below.
				 me.m_pairBuffer[removeCount].proxyId1 = pair.proxyId1
				 me.m_pairBuffer[removeCount].proxyId2 = pair.proxyId2
				++removeCount
			
			else
			
				' // b2Settings.b2Assert( me.m_broadPhase.TestOverlap(proxy1, proxy2) == true)
				if (pair.IsFinal() == false)
				
					pair.userData = me.m_callback.PairAdded(proxy1.userData, proxy2.userData)
					pair.SetFinal()
				
			
		for (i = 0; i < removeCount; ++i)
			 me.RemovePair( me.m_pairBuffer[i].proxyId1, me.m_pairBuffer[i].proxyId2)
		 me.m_pairBufferCount = 0
		if (b2BroadPhase.s_validate)
			 me.ValidateTable()
' // private:
	' //  Add a pair and return the new pair. If the pair already exists, '' TODO: posible funcion (revisar)

	' //  no new pair is created and the old one is returned. '' TODO: posible funcion (revisar)

end

public  sub 	AddPair(proxyId1 as variant, proxyId2 as variant) as variant ''funcio as variant ''funcio as variant ''funcion
		if (proxyId1 > proxyId2)
dim 			 temp  as variant = proxyId1

			proxyId1 = proxyId2
			proxyId2 = temp
			' // b2Math.b2Swap(p1, p2)
dim 		 hash  as variant = b2PairManager.Hash(proxyId1, proxyId2) & b2Pair.b2_tableMask

		' // var pairIndex = me.FindHash(proxyId1, proxyId2, hash)
dim 		 pair  as variant = pair = me.FindHash(proxyId1, proxyId2, hash)

		if (pair != null)
			return pair
 '' TODO: posible funcion (revisar)

		' // b2Settings.b2Assert( me.m_pairCount < b2Settings.b2_maxPairs && me.m_freePair != b2_nullPair)
dim 		 pIndex  as variant = me.m_freePair

		pair = me.m_pairs[pIndex]
		 me.m_freePair = pair.next
		pair.proxyId1 = proxyId1
		pair.proxyId2 = proxyId2
		pair.status = 0
		pair.userData = null
		pair.next = me.m_hashTable[hash]
		 me.m_hashTable[hash] = pIndex
		++ me.m_pairCount
		return pair
 '' TODO: posible funcion (revisar)

	' //  Remove a pair, return the pair's userData. '' TODO: posible funcion (revisar)

end

public  sub 	RemovePair(proxyId1 as variant, proxyId2 as variant) as variant ''funcio as variant ''funcion
		' // b2Settings.b2Assert( me.m_pairCount > 0)
		if (proxyId1 > proxyId2)
dim 			 temp  as variant = proxyId1

			proxyId1 = proxyId2
			proxyId2 = temp
			' // b2Math.b2Swap(proxyId1, proxyId2)
dim 		 hash  as variant = b2PairManager.Hash(proxyId1, proxyId2) & b2Pair.b2_tableMask

dim 		 node  as variant = me.m_hashTable[hash]

dim 		 pNode  as variant = null

		while (node != b2Pair.b2_nullPair)
			if (b2PairManager.Equals( me.m_pairs[node], proxyId1, proxyId2))
			
dim 				 index  as variant = node

				' // *node = me.m_pairs[*node].next
				if (pNode)
					pNode.next = me.m_pairs[node].next
				
				else
					 me.m_hashTable[hash] = me.m_pairs[node].next
				
dim 				 pair  as variant = me.m_pairs[ index ]

dim 				 userData  as variant = pair.userData

				' //  Scrub
				pair.next = me.m_freePair
				pair.proxyId1 = b2Pair.b2_nullProxy
				pair.proxyId2 = b2Pair.b2_nullProxy
				pair.userData = null
				pair.status = 0
				 me.m_freePair = index
				-- me.m_pairCount
				return userData
 '' TODO: posible funcion (revisar)

			
			else
			
				' // node = & me.m_pairs[*node].next
				pNode = me.m_pairs[node]
				node = pNode.next
			
		' // b2Settings.b2Assert(false)
		return null
 '' TODO: posible funcion (revisar)

end

public  sub 	Find(proxyId1 as variant, proxyId2 as variant) as variant ''funcion
		if (proxyId1 > proxyId2)
dim 			 temp  as variant = proxyId1

			proxyId1 = proxyId2
			proxyId2 = temp
			' // b2Math.b2Swap(proxyId1, proxyId2)
dim 		 hash  as variant = b2PairManager.Hash(proxyId1, proxyId2) & b2Pair.b2_tableMask

		return me.FindHash(proxyId1, proxyId2, hash)
 '' TODO: posible funcion (revisar)

end

public  sub 	FindHash(proxyId1 as variant, proxyId2 as variant, hash as variant) as variant ''funcio as variant ''funcion
dim 		 index  as variant = me.m_hashTable[hash]

		while( index != b2Pair.b2_nullPair && b2PairManager.Equals( me.m_pairs[index], proxyId1, proxyId2) == false)
			index = me.m_pairs[index].next
		if ( index == b2Pair.b2_nullPair )
			return null
 '' TODO: posible funcion (revisar)

		' // b2Settings.b2Assert(index < b2_maxPairs)
		return me.m_pairs[ index ]
 '' TODO: posible funcion (revisar)

end

public  sub 	ValidateBuffer()

		' //  DEBUG
end

public  sub 	ValidateTable()

		' //  DEBUG
' // public:
	m_broadPhase: null
	m_callback: null
	m_pairs: null
	m_freePair: 0
	m_pairCount: 0
	m_pairBuffer: null
	m_pairBufferCount: 0
	m_hashTable: null
' //  static
	' //  Thomas Wang's hash, see: http:
end

public  sub Hash (proxyId1 as variant, proxyId2 as variant) as variant ''funcion
dim 		 key  as variant = ((proxyId2 << 16) & 0xffff0000) | proxyId1

		key = ~key + ((key << 15) & 0xFFFF8000)
		key = key ^ ((key >> 12) & 0x000fffff)
		key = key + ((key << 2) & 0xFFFFFFFC)
		key = key ^ ((key >> 4) & 0x0fffffff)
		key = key * 2057
		key = key ^ ((key >> 16) & 0x0000ffff)
		return key
 '' TODO: posible funcion (revisar)

end

public  sub Equals (pair as variant, proxyId1 as variant, proxyId2 as variant) as variant ''funcion
		return (pair.proxyId1 == proxyId1 && pair.proxyId2 == proxyId2)
 '' TODO: posible funcion (revisar)

end

public  sub EqualsPair (pair1 as variant, pair2 as variant) as variant ''funcion
		return pair1.proxyId1 == pair2.proxyId1 && pair1.proxyId2 == pair2.proxyId2
 '' TODO: posible funcion (revisar)

﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  We use contact ids to facilitate warm starting.
dim  Features  as variant = Class.create()

Features.prototype = 
	' // 
end

public  sub 	set_referenceFace(value as variant)

		 me._referenceFace = value
		 me._m_id._key = ( me._m_id._key & 0xffffff00) | ( me._referenceFace & 0x000000ff)
end

public  sub 	get_referenceFace() as variant ''funcion
		return me._referenceFace
 '' TODO: posible funcion (revisar)

	_referenceFace: 0
	' // 
end

public  sub 	set_incidentEdge(value as variant)

		 me._incidentEdge = value
		 me._m_id._key = ( me._m_id._key & 0xffff00ff) | (( me._incidentEdge << 8) & 0x0000ff00)
end

public  sub 	get_incidentEdge() as variant ''funcion
		return me._incidentEdge
 '' TODO: posible funcion (revisar)

	_incidentEdge: 0
	' // 
end

public  sub 	set_incidentVertex(value as variant)

		 me._incidentVertex = value
		 me._m_id._key = ( me._m_id._key & 0xff00ffff) | (( me._incidentVertex << 16) & 0x00ff0000)
end

public  sub 	get_incidentVertex() as variant ''funcion
		return me._incidentVertex
 '' TODO: posible funcion (revisar)

	_incidentVertex: 0
	' // 
end

public  sub 	set_flip(value as variant)

		 me._flip = value
		 me._m_id._key = ( me._m_id._key & 0x00ffffff) | (( me._flip << 24) & 0xff000000)
end

public  sub 	get_flip() as variant ''funcion
		return me._flip
 '' TODO: posible funcion (revisar)

	_flip: 0
	_m_id: null
end

public  sub 	initialize()
 
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  We use contact ids to facilitate warm starting.
dim  b2ContactID  as variant = Class.create()

b2ContactID.prototype = 
end

public  sub 	initialize()

		' //  initialize instance variables for references
		 me.features = new Features()
		' // 
		 me.features._m_id = this
end

public  sub 	Set(id as variant)

		 me.set_key(id._key)
end

public  sub 	Copy() as variant ''funcion
dim 		 id  as variant = new b2ContactID()

		id.set_key( me._key)
		return id
 '' TODO: posible funcion (revisar)

end

public  sub 	get_key() as variant ''funcion
		return me._key
 '' TODO: posible funcion (revisar)

end

public  sub 	set_key(value as variant)
 
		 me._key = value
		 me.features._referenceFace = me._key & 0x000000ff
		 me.features._incidentEdge = (( me._key & 0x0000ff00) >> 8) & 0x000000ff
		 me.features._incidentVertex = (( me._key & 0x00ff0000) >> 16) & 0x000000ff
		 me.features._flip = (( me._key & 0xff000000) >> 24) & 0x000000ff
Public s: new Features(), as new eatures(),
	_key: 0
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' /* 
This broad phase uses the Sweep and Prune algorithm in:
Collision Detection in Interactive 3D Environments by Gino van den Bergen
Also, some ideas, such integral values for fast compares comes from
Bullet (http:/www.bulletphysics.com).
' */
' //  Notes:
' //  - we use bound arrays instead of linked lists for cache coherence.
' //  - we use quantized integral values for fast compares.
' //  - we use short indices rather than pointers to save memory.
' //  - we use a stabbing count for fast overlap queries (less than order N).
' //  - we also use a time stamp on each proxy to speed up the registration of
' //    overlap query results.
' //  - where possible, we compare bound indices instead of values to reduce
' //    cache misses (TODO_ERIN).
' //  - no broadphase is perfect and neither is this one: it is not great for huge
' //    worlds (use a multi-SAP instead), it is not great for large objects.
dim  b2BroadPhase  as variant = Class.create()

b2BroadPhase.prototype = 
' // public:
end

public  sub 	initialize(worldAABB as variant, callback as variant)

		' //  initialize instance variables for references
		 me.m_pairManager = new b2PairManager()
		 me.m_proxyPool = new Array(b2Settings.b2_maxPairs)
		 me.m_bounds = new Array(2*b2Settings.b2_maxProxies)
		 me.m_queryResults = new Array(b2Settings.b2_maxProxies)
		 me.m_quantizationFactor = new b2Vec2()
		' // 
		' // b2Settings.b2Assert(worldAABB.IsValid())
dim 		 i  as variant = 0

		 me.m_pairManager.Initialize(this, callback)
		 me.m_worldAABB = worldAABB
		 me.m_proxyCount = 0
		' //  query results
		for (i = 0; i < b2Settings.b2_maxProxies; i++)
			 me.m_queryResults[i] = 0
		' //  bounds array
		 me.m_bounds = new Array(2)
		for (i = 0; i < 2; i++)
			 me.m_bounds[i] = new Array(2*b2Settings.b2_maxProxies)
			for (var j = 0; j < 2*b2Settings.b2_maxProxies; j++)
				 me.m_bounds[i][j] = new b2Bound()
			
		' // var d = b2Math.SubtractVV(worldAABB.maxVertex, worldAABB.minVertex)
dim 		 dX  as variant = worldAABB.maxVertex.x

dim 		 dY  as variant = worldAABB.maxVertex.y

		dX -= worldAABB.minVertex.x
		dY -= worldAABB.minVertex.y
		 me.m_quantizationFactor.x = b2Settings.USHRT_MAX / dX
		 me.m_quantizationFactor.y = b2Settings.USHRT_MAX / dY
dim 		tProxy
 as variant
		for (i = 0; i < b2Settings.b2_maxProxies - 1; ++i)
			tProxy = new b2Proxy()
			 me.m_proxyPool[i] = tProxy
			tProxy.SetNext(i + 1)
			tProxy.timeStamp = 0
			tProxy.overlapCount = b2BroadPhase.b2_invalid
			tProxy.userData = null
		tProxy = new b2Proxy()
		 me.m_proxyPool[b2Settings.b2_maxProxies-1] = tProxy
		tProxy.SetNext(b2Pair.b2_nullProxy)
		tProxy.timeStamp = 0
		tProxy.overlapCount = b2BroadPhase.b2_invalid
		tProxy.userData = null
		 me.m_freeProxy = 0
		 me.m_timeStamp = 1
		 me.m_queryResultCount = 0
	' // ~b2BroadPhase()
	' //  Use this to see if your proxy is in range. If it is not in range
	' //  it should be destroyed. Otherwise you may get O(m^2) pairs, where m
	' //  is the number of proxies that are out of range.
end

public  sub 	InRange(aabb as variant) as variant ''funcion
		' // var d = b2Math.b2MaxV(b2Math.SubtractVV(aabb.minVertex, me.m_worldAABB.maxVertex), b2Math.SubtractVV( me.m_worldAABB.minVertex, aabb.maxVertex))
dim 		dX
 as variant
dim 		dY
 as variant
dim 		d2X
 as variant
dim 		d2Y
 as variant
		dX = aabb.minVertex.x
		dY = aabb.minVertex.y
		dX -= me.m_worldAABB.maxVertex.x
		dY -= me.m_worldAABB.maxVertex.y
		d2X = me.m_worldAABB.minVertex.x
		d2Y = me.m_worldAABB.minVertex.y
		d2X -= aabb.maxVertex.x
		d2Y -= aabb.maxVertex.y
		dX = b2Math.b2Max(dX, d2X)
		dY = b2Math.b2Max(dY, d2Y)
		return b2Math.b2Max(dX, dY) < 0.0
 '' TODO: posible funcion (revisar)

	' //  Get a single proxy. Returns NULL if the id is invalid.
end

public  sub 	GetProxy(proxyId as variant) as variant ''funcio as variant ''funcion
		if (proxyId == b2Pair.b2_nullProxy || me.m_proxyPool[proxyId].IsValid() == false)
			return null
 '' TODO: posible funcion (revisar)

		return me.m_proxyPool[ proxyId ]
 '' TODO: posible funcion (revisar)

	' //  Create and destroy proxies. These call Flush first.
end

public  sub 	CreateProxy(aabb as variant, userData as variant) as variant ''funcion
dim 		 index  as variant = 0

dim 		proxy
 as variant
		' // b2Settings.b2Assert( me.m_proxyCount < b2_maxProxies)
		' // b2Settings.b2Assert( me.m_freeProxy != b2Pair.b2_nullProxy)
dim 		 proxyId  as variant = me.m_freeProxy

		proxy = me.m_proxyPool[ proxyId ]
		 me.m_freeProxy = proxy.GetNext()
		proxy.overlapCount = 0
		proxy.userData = userData
dim 		 boundCount  as variant = 2 * me.m_proxyCount

dim 		 lowerValues  as variant = new Array()

dim 		 upperValues  as variant = new Array()

		 me.ComputeBounds(lowerValues, upperValues, aabb)
		for (var axis = 0; axis < 2; ++axis)
dim 			 bounds  as variant = me.m_bounds[axis]

dim 			 lowerIndex  as variant = 0

dim 			 upperIndex  as variant = 0

dim 			 lowerIndexOut  as variant = [lowerIndex]

dim 			 upperIndexOut  as variant = [upperIndex]

			 me.Query(lowerIndexOut, upperIndexOut, lowerValues[axis], upperValues[axis], bounds, boundCount, axis)
			lowerIndex = lowerIndexOut[0]
			upperIndex = upperIndexOut[0]
			' //  Replace memmove calls
			' // memmove(bounds + upperIndex + 2, bounds + upperIndex, (edgeCount - upperIndex) * sizeof(b2Bound))
dim 			 tArr  as variant = new Array()

dim 			 j  as variant = 0

dim 			 tEnd  as variant = boundCount - upperIndex
dim 			tBound1
 as variant
dim 			tBound2
 as variant
			' //  make temp array
			for (j = 0; j < tEnd; j++)
				tArr[j] = new b2Bound()
				tBound1 = tArr[j]
				tBound2 = bounds[upperIndex+j]
				tBound1.value = tBound2.value
				tBound1.proxyId = tBound2.proxyId
				tBound1.stabbingCount = tBound2.stabbingCount
			
			' //  move temp array back in to bounds
			tEnd = tArr.length
dim 			 tIndex  as variant = upperIndex+2

			for (j = 0; j < tEnd; j++)
				' // bounds[tIndex+j] = tArr[j]
				tBound2 = tArr[j]
				tBound1 = bounds[tIndex+j]
				tBound1.value = tBound2.value
				tBound1.proxyId = tBound2.proxyId
				tBound1.stabbingCount = tBound2.stabbingCount
			
			' // memmove(bounds + lowerIndex + 1, bounds + lowerIndex, (upperIndex - lowerIndex) * sizeof(b2Bound))
			' //  make temp array
			tArr = new Array()
			tEnd = upperIndex - lowerIndex
			for (j = 0; j < tEnd; j++)
				tArr[j] = new b2Bound()
				tBound1 = tArr[j]
				tBound2 = bounds[lowerIndex+j]
				tBound1.value = tBound2.value
				tBound1.proxyId = tBound2.proxyId
				tBound1.stabbingCount = tBound2.stabbingCount
			
			' //  move temp array back in to bounds
			tEnd = tArr.length
			tIndex = lowerIndex+1
			for (j = 0; j < tEnd; j++)
				' // bounds[tIndex+j] = tArr[j]
				tBound2 = tArr[j]
				tBound1 = bounds[tIndex+j]
				tBound1.value = tBound2.value
				tBound1.proxyId = tBound2.proxyId
				tBound1.stabbingCount = tBound2.stabbingCount
			
			' //  The upper index has increased because of the lower bound insertion.
			++upperIndex
			' //  Copy in the new bounds.
			bounds[lowerIndex].value = lowerValues[axis]
			bounds[lowerIndex].proxyId = proxyId
			bounds[upperIndex].value = upperValues[axis]
			bounds[upperIndex].proxyId = proxyId
			bounds[lowerIndex].stabbingCount = lowerIndex == 0 ? 0 : bounds[lowerIndex-1].stabbingCount
			bounds[upperIndex].stabbingCount = bounds[upperIndex-1].stabbingCount
			' //  Adjust the stabbing count between the new bounds.
			for (index = lowerIndex; index < upperIndex; ++index)
			
				bounds[index].stabbingCount++
			
			' //  Adjust the all the affected bound indices.
			for (index = lowerIndex; index < boundCount + 2; ++index)
			
dim 				 proxy2  as variant = me.m_proxyPool[ bounds[index].proxyId ]

				if (bounds[index].IsLower())
				
					proxy2.lowerBounds[axis] = index
				
				else
				
					proxy2.upperBounds[axis] = index
				
			
		++ me.m_proxyCount
		' // b2Settings.b2Assert( me.m_queryResultCount < b2Settings.b2_maxProxies)
		for (var i = 0; i < me.m_queryResultCount; ++i)
			' // b2Settings.b2Assert( me.m_queryResults[i] < b2_maxProxies)
			' // b2Settings.b2Assert( me.m_proxyPool[ me.m_queryResults[i]].IsValid())
			 me.m_pairManager.AddBufferedPair(proxyId, me.m_queryResults[i])
		 me.m_pairManager.Commit()
		' //  Prepare for next query.
		 me.m_queryResultCount = 0
		 me.IncrementTimeStamp()
		return proxyId
 '' TODO: posible funcion (revisar)

end

public  sub 	DestroyProxy(proxyId as variant)

		' // b2Settings.b2Assert(0 < me.m_proxyCount && me.m_proxyCount <= b2_maxProxies)
dim 		 proxy  as variant = me.m_proxyPool[ proxyId ]

		' // b2Settings.b2Assert(proxy.IsValid())
dim 		 boundCount  as variant = 2 * me.m_proxyCount

		for (var axis = 0; axis < 2; ++axis)
dim 			 bounds  as variant = me.m_bounds[axis]

dim 			 lowerIndex  as variant = proxy.lowerBounds[axis]

dim 			 upperIndex  as variant = proxy.upperBounds[axis]

dim 			 lowerValue  as variant = bounds[lowerIndex].value

dim 			 upperValue  as variant = bounds[upperIndex].value

			' //  replace memmove calls
			' // memmove(bounds + lowerIndex, bounds + lowerIndex + 1, (upperIndex - lowerIndex - 1) * sizeof(b2Bound))
dim 			 tArr  as variant = new Array()

dim 			 j  as variant = 0

dim 			 tEnd  as variant = upperIndex - lowerIndex - 1

dim 			tBound1
 as variant
dim 			tBound2
 as variant
			' //  make temp array
			for (j = 0; j < tEnd; j++)
				tArr[j] = new b2Bound()
				tBound1 = tArr[j]
				tBound2 = bounds[lowerIndex+1+j]
				tBound1.value = tBound2.value
				tBound1.proxyId = tBound2.proxyId
				tBound1.stabbingCount = tBound2.stabbingCount
			
			' //  move temp array back in to bounds
			tEnd = tArr.length
dim 			 tIndex  as variant = lowerIndex

			for (j = 0; j < tEnd; j++)
				' // bounds[tIndex+j] = tArr[j]
				tBound2 = tArr[j]
				tBound1 = bounds[tIndex+j]
				tBound1.value = tBound2.value
				tBound1.proxyId = tBound2.proxyId
				tBound1.stabbingCount = tBound2.stabbingCount
			
			' // memmove(bounds + upperIndex-1, bounds + upperIndex + 1, (edgeCount - upperIndex - 1) * sizeof(b2Bound))
			' //  make temp array
			tArr = new Array()
			tEnd = boundCount - upperIndex - 1
			for (j = 0; j < tEnd; j++)
				tArr[j] = new b2Bound()
				tBound1 = tArr[j]
				tBound2 = bounds[upperIndex+1+j]
				tBound1.value = tBound2.value
				tBound1.proxyId = tBound2.proxyId
				tBound1.stabbingCount = tBound2.stabbingCount
			
			' //  move temp array back in to bounds
			tEnd = tArr.length
			tIndex = upperIndex-1
			for (j = 0; j < tEnd; j++)
				' // bounds[tIndex+j] = tArr[j]
				tBound2 = tArr[j]
				tBound1 = bounds[tIndex+j]
				tBound1.value = tBound2.value
				tBound1.proxyId = tBound2.proxyId
				tBound1.stabbingCount = tBound2.stabbingCount
			
			' //  Fix bound indices.
			tEnd = boundCount - 2
			for (var index = lowerIndex; index < tEnd; ++index)
			
dim 				 proxy2  as variant = me.m_proxyPool[ bounds[index].proxyId ]

				if (bounds[index].IsLower())
				
					proxy2.lowerBounds[axis] = index
				
				else
				
					proxy2.upperBounds[axis] = index
				
			
			' //  Fix stabbing count.
			tEnd = upperIndex - 1
			for (var index2 = lowerIndex; index2 < tEnd; ++index2)
			
				bounds[index2].stabbingCount--
			
			' //  me.Query for pairs to be removed. lowerIndex and upperIndex are not needed.
			' //  make lowerIndex and upper output using an array and do this for others if compiler doesn't pick them up
			 me.Query([0], [0], lowerValue, upperValue, bounds, boundCount - 2, axis)
		' // b2Settings.b2Assert( me.m_queryResultCount < b2Settings.b2_maxProxies)
		for (var i = 0; i < me.m_queryResultCount; ++i)
			' // b2Settings.b2Assert( me.m_proxyPool[ me.m_queryResults[i]].IsValid())
			 me.m_pairManager.RemoveBufferedPair(proxyId, me.m_queryResults[i])
		 me.m_pairManager.Commit()
		' //  Prepare for next query.
		 me.m_queryResultCount = 0
		 me.IncrementTimeStamp()
		' //  Return the proxy to the pool.
		proxy.userData = null
		proxy.overlapCount = b2BroadPhase.b2_invalid
		proxy.lowerBounds[0] = b2BroadPhase.b2_invalid
		proxy.lowerBounds[1] = b2BroadPhase.b2_invalid
		proxy.upperBounds[0] = b2BroadPhase.b2_invalid
		proxy.upperBounds[1] = b2BroadPhase.b2_invalid
		proxy.SetNext( me.m_freeProxy)
		 me.m_freeProxy = proxyId
		-- me.m_proxyCount
	' //  Call me.MoveProxy times like, then when you are done
	' //  call me.Commit to finalized the proxy pairs (for your time step).
end

public  sub 	MoveProxy(proxyId as variant, aabb as variant) as variant ''funcio as variant ''funcion
dim 		 axis  as variant = 0

dim 		 index  as variant = 0

dim 		bound
 as variant
dim 		prevBound as variant
dim 		nextBound as variant
dim 		 nextProxyId  as variant = 0

dim 		nextProxy
 as variant
		if (proxyId == b2Pair.b2_nullProxy || b2Settings.b2_maxProxies <= proxyId)
			' // b2Settings.b2Assert(false)
			return
 '' TODO: posible funcion (revisar)

		if (aabb.IsValid() == false)
			' // b2Settings.b2Assert(false)
			return
 '' TODO: posible funcion (revisar)

dim 		 boundCount  as variant = 2 * me.m_proxyCount

dim 		 proxy  as variant = me.m_proxyPool[ proxyId ]

		' //  Get new bound values
dim 		 newValues  as variant = new b2BoundValues()

		 me.ComputeBounds(newValues.lowerValues, newValues.upperValues, aabb)
		' //  Get old bound values
dim 		 oldValues  as variant = new b2BoundValues()

		for (axis = 0; axis < 2; ++axis)
			oldValues.lowerValues[axis] = me.m_bounds[axis][proxy.lowerBounds[axis]].value
			oldValues.upperValues[axis] = me.m_bounds[axis][proxy.upperBounds[axis]].value
		for (axis = 0; axis < 2; ++axis)
dim 			 bounds  as variant = me.m_bounds[axis]

dim 			 lowerIndex  as variant = proxy.lowerBounds[axis]

dim 			 upperIndex  as variant = proxy.upperBounds[axis]

dim 			 lowerValue  as variant = newValues.lowerValues[axis]

dim 			 upperValue  as variant = newValues.upperValues[axis]

dim 			 deltaLower  as variant = lowerValue - bounds[lowerIndex].value

dim 			 deltaUpper  as variant = upperValue - bounds[upperIndex].value

			bounds[lowerIndex].value = lowerValue
			bounds[upperIndex].value = upperValue
			' // 
			' //  Expanding adds overlaps
			' // 
			' //  Should we move the lower bound down?
			if (deltaLower < 0)
			
				index = lowerIndex
				while (index > 0 && lowerValue < bounds[index-1].value)
				
					bound = bounds[index]
					prevBound = bounds[index - 1]
dim 					 prevProxyId  as variant = prevBound.proxyId

dim 					 prevProxy  as variant = me.m_proxyPool[ prevBound.proxyId ]

					prevBound.stabbingCount++
					if (prevBound.IsUpper() == true)
					
						if ( me.TestOverlap(newValues, prevProxy))
						
							 me.m_pairManager.AddBufferedPair(proxyId, prevProxyId)
						
						prevProxy.upperBounds[axis]++
						bound.stabbingCount++
					
					else
					
						prevProxy.lowerBounds[axis]++
						bound.stabbingCount--
					
					proxy.lowerBounds[axis]--
					' //  swap
					' // var temp = bound
					' // bound = prevEdge
					' // prevEdge = temp
					bound.Swap(prevBound)
					' // b2Math.b2Swap(bound, prevEdge)
					--index
				
			
			' //  Should we move the upper bound up?
			if (deltaUpper > 0)
			
				index = upperIndex
				while (index < boundCount-1 && bounds[index+1].value <= upperValue)
				
					bound = bounds[ index ]
					nextBound = bounds[ index + 1 ]
					nextProxyId = nextBound.proxyId
					nextProxy = me.m_proxyPool[ nextProxyId ]
					nextBound.stabbingCount++
					if (nextBound.IsLower() == true)
					
						if ( me.TestOverlap(newValues, nextProxy))
						
							 me.m_pairManager.AddBufferedPair(proxyId, nextProxyId)
						
						nextProxy.lowerBounds[axis]--
						bound.stabbingCount++
					
					else
					
						nextProxy.upperBounds[axis]--
						bound.stabbingCount--
					
					proxy.upperBounds[axis]++
					' //  swap
					' // var temp = bound
					' // bound = nextEdge
					' // nextEdge = temp
					bound.Swap(nextBound)
					' // b2Math.b2Swap(bound, nextEdge)
					index++
				
			
			' // 
			' //  Shrinking removes overlaps
			' // 
			' //  Should we move the lower bound up?
			if (deltaLower > 0)
			
				index = lowerIndex
				while (index < boundCount-1 && bounds[index+1].value <= lowerValue)
				
					bound = bounds[ index ]
					nextBound = bounds[ index + 1 ]
					nextProxyId = nextBound.proxyId
					nextProxy = me.m_proxyPool[ nextProxyId ]
					nextBound.stabbingCount--
					if (nextBound.IsUpper())
					
						if ( me.TestOverlap(oldValues, nextProxy))
						
							 me.m_pairManager.RemoveBufferedPair(proxyId, nextProxyId)
						
						nextProxy.upperBounds[axis]--
						bound.stabbingCount--
					
					else
					
						nextProxy.lowerBounds[axis]--
						bound.stabbingCount++
					
					proxy.lowerBounds[axis]++
					' //  swap
					' // var temp = bound
					' // bound = nextEdge
					' // nextEdge = temp
					bound.Swap(nextBound)
					' // b2Math.b2Swap(bound, nextEdge)
					index++
				
			
			' //  Should we move the upper bound down?
			if (deltaUpper < 0)
			
				index = upperIndex
				while (index > 0 && upperValue < bounds[index-1].value)
				
					bound = bounds[index]
					prevBound = bounds[index - 1]
					prevProxyId = prevBound.proxyId
					prevProxy = me.m_proxyPool[ prevProxyId ]
					prevBound.stabbingCount--
					if (prevBound.IsLower() == true)
					
						if ( me.TestOverlap(oldValues, prevProxy))
						
							 me.m_pairManager.RemoveBufferedPair(proxyId, prevProxyId)
						
						prevProxy.lowerBounds[axis]++
						bound.stabbingCount--
					
					else
					
						prevProxy.upperBounds[axis]++
						bound.stabbingCount++
					
					proxy.upperBounds[axis]--
					' //  swap
					' // var temp = bound
					' // bound = prevEdge
					' // prevEdge = temp
					bound.Swap(prevBound)
					' // b2Math.b2Swap(bound, prevEdge)
					index--
				
			
end

public  sub 	Commit() as variant ''funcion
		 me.m_pairManager.Commit()
	' //  me.Query an AABB for overlapping proxies, returns the user data and '' TODO: posible funcion (revisar)

	' //  the count, up to the supplied maximum count.
end

public  sub 	QueryAABB(aabb as variant, userData as variant, maxCount as variant) as variant ''funcion
dim 		 lowerValues  as variant = new Array()

dim 		 upperValues  as variant = new Array()

		 me.ComputeBounds(lowerValues, upperValues, aabb)
dim 		 lowerIndex  as variant = 0

dim 		 upperIndex  as variant = 0

dim 		 lowerIndexOut  as variant = [lowerIndex]

dim 		 upperIndexOut  as variant = [upperIndex]

		 me.Query(lowerIndexOut, upperIndexOut, lowerValues[0], upperValues[0], me.m_bounds[0], 2* me.m_proxyCount, 0)
		 me.Query(lowerIndexOut, upperIndexOut, lowerValues[1], upperValues[1], me.m_bounds[1], 2* me.m_proxyCount, 1)
		' // b2Settings.b2Assert( me.m_queryResultCount < b2Settings.b2_maxProxies)
dim 		 count  as variant = 0

		for (var i = 0; i < me.m_queryResultCount && count < maxCount; ++i, ++count)
			' // b2Settings.b2Assert( me.m_queryResults[i] < b2Settings.b2_maxProxies)
dim 			 proxy  as variant = me.m_proxyPool[ me.m_queryResults[i] ]

			' // b2Settings.b2Assert(proxy.IsValid())
			userData[i] = proxy.userData
		' //  Prepare for next query.
		 me.m_queryResultCount = 0
		 me.IncrementTimeStamp()
		return count
 '' TODO: posible funcion (revisar)

end

public  sub 	Validate()

dim 		pair
 as variant
dim 		proxy1
 as variant
dim 		proxy2
 as variant
dim 		overlap
 as variant
		for (var axis = 0; axis < 2; ++axis)
dim 			 bounds  as variant = me.m_bounds[axis]

dim 			 boundCount  as variant = 2 * me.m_proxyCount

dim 			 stabbingCount  as variant = 0

			for (var i = 0; i < boundCount; ++i)
			
dim 				 bound  as variant = bounds[i]

				' // b2Settings.b2Assert(i == 0 || bounds[i-1].value <= bound->value)
				' // b2Settings.b2Assert(bound->proxyId != b2_nullProxy)
				' // b2Settings.b2Assert( me.m_proxyPool[bound->proxyId].IsValid())
				if (bound.IsLower() == true)
				
					' // b2Settings.b2Assert( me.m_proxyPool[bound.proxyId].lowerBounds[axis] == i)
					stabbingCount++
				
				else
				
					' // b2Settings.b2Assert( me.m_proxyPool[bound.proxyId].upperBounds[axis] == i)
					stabbingCount--
				
				' // b2Settings.b2Assert(bound.stabbingCount == stabbingCount)
			
' // private:
end

public  sub 	ComputeBounds(lowerValues as variant, upperValues as variant, aabb as variant)

		' // b2Settings.b2Assert(aabb.maxVertex.x > aabb.minVertex.x)
		' // b2Settings.b2Assert(aabb.maxVertex.y > aabb.minVertex.y)
		' // var minVertex = b2Math.b2ClampV(aabb.minVertex, me.m_worldAABB.minVertex, me.m_worldAABB.maxVertex)
dim 		 minVertexX  as variant = aabb.minVertex.x

dim 		 minVertexY  as variant = aabb.minVertex.y

		minVertexX = b2Math.b2Min(minVertexX, me.m_worldAABB.maxVertex.x)
		minVertexY = b2Math.b2Min(minVertexY, me.m_worldAABB.maxVertex.y)
		minVertexX = b2Math.b2Max(minVertexX, me.m_worldAABB.minVertex.x)
		minVertexY = b2Math.b2Max(minVertexY, me.m_worldAABB.minVertex.y)
		' // var maxVertex = b2Math.b2ClampV(aabb.maxVertex, me.m_worldAABB.minVertex, me.m_worldAABB.maxVertex)
dim 		 maxVertexX  as variant = aabb.maxVertex.x

dim 		 maxVertexY  as variant = aabb.maxVertex.y

		maxVertexX = b2Math.b2Min(maxVertexX, me.m_worldAABB.maxVertex.x)
		maxVertexY = b2Math.b2Min(maxVertexY, me.m_worldAABB.maxVertex.y)
		maxVertexX = b2Math.b2Max(maxVertexX, me.m_worldAABB.minVertex.x)
		maxVertexY = b2Math.b2Max(maxVertexY, me.m_worldAABB.minVertex.y)
		' //  Bump lower bounds downs and upper bounds up. This ensures correct sorting of
		' //  lower/upper bounds that would have equal values.
		' //  TODO_ERIN implement fast float to uint16 conversion.
		lowerValues[0] = ' /* uint*/( me.m_quantizationFactor.x * (minVertexX - me.m_worldAABB.minVertex.x)) & (b2Settings.USHRT_MAX - 1)
		upperValues[0] = (' /* uint*/( me.m_quantizationFactor.x * (maxVertexX - me.m_worldAABB.minVertex.x))& 0x0000ffff) | 1
		lowerValues[1] = ' /* uint*/( me.m_quantizationFactor.y * (minVertexY - me.m_worldAABB.minVertex.y)) & (b2Settings.USHRT_MAX - 1)
		upperValues[1] = (' /* uint*/( me.m_quantizationFactor.y * (maxVertexY - me.m_worldAABB.minVertex.y))& 0x0000ffff) | 1
	' //  This one is only used for validation.
end

public  sub 	TestOverlapValidate(p1 as variant, p2 as variant) as variant ''funcio as variant ''funcio as variant ''funcion
		for (var axis = 0; axis < 2; ++axis)
dim 			 bounds  as variant = me.m_bounds[axis]

			' // b2Settings.b2Assert(p1.lowerBounds[axis] < 2 * me.m_proxyCount)
			' // b2Settings.b2Assert(p1.upperBounds[axis] < 2 * me.m_proxyCount)
			' // b2Settings.b2Assert(p2.lowerBounds[axis] < 2 * me.m_proxyCount)
			' // b2Settings.b2Assert(p2.upperBounds[axis] < 2 * me.m_proxyCount)
			if (bounds[p1.lowerBounds[axis]].value > bounds[p2.upperBounds[axis]].value)
				return false
 '' TODO: posible funcion (revisar)

			if (bounds[p1.upperBounds[axis]].value < bounds[p2.lowerBounds[axis]].value)
				return false
 '' TODO: posible funcion (revisar)

		return true
 '' TODO: posible funcion (revisar)

end

public  sub 	TestOverlap(b as variant, p as variant) as variant ''funcio as variant ''funcio as variant ''funcion
		for (var axis = 0; axis < 2; ++axis)
dim 			 bounds  as variant = me.m_bounds[axis]

			' // b2Settings.b2Assert(p.lowerBounds[axis] < 2 * me.m_proxyCount)
			' // b2Settings.b2Assert(p.upperBounds[axis] < 2 * me.m_proxyCount)
			if (b.lowerValues[axis] > bounds[p.upperBounds[axis]].value)
				return false
 '' TODO: posible funcion (revisar)

			if (b.upperValues[axis] < bounds[p.lowerBounds[axis]].value)
				return false
 '' TODO: posible funcion (revisar)

		return true
 '' TODO: posible funcion (revisar)

end

public  sub 	Query(lowerQueryOut as variant, upperQueryOut as variant, lowerValue as variant, upperValue as variant, bounds as variant, boundCount as variant, axis as variant)

dim 		 lowerQuery  as variant = b2BroadPhase.BinarySearch(bounds, boundCount, lowerValue)

dim 		 upperQuery  as variant = b2BroadPhase.BinarySearch(bounds, boundCount, upperValue)

		' //  Easy case: lowerQuery <= lowerIndex(i) < upperQuery
		' //  Solution: search query range for min bounds.
		for (var j = lowerQuery; j < upperQuery; ++j)
			if (bounds[j].IsLower())
			
				 me.IncrementOverlapCount(bounds[j].proxyId)
			
		' //  Hard case: lowerIndex(i) < lowerQuery < upperIndex(i)
		' //  Solution: use the stabbing count to search down the bound array.
		if (lowerQuery > 0)
dim 			 i  as variant = lowerQuery - 1

dim 			 s  as variant = bounds[i].stabbingCount

			' //  Find the s overlaps.
			while (s)
			
				' // b2Settings.b2Assert(i >= 0)
				if (bounds[i].IsLower())
				
dim 					 proxy  as variant = me.m_proxyPool[ bounds[i].proxyId ]

					if (lowerQuery <= proxy.upperBounds[axis])
					
						 me.IncrementOverlapCount(bounds[i].proxyId)
						--s
					
				
				--i
			
		lowerQueryOut[0] = lowerQuery
		upperQueryOut[0] = upperQuery
end

public  sub 	IncrementOverlapCount(proxyId as variant)

dim 		 proxy  as variant = me.m_proxyPool[ proxyId ]

		if (proxy.timeStamp < me.m_timeStamp)
			proxy.timeStamp = me.m_timeStamp
			proxy.overlapCount = 1
		else
			proxy.overlapCount = 2
			' // b2Settings.b2Assert( me.m_queryResultCount < b2Settings.b2_maxProxies)
			 me.m_queryResults[ me.m_queryResultCount] = proxyId
			++ me.m_queryResultCount
end

public  sub 	IncrementTimeStamp()

		if ( me.m_timeStamp == b2Settings.USHRT_MAX)
			for (var i = 0; i < b2Settings.b2_maxProxies; ++i)
			
				 me.m_proxyPool[i].timeStamp = 0
			
			 me.m_timeStamp = 1
		else
			++ me.m_timeStamp
' // public:
Public r: new b2PairManager(), as new 2PairManager(),
Public l: new Array(b2Settings.b2_maxPairs), as new rray(b2Settings.b2_maxPairs),
	m_freeProxy: 0
Public s: new Array(2*b2Settings.b2_maxProxies), as new rray(2*b2Settings.b2_maxProxies),
Public s: new Array(b2Settings.b2_maxProxies), as new rray(b2Settings.b2_maxProxies),
	m_queryResultCount: 0
	m_worldAABB: null
Public r: new b2Vec2(), as new 2Vec2(),
	m_proxyCount: 0
	m_timeStamp: 0
b2BroadPhase.s_validate = false
b2BroadPhase.b2_invalid = b2Settings.USHRT_MAX
b2BroadPhase.b2_nullEdge = b2Settings.USHRT_MAX
end

public  sub BinarySearch (bounds as variant, count as variant, value as variant) as variant ''funcio as variant ''funcio as variant ''funcio as variant ''funcion
dim 		 low  as variant = 0

dim 		 high  as variant = count - 1

		while (low <= high)
dim 			 mid  as variant = Math.floor((low + high) / 2)

			if (bounds[mid].value > value)
			
				high = mid - 1
			
			else if (bounds[mid].value < value)
			
				low = mid + 1
			
			else
			
				return ' /* uint*/(mid)
 '' TODO: posible funcion (revisar)

			
		return ' /* uint*/(low)
 '' TODO: posible funcion (revisar)

﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2Collision  as variant = Class.create()

b2Collision.prototype = 
	' //  Null feature
	' //  Find the separation between poly1 and poly2 for a give edge normal on poly1.
	' //  Find the max separation between poly1 and poly2 using edge normals
	' //  from poly1.
	' //  Find edge normal of max separation on A - return if separating axis is found '' TODO: posible funcion (revisar)

	' //  Find edge normal of max separation on B - return if separation axis is found '' TODO: posible funcion (revisar)

	' //  Choose reference edge(minA, minB)
	' //  Find incident edge
	' //  Clip
	' //  The normal points from 1 to 2
end

public  sub 	initialize()
 
b2Collision.b2_nullFeature = 0x000000ff
end

public  sub ClipSegmentToLine (vOut as variant, vIn as variant, normal as variant, offset as variant) as variant ''funcion
		' //  Start with no output points
dim 		 numOut  as variant = 0

dim 		 vIn0  as variant = vIn[0].v

dim 		 vIn1  as variant = vIn[1].v

		' //  Calculate the distance of end points to the line
dim 		 distance0  as variant = b2Math.b2Dot(normal, vIn[0].v) - offset

dim 		 distance1  as variant = b2Math.b2Dot(normal, vIn[1].v) - offset

		' //  If the points are behind the plane
		if (distance0 <= 0.0) vOut[numOut++] = vIn[0]
		if (distance1 <= 0.0) vOut[numOut++] = vIn[1]
		' //  If the points are on different sides of the plane
		if (distance0 * distance1 < 0.0)
			' //  Find intersection point of edge and plane
dim 			 interp  as variant = distance0 / (distance0 - distance1)

			' //  expanded for performance
dim 			 tVec  as variant = vOut[numOut].v

			tVec.x = vIn0.x + interp * (vIn1.x - vIn0.x)
			tVec.y = vIn0.y + interp * (vIn1.y - vIn0.y)
			if (distance0 > 0.0)
			
				vOut[numOut].id = vIn[0].id
			
			else
			
				vOut[numOut].id = vIn[1].id
			
			++numOut
		return numOut
 '' TODO: posible funcion (revisar)

end

public  sub EdgeSeparation (poly1 as variant, edge1 as variant, poly2 as variant) as variant ''funcion
dim 		 vert1s  as variant = poly1.m_vertices

dim 		 count2  as variant = poly2.m_vertexCount

dim 		 vert2s  as variant = poly2.m_vertices

		' //  Convert normal from into poly2's frame.
		' // b2Settings.b2Assert(edge1 < poly1.m_vertexCount)
		' // var normal = b2Math.b2MulMV(poly1.m_R, poly1->m_normals[edge1])
dim 		 normalX  as variant = poly1.m_normals[edge1].x

dim 		 normalY  as variant = poly1.m_normals[edge1].y

dim 		 tX  as variant = normalX

dim 		 tMat  as variant = poly1.m_R

		normalX = tMat.col1.x * tX + tMat.col2.x * normalY
		normalY = tMat.col1.y * tX + tMat.col2.y * normalY
		' //  ^^^^^^^ normal.MulM(poly1.m_R)
		' // var normalLocal2 = b2Math.b2MulTMV(poly2.m_R, normal)
dim 		 normalLocal2X  as variant = normalX

dim 		 normalLocal2Y  as variant = normalY

		tMat = poly2.m_R
		tX = normalLocal2X * tMat.col1.x + normalLocal2Y * tMat.col1.y
		normalLocal2Y = normalLocal2X * tMat.col2.x + normalLocal2Y * tMat.col2.y
		normalLocal2X = tX
		' //  ^^^^^ normalLocal2.MulTM(poly2.m_R)
		' //  Find support vertex on poly2 for -normal.
dim 		 vertexIndex2  as variant = 0

dim 		 minDot  as variant = Number.MAX_VALUE

		for (var i = 0; i < count2; ++i)
			' // var dot = b2Math.b2Dot(vert2s[i], normalLocal2)
dim 			 tVec  as variant = vert2s[i]

dim 			 dot  as variant = tVec.x * normalLocal2X + tVec.y * normalLocal2Y

			if (dot < minDot)
			
				minDot = dot
				vertexIndex2 = i
			
		' // b2Vec2 v1 = poly1->m_position + b2Mul(poly1->m_R, vert1s[edge1])
		tMat = poly1.m_R
dim 		 v1X  as variant = poly1.m_position.x + (tMat.col1.x * vert1s[edge1].x + tMat.col2.x * vert1s[edge1].y)
dim 		 v1Y  as variant = poly1.m_position.y + (tMat.col1.y * vert1s[edge1].x + tMat.col2.y * vert1s[edge1].y)
		' // b2Vec2 v2 = poly2->m_position + b2Mul(poly2->m_R, vert2s[vertexIndex2])
		tMat = poly2.m_R
dim 		 v2X  as variant = poly2.m_position.x + (tMat.col1.x * vert2s[vertexIndex2].x + tMat.col2.x * vert2s[vertexIndex2].y)
dim 		 v2Y  as variant = poly2.m_position.y + (tMat.col1.y * vert2s[vertexIndex2].x + tMat.col2.y * vert2s[vertexIndex2].y)
		' // var separation = b2Math.b2Dot( b2Math.SubtractVV( v2, v1 ) , normal)
		v2X -= v1X
		v2Y -= v1Y
		' // var separation = b2Math.b2Dot( v2 , normal)
dim 		 separation  as variant = v2X * normalX + v2Y * normalY

		return separation
 '' TODO: posible funcion (revisar)

end

public  sub FindMaxSeparation (edgeIndex ' /* int ptr*/ as variant, poly1 as variant, poly2 as variant, conservative as variant) as variant ''funcio as variant ''funcio as variant ''funcio as variant ''funcio as variant ''funcio as variant ''funcion
dim 		 count1  as variant = poly1.m_vertexCount

		' //  Vector pointing from the origin of poly1 to the origin of poly2.
		' // var d = b2Math.SubtractVV( poly2.m_position, poly1.m_position )
dim 		 dX  as variant = poly2.m_position.x - poly1.m_position.x

dim 		 dY  as variant = poly2.m_position.y - poly1.m_position.y

		' // var dLocal1 = b2Math.b2MulTMV(poly1.m_R, d)
dim 		 dLocal1X  as variant = (dX * poly1.m_R.col1.x + dY * poly1.m_R.col1.y)

dim 		 dLocal1Y  as variant = (dX * poly1.m_R.col2.x + dY * poly1.m_R.col2.y)

		' //  Get support vertex hint for our search
dim 		 edge  as variant = 0

dim 		 maxDot  as variant = -Number.MAX_VALUE

		for (var i = 0; i < count1; ++i)
			' // var dot = b2Math.b2Dot(poly.m_normals[i], dLocal1)
dim 			 dot  as variant = (poly1.m_normals[i].x * dLocal1X + poly1.m_normals[i].y * dLocal1Y)

			if (dot > maxDot)
			
				maxDot = dot
				edge = i
			
		' //  Get the separation for the edge normal.
dim 		 s  as variant = b2Collision.EdgeSeparation(poly1, edge, poly2)

		if (s > 0.0 && conservative == false)
			return s
 '' TODO: posible funcion (revisar)

		' //  Check the separation for the neighboring edges.
dim 		 prevEdge  as variant = edge - 1 >= 0 ? edge - 1 : count1 - 1

dim 		 sPrev  as variant = b2Collision.EdgeSeparation(poly1, prevEdge, poly2)

		if (sPrev > 0.0 && conservative == false)
			return sPrev
 '' TODO: posible funcion (revisar)

dim 		 nextEdge  as variant = edge + 1 < count1 ? edge + 1 : 0

dim 		 sNext  as variant = b2Collision.EdgeSeparation(poly1, nextEdge, poly2)

		if (sNext > 0.0 && conservative == false)
			return sNext
 '' TODO: posible funcion (revisar)

		' //  Find the best edge and the search direction.
dim 		 bestEdge  as variant = 0

dim 		bestSeparation
 as variant
dim 		 increment  as variant = 0

		if (sPrev > s && sPrev > sNext)
			increment = -1
			bestEdge = prevEdge
			bestSeparation = sPrev
		else if (sNext > s)
			increment = 1
			bestEdge = nextEdge
			bestSeparation = sNext
		else
			' //  pointer out
			edgeIndex[0] = edge
			return s
 '' TODO: posible funcion (revisar)

		while (true)
			if (increment == -1)
				edge = bestEdge - 1 >= 0 ? bestEdge - 1 : count1 - 1
			else
				edge = bestEdge + 1 < count1 ? bestEdge + 1 : 0
			s = b2Collision.EdgeSeparation(poly1, edge, poly2)
			if (s > 0.0 && conservative == false)
			
				return s
 '' TODO: posible funcion (revisar)

			
			if (s > bestSeparation)
			
				bestEdge = edge
				bestSeparation = s
			
			else
			
				break
			
		' //  pointer out
		edgeIndex[0] = bestEdge
		return bestSeparation
 '' TODO: posible funcion (revisar)

end

public  sub FindIncidentEdge (c as variant, poly1 as variant, edge1 as variant, poly2 as variant)

dim 		 count1  as variant = poly1.m_vertexCount

dim 		 vert1s  as variant = poly1.m_vertices

dim 		 count2  as variant = poly2.m_vertexCount

dim 		 vert2s  as variant = poly2.m_vertices

		' //  Get the vertices associated with edge1.
dim 		 vertex11  as variant = edge1

dim 		 vertex12  as variant = edge1 + 1 == count1 ? 0 : edge1 + 1

		' //  Get the normal of edge1.
dim 		 tVec  as variant = vert1s[vertex12]

		' // var normal1Local1 = b2Math.b2CrossVF( b2Math.SubtractVV( vert1s[vertex12], vert1s[vertex11] ), 1.0)
dim 		 normal1Local1X  as variant = tVec.x

dim 		 normal1Local1Y  as variant = tVec.y

		tVec = vert1s[vertex11]
		normal1Local1X -= tVec.x
		normal1Local1Y -= tVec.y
dim 		 tX  as variant = normal1Local1X

		normal1Local1X = normal1Local1Y
		normal1Local1Y = -tX
		' //  ^^^^ normal1Local1.CrossVF(1.0)
dim 		 invLength  as variant = 1.0 / Math.sqrt(normal1Local1X*normal1Local1X + normal1Local1Y*normal1Local1Y)

		normal1Local1X *= invLength
		normal1Local1Y *= invLength
		' //  ^^^^normal1Local1.Normalize()
		' // var normal1 = b2Math.b2MulMV(poly1.m_R, normal1Local1)
dim 		 normal1X  as variant = normal1Local1X

dim 		 normal1Y  as variant = normal1Local1Y

		tX = normal1X
dim 		 tMat  as variant = poly1.m_R

		normal1X = tMat.col1.x * tX + tMat.col2.x * normal1Y
		normal1Y = tMat.col1.y * tX + tMat.col2.y * normal1Y
		' //  ^^^^ normal1.MulM(poly1.m_R)
		' // var normal1Local2 = b2Math.b2MulTMV(poly2.m_R, normal1)
dim 		 normal1Local2X  as variant = normal1X

dim 		 normal1Local2Y  as variant = normal1Y

		tMat = poly2.m_R
		tX = normal1Local2X * tMat.col1.x + normal1Local2Y * tMat.col1.y
		normal1Local2Y = normal1Local2X * tMat.col2.x + normal1Local2Y * tMat.col2.y
		normal1Local2X = tX
		' //  ^^^^ normal1Local2.MulTM(poly2.m_R)
		' //  Find the incident edge on poly2.
dim 		 vertex21  as variant = 0

dim 		 vertex22  as variant = 0

dim 		 minDot  as variant = Number.MAX_VALUE

		for (var i = 0; i < count2; ++i)
dim 			 i1  as variant = i

dim 			 i2  as variant = i + 1 < count2 ? i + 1 : 0

			' // var normal2Local2 = b2Math.b2CrossVF( b2Math.SubtractVV( vert2s[i2], vert2s[i1] ), 1.0)
			tVec = vert2s[i2]
dim 			 normal2Local2X  as variant = tVec.x

dim 			 normal2Local2Y  as variant = tVec.y

			tVec = vert2s[i1]
			normal2Local2X -= tVec.x
			normal2Local2Y -= tVec.y
			tX = normal2Local2X
			normal2Local2X = normal2Local2Y
			normal2Local2Y = -tX
			' //  ^^^^ normal2Local2.CrossVF(1.0)
			invLength = 1.0 / Math.sqrt(normal2Local2X*normal2Local2X + normal2Local2Y*normal2Local2Y)
			normal2Local2X *= invLength
			normal2Local2Y *= invLength
			' //  ^^^^ normal2Local2.Normalize()
			' // var dot = b2Math.b2Dot(normal2Local2, normal1Local2)
dim 			 dot  as variant = normal2Local2X * normal1Local2X + normal2Local2Y * normal1Local2Y

			if (dot < minDot)
			
				minDot = dot
				vertex21 = i1
				vertex22 = i2
			
dim 		tClip
 as variant
		' //  Build the clip vertices for the incident edge.
		tClip = c[0]
		' // tClip.v = b2Math.AddVV(poly2.m_position, b2Math.b2MulMV(poly2.m_R, vert2s[vertex21]))
		tVec = tClip.v
		tVec.SetV(vert2s[vertex21])
		tVec.MulM(poly2.m_R)
		tVec.Add(poly2.m_position)
		tClip.id.features.referenceFace = edge1
		tClip.id.features.incidentEdge = vertex21
		tClip.id.features.incidentVertex = vertex21
		tClip = c[1]
		' // tClip.v = b2Math.AddVV(poly2.m_position, b2Math.b2MulMV(poly2.m_R, vert2s[vertex22]))
		tVec = tClip.v
		tVec.SetV(vert2s[vertex22])
		tVec.MulM(poly2.m_R)
		tVec.Add(poly2.m_position)
		tClip.id.features.referenceFace = edge1
		tClip.id.features.incidentEdge = vertex21
		tClip.id.features.incidentVertex = vertex22
b2Collision.b2CollidePolyTempVec = new b2Vec2()
end

public  sub b2CollidePoly (manifold as variant, polyA as variant, polyB as variant, conservative as variant) as variant ''funcio as variant ''funcio as variant ''funcio as variant ''funcion
		manifold.pointCount = 0
dim 		 edgeA  as variant = 0

dim 		 edgeAOut  as variant = [edgeA]

dim 		 separationA  as variant = b2Collision.FindMaxSeparation(edgeAOut, polyA, polyB, conservative)

		edgeA = edgeAOut[0]
		if (separationA > 0.0 && conservative == false)
			return
 '' TODO: posible funcion (revisar)

dim 		 edgeB  as variant = 0

dim 		 edgeBOut  as variant = [edgeB]

dim 		 separationB  as variant = b2Collision.FindMaxSeparation(edgeBOut, polyB, polyA, conservative)

		edgeB = edgeBOut[0]
		if (separationB > 0.0 && conservative == false)
			return
 '' TODO: posible funcion (revisar)

dim 		poly1
 as variant
dim 		poly2
 as variant
dim 		 edge1  as variant = 0

dim 		 flip  as variant = 0

dim 		 k_relativeTol  as variant = 0.98

dim 		 k_absoluteTol  as variant = 0.001

		' //  TODO_ERIN use "radius" of poly for absolute tolerance.
		if (separationB > k_relativeTol * separationA + k_absoluteTol)
			poly1 = polyB
			poly2 = polyA
			edge1 = edgeB
			flip = 1
		else
			poly1 = polyA
			poly2 = polyB
			edge1 = edgeA
			flip = 0
dim 		 incidentEdge  as variant = [new ClipVertex(), new ClipVertex()]

		b2Collision.FindIncidentEdge(incidentEdge, poly1, edge1, poly2)
dim 		 count1  as variant = poly1.m_vertexCount

dim 		 vert1s  as variant = poly1.m_vertices

dim 		 v11  as variant = vert1s[edge1]

dim 		 v12  as variant = edge1 + 1 < count1 ? vert1s[edge1+1] : vert1s[0]

		' // var dv = b2Math.SubtractVV(v12, v11)
dim 		 dvX  as variant = v12.x - v11.x

dim 		 dvY  as variant = v12.y - v11.y

		' // var sideNormal = b2Math.b2MulMV(poly1.m_R, b2Math.SubtractVV(v12, v11))
dim 		 sideNormalX  as variant = v12.x - v11.x

dim 		 sideNormalY  as variant = v12.y - v11.y

dim 		 tX  as variant = sideNormalX

dim 		 tMat  as variant = poly1.m_R

		sideNormalX = tMat.col1.x * tX + tMat.col2.x * sideNormalY
		sideNormalY = tMat.col1.y * tX + tMat.col2.y * sideNormalY
		' //  ^^^^ sideNormal.MulM(poly1.m_R)
dim 		 invLength  as variant = 1.0 / Math.sqrt(sideNormalX*sideNormalX + sideNormalY*sideNormalY)

		sideNormalX *= invLength
		sideNormalY *= invLength
		' //  ^^^^ sideNormal.Normalize()
		' // var frontNormal = b2Math.b2CrossVF(sideNormal, 1.0)
dim 		 frontNormalX  as variant = sideNormalX

dim 		 frontNormalY  as variant = sideNormalY

		tX = frontNormalX
		frontNormalX = frontNormalY
		frontNormalY = -tX
		' //  ^^^^ frontNormal.CrossVF(1.0)
		' //  Expanded for performance
		' // v11 = b2Math.AddVV(poly1.m_position, b2Math.b2MulMV(poly1.m_R, v11))
dim 		 v11X  as variant = v11.x

dim 		 v11Y  as variant = v11.y

		tX = v11X
		tMat = poly1.m_R
		v11X = tMat.col1.x * tX + tMat.col2.x * v11Y
		v11Y = tMat.col1.y * tX + tMat.col2.y * v11Y
		' //  ^^^^ v11.MulM(poly1.m_R)
		v11X += poly1.m_position.x
		v11Y += poly1.m_position.y
		' // v12 = b2Math.AddVV(poly1.m_position, b2Math.b2MulMV(poly1.m_R, v12))
dim 		 v12X  as variant = v12.x

dim 		 v12Y  as variant = v12.y

		tX = v12X
		tMat = poly1.m_R
		v12X = tMat.col1.x * tX + tMat.col2.x * v12Y
		v12Y = tMat.col1.y * tX + tMat.col2.y * v12Y
		' //  ^^^^ v12.MulM(poly1.m_R)
		v12X += poly1.m_position.x
		v12Y += poly1.m_position.y
		' // var frontOffset = b2Math.b2Dot(frontNormal, v11)
dim 		 frontOffset  as variant = frontNormalX * v11X + frontNormalY * v11Y

		' // var sideOffset1 = -b2Math.b2Dot(sideNormal, v11)
dim 		 sideOffset1  as variant = -(sideNormalX * v11X + sideNormalY * v11Y)

		' // var sideOffset2 = b2Math.b2Dot(sideNormal, v12)
dim 		 sideOffset2  as variant = sideNormalX * v12X + sideNormalY * v12Y

		' //  Clip incident edge against extruded edge1 side edges.
dim 		 clipPoints1  as variant = [new ClipVertex(), new ClipVertex()]

dim 		 clipPoints2  as variant = [new ClipVertex(), new ClipVertex()]

dim 		 np  as variant = 0

		' //  Clip to box side 1
		b2Collision.b2CollidePolyTempVec.Set(-sideNormalX, -sideNormalY)
		np = b2Collision.ClipSegmentToLine(clipPoints1, incidentEdge, b2Collision.b2CollidePolyTempVec, sideOffset1)
		if (np < 2)
			return
 '' TODO: posible funcion (revisar)

		' //  Clip to negative box side 1
		b2Collision.b2CollidePolyTempVec.Set(sideNormalX, sideNormalY)
		np = b2Collision.ClipSegmentToLine(clipPoints2, clipPoints1,  b2Collision.b2CollidePolyTempVec, sideOffset2)
		if (np < 2)
			return
 '' TODO: posible funcion (revisar)

		' //  Now clipPoints2 contains the clipped points.
		if (flip)
			manifold.normal.Set(-frontNormalX, -frontNormalY)
		else
			manifold.normal.Set(frontNormalX, frontNormalY)
		' //  ^^^^ manifold.normal = flip ? frontNormal.Negative() : frontNormal
dim 		 pointCount  as variant = 0

		for (var i = 0; i < b2Settings.b2_maxManifoldPoints; ++i)
			' // var separation = b2Math.b2Dot(frontNormal, clipPoints2[i].v) - frontOffset
dim 			 tVec  as variant = clipPoints2[i].v

dim 			 separation  as variant = (frontNormalX * tVec.x + frontNormalY * tVec.y) - frontOffset

			if (separation <= 0.0 || conservative == true)
			
dim 				 cp  as variant = manifold.points[ pointCount ]

				cp.separation = separation
				cp.position.SetV( clipPoints2[i].v )
				cp.id.Set( clipPoints2[i].id )
				cp.id.features.flip = flip
				++pointCount
			
		manifold.pointCount = pointCount
end

public  sub b2CollideCircle (manifold as variant, circle1 as variant, circle2 as variant, conservative as variant) as variant ''funcion
		manifold.pointCount = 0
		' // var d = b2Math.SubtractVV(circle2.m_position, circle1.m_position)
dim 		 dX  as variant = circle2.m_position.x - circle1.m_position.x

dim 		 dY  as variant = circle2.m_position.y - circle1.m_position.y

		' // var distSqr = b2Math.b2Dot(d, d)
dim 		 distSqr  as variant = dX * dX + dY * dY

dim 		 radiusSum  as variant = circle1.m_radius + circle2.m_radius

		if (distSqr > radiusSum * radiusSum && conservative == false)
			return
 '' TODO: posible funcion (revisar)

dim 		separation
 as variant
		if (distSqr < Number.MIN_VALUE)
			separation = -radiusSum
			manifold.normal.Set(0.0, 1.0)
		else
dim 			 dist  as variant = Math.sqrt(distSqr)

			separation = dist - radiusSum
dim 			 a  as variant = 1.0 / dist

			manifold.normal.x = a * dX
			manifold.normal.y = a * dY
		manifold.pointCount = 1
dim 		 tPoint  as variant = manifold.points[0]

		tPoint.id.set_key(0)
		tPoint.separation = separation
		' // tPoint.position = b2Math.SubtractVV(circle2.m_position, b2Math.MulFV(circle2.m_radius, manifold.normal))
		tPoint.position.x = circle2.m_position.x - (circle2.m_radius * manifold.normal.x)
		tPoint.position.y = circle2.m_position.y - (circle2.m_radius * manifold.normal.y)
end

public  sub b2CollidePolyAndCircle (manifold as variant, poly as variant, circle as variant, conservative as variant) as variant ''funcio as variant ''funcio as variant ''funcio as variant ''funcio as variant ''funcion
		manifold.pointCount = 0
dim 		tPoint
 as variant
dim 		dX
 as variant
dim 		dY
 as variant
		' //  Compute circle position in the frame of the polygon.
		' // var xLocal = b2Math.b2MulTMV(poly.m_R, b2Math.SubtractVV(circle.m_position, poly.m_position))
dim 		 xLocalX  as variant = circle.m_position.x - poly.m_position.x

dim 		 xLocalY  as variant = circle.m_position.y - poly.m_position.y

dim 		 tMat  as variant = poly.m_R

dim 		 tX  as variant = xLocalX * tMat.col1.x + xLocalY * tMat.col1.y

		xLocalY = xLocalX * tMat.col2.x + xLocalY * tMat.col2.y
		xLocalX = tX
dim 		dist
 as variant
		' //  Find the min separating edge.
dim 		 normalIndex  as variant = 0

dim 		 separation  as variant = -Number.MAX_VALUE

dim 		 radius  as variant = circle.m_radius

		for (var i = 0; i < poly.m_vertexCount; ++i)
			' // var s = b2Math.b2Dot(poly.m_normals[i], b2Math.SubtractVV(xLocal, poly.m_vertices[i]))
dim 			 s  as variant = poly.m_normals[i].x * (xLocalX-poly.m_vertices[i].x) + poly.m_normals[i].y * (xLocalY-poly.m_vertices[i].y)

			if (s > radius)
			
				' //  Early out.
				return
 '' TODO: posible funcion (revisar)

			
			if (s > separation)
			
				separation = s
				normalIndex = i
			
		' //  If the center is inside the polygon ...
		if (separation < Number.MIN_VALUE)
			manifold.pointCount = 1
			' // manifold.normal = b2Math.b2MulMV(poly.m_R, poly.m_normals[normalIndex])
dim 			 tVec  as variant = poly.m_normals[normalIndex]

			manifold.normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y
			manifold.normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y
			tPoint = manifold.points[0]
			tPoint.id.features.incidentEdge = normalIndex
			tPoint.id.features.incidentVertex = b2Collision.b2_nullFeature
			tPoint.id.features.referenceFace = b2Collision.b2_nullFeature
			tPoint.id.features.flip = 0
			tPoint.position.x = circle.m_position.x - radius * manifold.normal.x
			tPoint.position.y = circle.m_position.y - radius * manifold.normal.y
			' // tPoint.position = b2Math.SubtractVV(circle.m_position , b2Math.MulFV(radius , manifold.normal))
			tPoint.separation = separation - radius
			return
 '' TODO: posible funcion (revisar)

		' //  Project the circle center onto the edge segment.
dim 		 vertIndex1  as variant = normalIndex

dim 		 vertIndex2  as variant = vertIndex1 + 1 < poly.m_vertexCount ? vertIndex1 + 1 : 0

		' // var e = b2Math.SubtractVV(poly.m_vertices[vertIndex2] , poly.m_vertices[vertIndex1])
dim 		 eX  as variant = poly.m_vertices[vertIndex2].x - poly.m_vertices[vertIndex1].x

dim 		 eY  as variant = poly.m_vertices[vertIndex2].y - poly.m_vertices[vertIndex1].y

		' // var length = e.Normalize()
dim 		 length  as variant = Math.sqrt(eX*eX + eY*eY)

		eX /= length
		eY /= length
		' //  If the edge length is zero ...
		if (length < Number.MIN_VALUE)
			' // d = b2Math.SubtractVV(xLocal , poly.m_vertices[vertIndex1])
			dX = xLocalX - poly.m_vertices[vertIndex1].x
			dY = xLocalY - poly.m_vertices[vertIndex1].y
			' // dist = d.Normalize()
			dist = Math.sqrt(dX*dX + dY*dY)
			dX /= dist
			dY /= dist
			if (dist > radius)
			
				return
 '' TODO: posible funcion (revisar)

			
			manifold.pointCount = 1
			' // manifold.normal = b2Math.b2MulMV(poly.m_R, d)
			manifold.normal.Set(tMat.col1.x * dX + tMat.col2.x * dY, tMat.col1.y * dX + tMat.col2.y * dY)
			tPoint = manifold.points[0]
			tPoint.id.features.incidentEdge = b2Collision.b2_nullFeature
			tPoint.id.features.incidentVertex = vertIndex1
			tPoint.id.features.referenceFace = b2Collision.b2_nullFeature
			tPoint.id.features.flip = 0
			' // tPoint.position = b2Math.SubtractVV(circle.m_position , b2Math.MulFV(radius , manifold.normal))
			tPoint.position.x = circle.m_position.x - radius * manifold.normal.x
			tPoint.position.y = circle.m_position.y - radius * manifold.normal.y
			tPoint.separation = dist - radius
			return
 '' TODO: posible funcion (revisar)

		' //  Project the center onto the edge.
		' // var u = b2Math.b2Dot(b2Math.SubtractVV(xLocal , poly.m_vertices[vertIndex1]) , e)
dim 		 u  as variant = (xLocalX-poly.m_vertices[vertIndex1].x) * eX + (xLocalY-poly.m_vertices[vertIndex1].y) * eY

		tPoint = manifold.points[0]
		tPoint.id.features.incidentEdge = b2Collision.b2_nullFeature
		tPoint.id.features.incidentVertex = b2Collision.b2_nullFeature
		tPoint.id.features.referenceFace = b2Collision.b2_nullFeature
		tPoint.id.features.flip = 0
dim 		pX, pY
 as variant
		if (u <= 0.0)
			pX = poly.m_vertices[vertIndex1].x
			pY = poly.m_vertices[vertIndex1].y
			tPoint.id.features.incidentVertex = vertIndex1
		else if (u >= length)
			pX = poly.m_vertices[vertIndex2].x
			pY = poly.m_vertices[vertIndex2].y
			tPoint.id.features.incidentVertex = vertIndex2
		else
			' // p = b2Math.AddVV(poly.m_vertices[vertIndex1] , b2Math.MulFV(u, e))
			pX = eX * u + poly.m_vertices[vertIndex1].x
			pY = eY * u + poly.m_vertices[vertIndex1].y
			tPoint.id.features.incidentEdge = vertIndex1
		' // d = b2Math.SubtractVV(xLocal , p)
		dX = xLocalX - pX
		dY = xLocalY - pY
		' // dist = d.Normalize()
		dist = Math.sqrt(dX*dX + dY*dY)
		dX /= dist
		dY /= dist
		if (dist > radius)
			return
 '' TODO: posible funcion (revisar)

		manifold.pointCount = 1
		' // manifold.normal = b2Math.b2MulMV(poly.m_R, d)
		manifold.normal.Set(tMat.col1.x * dX + tMat.col2.x * dY, tMat.col1.y * dX + tMat.col2.y * dY)
		' // tPoint.position = b2Math.SubtractVV(circle.m_position , b2Math.MulFV(radius , manifold.normal))
		tPoint.position.x = circle.m_position.x - radius * manifold.normal.x
		tPoint.position.y = circle.m_position.y - radius * manifold.normal.y
		tPoint.separation = dist - radius
end

public  sub b2TestOverlap (a as variant, b as variant) as variant ''funcio as variant ''funcio as variant ''funcion
dim 		 t1  as variant = b.minVertex

dim 		 t2  as variant = a.maxVertex

		' // d1 = b2Math.SubtractVV(b.minVertex, a.maxVertex)
dim 		 d1X  as variant = t1.x - t2.x

dim 		 d1Y  as variant = t1.y - t2.y

		' // d2 = b2Math.SubtractVV(a.minVertex, b.maxVertex)
		t1 = a.minVertex
		t2 = b.maxVertex
dim 		 d2X  as variant = t1.x - t2.x

dim 		 d2Y  as variant = t1.y - t2.y

		if (d1X > 0.0 || d1Y > 0.0)
			return false
 '' TODO: posible funcion (revisar)

		if (d2X > 0.0 || d2Y > 0.0)
			return false
 '' TODO: posible funcion (revisar)

		return true
 '' TODO: posible funcion (revisar)
