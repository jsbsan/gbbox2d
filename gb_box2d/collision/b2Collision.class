 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not   
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.

	' //  Null feature
	' //  Find the separation between poly1 and poly2 for a give edge normal on poly1.
	' //  Find the max separation between poly1 and poly2 using edge normals
	' //  from poly1.
	' //  Find edge normal of max separation on A - return if separating axis is found '' TODO: posible funcion (revisar)

	' //  Find edge normal of max separation on B - return if separation axis is found '' TODO: posible funcion (revisar)

	' //  Choose reference edge(minA, minB)
	' //  Find incident edge
	' //  Clip
	' //  The normal points from 1 to 2


public b2CollidePolyTempVec = new b2Vec2()


public  sub 	_new()
 b2_nullFeature = 0x000000ff
end

public  sub ClipSegmentToLine (vOut as variant, vIn as variant, normal as variant, offset as variant) as variant ''funcion
		' //  Start with no output points
dim 		 numOut  as variant = 0

dim 		 vIn0  as variant = vIn[0].v

dim 		 vIn1  as variant = vIn[1].v

		' //  Calculate the distance of end points to the line
dim 		 distance0  as variant = b2Math.b2Dot(normal, vIn[0].v) - offset

dim 		 distance1  as variant = b2Math.b2Dot(normal, vIn[1].v) - offset



dim 			 interp  as variant 
dim 			 tVec  as variant
		' //  If the points are behind the plane
		numOut+=1
		if (distance0 <= 0.0) then vOut[numOut] = vIn[0]
		if (distance1 <= 0.0) then vOut[numOut] = vIn[1]
		' //  If the points are on different sides of the plane
		if (distance0 * distance1 < 0.0) then 
			' //  Find intersection point of edge and plane
		 interp   = distance0 / (distance0 - distance1)

			' //  expanded for performance
     	 tVec   = vOut[numOut].v

			tVec.x = vIn0.x + interp * (vIn1.x - vIn0.x)
			tVec.y = vIn0.y + interp * (vIn1.y - vIn0.y)
			if (distance0 > 0.0) then
			
				vOut[numOut].id = vIn[0].id
			
			else
			
				vOut[numOut].id = vIn[1].id
			endif
			
			numOut+=1
		endif
			
		return numOut
 '' TODO: posible funcion (revisar)

end

public  sub EdgeSeparation (poly1 as variant, edge1 as variant, poly2 as variant) as variant ''funcion
dim 		 vert1s  as variant = poly1.m_vertices

dim 		 count2  as variant = poly2.m_vertexCount

dim 		 vert2s  as variant = poly2.m_vertices

		' //  Convert normal from into poly2's frame.
		' // b2Settings.b2Assert(edge1 < poly1.m_vertexCount)
		' // var normal = b2Math.b2MulMV(poly1.m_R, poly1->m_normals[edge1])
dim 		 normalX  as variant = poly1.m_normals[edge1].x

dim 		 normalY  as variant = poly1.m_normals[edge1].y

dim 		 tX  as variant = normalX

dim 		 tMat  as variant = poly1.m_R

dim 		 normalLocal2X  as variant

dim 		 normalLocal2Y  as variant

dim 		 vertexIndex2  as variant
dim 		 minDot  as variant 
dim i as integer
dim 			 tVec  as variant 
dim 			 dot  as variant

dim 		 v1X  as variant 
dim 		 v1Y  as variant 
dim 		 v2X  as variant
dim 		 v2Y  as variant
dim 		 separation  as variant

		normalX = tMat.col1.x * tX + tMat.col2.x * normalY
		normalY = tMat.col1.y * tX + tMat.col2.y * normalY
		' //  ^^^^^^^ normal.MulM(poly1.m_R)
		' // var normalLocal2 = b2Math.b2MulTMV(poly2.m_R, normal)
		 normalLocal2X   = normalX

 		 normalLocal2Y   = normalY

		tMat = poly2.m_R
		tX = normalLocal2X * tMat.col1.x + normalLocal2Y * tMat.col1.y
		normalLocal2Y = normalLocal2X * tMat.col2.x + normalLocal2Y * tMat.col2.y
		normalLocal2X = tX
		' //  ^^^^^ normalLocal2.MulTM(poly2.m_R)
		' //  Find support vertex on poly2 for -normal.
 		 vertexIndex2   = 0

 		 minDot   = Number.MAX_VALUE

		for  i = 0 to  count2
			' // var dot = b2Math.b2Dot(vert2s[i], normalLocal2)
 			tVec   = vert2s[i]

 			 dot   = tVec.x * normalLocal2X + tVec.y * normalLocal2Y

			if (dot < minDot) then
			
				minDot = dot
				vertexIndex2 = i
			endif
		nextEdge
		
		' // b2Vec2 v1 = poly1->m_position + b2Mul(poly1->m_R, vert1s[edge1])
		tMat = poly1.m_R
 		 v1X   = poly1.m_position.x + (tMat.col1.x * vert1s[edge1].x + tMat.col2.x * vert1s[edge1].y)
 		 v1Y   = poly1.m_position.y + (tMat.col1.y * vert1s[edge1].x + tMat.col2.y * vert1s[edge1].y)
		' // b2Vec2 v2 = poly2->m_position + b2Mul(poly2->m_R, vert2s[vertexIndex2])
		tMat = poly2.m_R
 		 v2X   = poly2.m_position.x + (tMat.col1.x * vert2s[vertexIndex2].x + tMat.col2.x * vert2s[vertexIndex2].y)
 		 v2Y  = poly2.m_position.y + (tMat.col1.y * vert2s[vertexIndex2].x + tMat.col2.y * vert2s[vertexIndex2].y)
		' // var separation = b2Math.b2Dot( b2Math.SubtractVV( v2, v1 ) , normal)
		v2X -= v1X
		v2Y -= v1Y
		' // var separation = b2Math.b2Dot( v2 , normal)
 		 separation   = v2X * normalX + v2Y * normalY

		return separation

end

public  sub FindMaxSeparation (edgeIndex ' /* int ptr*/ as variant, poly1 as variant, poly2 as variant, conservative as variant) as variant ''funcio as variant ''funcio as variant ''funcio as variant ''funcio as variant ''funcio as variant ''funcion
dim 		 count1  as variant = poly1.m_vertexCount

		' //  Vector pointing from the origin of poly1 to the origin of poly2.
		' // var d = b2Math.SubtractVV( poly2.m_position, poly1.m_position )
dim 		 dX  as variant = poly2.m_position.x - poly1.m_position.x

dim 		 dY  as variant = poly2.m_position.y - poly1.m_position.y

		' // var dLocal1 = b2Math.b2MulTMV(poly1.m_R, d)
dim 		 dLocal1X  as variant = (dX * poly1.m_R.col1.x + dY * poly1.m_R.col1.y)

dim 		 dLocal1Y  as variant = (dX * poly1.m_R.col2.x + dY * poly1.m_R.col2.y)

		' //  Get support vertex hint for our search
dim 		 edge  as variant = 0

dim 		 maxDot  as variant = -Number.MAX_VALUE


dim i as integer
dim 			 dot  as variant 
dim 		 s  as variant

  dim 		 prevEdge  as variant
  dim 		 sPrev  as variant
  dim 		 nextEdge  as variant
  dim 		 sNext  as variant
  dim 		 bestEdge  as variant
  dim 		bestSeparation  as variant
  dim 		 increment  as variant 


		for i = 0 to  count1
			' // var dot = b2Math.b2Dot(poly.m_normals[i], dLocal1)
			 dot   = (poly1.m_normals[i].x * dLocal1X + poly1.m_normals[i].y * dLocal1Y)

			if (dot > maxDot) then 
			
				maxDot = dot
				edge = i
			endif
		 next	
		' //  Get the separation for the edge normal.
		 s   = b2Collision.EdgeSeparation(poly1, edge, poly2)
		
		 
		if (s > 0.0 && conservative = false) then 
			return s
		endif
		
 '' TODO: posible funcion (revisar)

		' //  Check the separation for the neighboring edges.
 		 prevEdge   =if( edge - 1 >= 0 , edge -= 1, count1 - 1)

 		 sPrev   = b2Collision.EdgeSeparation(poly1, prevEdge, poly2)

		if (sPrev > 0.0 & conservative = false)
			return sPrev
		endif

 		 nextEdge   = if( edge + 1 < count1, edge + 1, 0)

 		 sNext   = b2Collision.EdgeSeparation(poly1, nextEdge, poly2)

		if (sNext > 0.0 & conservative = false)
			return sNext
 		endif

		' //  Find the best edge and the search direction.
 		 bestEdge   = 0

 	
 		 increment   = 0

		if (sPrev > s & sPrev > sNext) then
			increment = -1
			bestEdge = prevEdge
			bestSeparation = sPrev
		else
		if (sNext > s) then
			increment = 1
			bestEdge = nextEdge
			bestSeparation = sNext
		else
			' //  pointer out
			edgeIndex[0] = edge
			return s
		endif
		endif
		
 

		while (true)
			if (increment = -1) then 
				edge =if( bestEdge - 1 >= 0 , bestEdge - 1 , count1 - 1)
			else
				edge = if(bestEdge + 1 < count1 , bestEdge + 1 , 0)
			s = b2Collision.EdgeSeparation(poly1, edge, poly2)
			if (s > 0.0 & conservative = false)
							return s
				endif
				
 '' TODO: posible funcion (revisar)

			
			if (s > bestSeparation) then 
			
				bestEdge = edge
				bestSeparation = s
			
			else
			
				break
			endif
		wend
		
		' //  pointer out
		edgeIndex[0] = bestEdge
		return bestSeparation
end

public  sub FindIncidentEdge (c as variant, poly1 as variant, edge1 as variant, poly2 as variant)

dim 		 count1  as variant = poly1.m_vertexCount

dim 		 vert1s  as variant = poly1.m_vertices

dim 		 count2  as variant = poly2.m_vertexCount

dim 		 vert2s  as variant = poly2.m_vertices

		' //  Get the vertices associated with edge1.
dim 		 vertex11  as variant = edge1

dim 		 vertex12  as variant = edge1 + 1 == count1 ? 0 : edge1 + 1

		' //  Get the normal of edge1.
dim 		 tVec  as variant = vert1s[vertex12]

		' // var normal1Local1 = b2Math.b2CrossVF( b2Math.SubtractVV( vert1s[vertex12], vert1s[vertex11] ), 1.0)
dim 		 normal1Local1X  as variant = tVec.x

dim 		 normal1Local1Y  as variant = tVec.y


dim 		 tX  as variant
dim 		 invLength  as variant
dim 		 normal1X  as variant
dim 		 normal1Y  as variant
dim 		 tMat  as variant

dim 		 normal1Local2X  as variant 
dim 		 normal1Local2Y  as variant 
dim 		 vertex21  as variant
dim 		 vertex22  as variant
dim 		 minDot  as variant
dim i as integer
dim 			 i1  as variant
dim 			 i2  as variant
dim 			 normal2Local2X  as variant
dim 			 normal2Local2Y  as variant
dim 			 dot  as variant 
dim 		tClip  as variant


		tVec = vert1s[vertex11]
		normal1Local1X -= tVec.x
		normal1Local1Y -= tVec.y
		
 		 tX  = normal1Local1X

		normal1Local1X = normal1Local1Y
		normal1Local1Y = -tX
		' //  ^^^^ normal1Local1.CrossVF(1.0)
 		 invLength  = 1.0 / Math.sqrt(normal1Local1X*normal1Local1X + normal1Local1Y*normal1Local1Y)

		normal1Local1X *= invLength
		normal1Local1Y *= invLength
		' //  ^^^^normal1Local1.Normalize()
		' // var normal1 = b2Math.b2MulMV(poly1.m_R, normal1Local1)
 		 normal1X  = normal1Local1X

 		 normal1Y  = normal1Local1Y

		tX = normal1X
 		 tMat  = poly1.m_R

		normal1X = tMat.col1.x * tX + tMat.col2.x * normal1Y
		normal1Y = tMat.col1.y * tX + tMat.col2.y * normal1Y
		' //  ^^^^ normal1.MulM(poly1.m_R)
		' // var normal1Local2 = b2Math.b2MulTMV(poly2.m_R, normal1)
 		 normal1Local2X  = normal1X

 		 normal1Local2Y  = normal1Y

		tMat = poly2.m_R
		tX = normal1Local2X * tMat.col1.x + normal1Local2Y * tMat.col1.y
		normal1Local2Y = normal1Local2X * tMat.col2.x + normal1Local2Y * tMat.col2.y
		normal1Local2X = tX
		' //  ^^^^ normal1Local2.MulTM(poly2.m_R)
		' //  Find the incident edge on poly2.
 		 vertex21  = 0

 		 vertex22  = 0

 		 minDot  = Number.MAX_VALUE

		for  i = 0 to i count2
 			 i1  = i

 			 i2  = if(i + 1 < count2 , i + 1 , 0)

			' // var normal2Local2 = b2Math.b2CrossVF( b2Math.SubtractVV( vert2s[i2], vert2s[i1] ), 1.0)
			tVec = vert2s[i2]
 			 normal2Local2X  = tVec.x

 			 normal2Local2Y  = tVec.y

			tVec = vert2s[i1]
			normal2Local2X -= tVec.x
			normal2Local2Y -= tVec.y
			tX = normal2Local2X
			normal2Local2X = normal2Local2Y
			normal2Local2Y = -tX
			' //  ^^^^ normal2Local2.CrossVF(1.0)
			invLength = 1.0 / Math.sqrt(normal2Local2X*normal2Local2X + normal2Local2Y*normal2Local2Y)
			normal2Local2X *= invLength
			normal2Local2Y *= invLength
			' //  ^^^^ normal2Local2.Normalize()
			' // var dot = b2Math.b2Dot(normal2Local2, normal1Local2)
 			 dot  = normal2Local2X * normal1Local2X + normal2Local2Y * normal1Local2Y

			if (dot < minDot) then
			
				minDot = dot
				vertex21 = i1
				vertex22 = i2
			endif
		next


		' //  Build the clip vertices for the incident edge.
		tClip = c[0]
		' // tClip.v = b2Math.AddVV(poly2.m_position, b2Math.b2MulMV(poly2.m_R, vert2s[vertex21]))
		tVec = tClip.v
		tVec.SetV(vert2s[vertex21])
		tVec.MulM(poly2.m_R)
		tVec.Add(poly2.m_position)
		tClip.id.features.referenceFace = edge1
		tClip.id.features.incidentEdge = vertex21
		tClip.id.features.incidentVertex = vertex21
		tClip = c[1]
		' // tClip.v = b2Math.AddVV(poly2.m_position, b2Math.b2MulMV(poly2.m_R, vert2s[vertex22]))
		tVec = tClip.v
		tVec.SetV(vert2s[vertex22])
		tVec.MulM(poly2.m_R)
		tVec.Add(poly2.m_position)
		tClip.id.features.referenceFace = edge1
		tClip.id.features.incidentEdge = vertex21
		tClip.id.features.incidentVertex = vertex22
end

---------------------------------------------------

public  sub b2CollidePoly (manifold as variant, polyA as variant, polyB as variant, conservative as variant) as variant ''funcio as variant ''funcio as variant ''funcio as variant ''funcion
		manifold.pointCount = 0
dim 		 edgeA  as variant = 0

dim 		 edgeAOut  as variant = [edgeA]

dim 		 separationA  as variant = b2Collision.FindMaxSeparation(edgeAOut, polyA, polyB, conservative)


dim 		poly1  as variant
dim 		poly2  as variant


'---------------------
dim 		 edgeB  as variant 
dim 		 edgeBOut  as variant
dim 		 separationB  as variant

dim 		 edge1  as variant
dim 		 flip  as variant
dim 		 k_relativeTol  as variant
dim 		 k_absoluteTol  as variant
dim 		 incidentEdge  as new variant[]
dim 		 count1  as variant
dim 		 vert1s  as variant

dim 		 v11  as variant 
dim 		 v12  as variant
dim 		 dvX  as variant
dim 		 dvY  as variant
dim 		 sideNormalX  as variant
dim 		 sideNormalY  as variant
dim 		 tX  as variant
dim 		 tMat  as variant

dim 		 invLength  as variant
dim 		 frontNormalX  as variant 
dim 		 frontNormalY  as variant
dim 		 v11X  as variant
dim 		 v11Y  as variant 
dim 		 v12X  as variant
dim 		 v12Y  as variant
dim 		 frontOffset  as variant
dim 		 sideOffset1  as variant
dim 		 sideOffset2  as variant
dim 		 clipPoints1  as variant
dim 		 clipPoints2  as variant
dim 		 np  as variant 
dim 		 pointCount  as variant
dim 			 tVec  as variant
dim 			 separation  as variant
dim 				 cp  as variant


		edgeA = edgeAOut[0]
		if (separationA > 0.0 & conservative = false) then
			return
		endif
		
 

	 edgeB   = 0

		 edgeBOut   = [edgeB]

		 separationB   = b2Collision.FindMaxSeparation(edgeBOut, polyB, polyA, conservative)



		edgeB = edgeBOut[0]
		if (separationB > 0.0 & conservative = false)
			return
		endif
		



 	 edge1   = 0

 	 flip   = 0

 	 k_relativeTol   = 0.98

 	 k_absoluteTol   = 0.001

		' //  TODO_ERIN use "radius" of poly for absolute tolerance.
		if (separationB > k_relativeTol * separationA + k_absoluteTol) then
			poly1 = polyB
			poly2 = polyA
			edge1 = edgeB
			flip = 1
		else
			poly1 = polyA
			poly2 = polyB
			edge1 = edgeA
			flip = 0
		end
		
 	 incidentEdge   = [new ClipVertex(), new ClipVertex()]

		b2Collision.FindIncidentEdge(incidentEdge, poly1, edge1, poly2)
 	 count1   = poly1.m_vertexCount

 	 vert1s   = poly1.m_vertices

 	 v11   = vert1s[edge1]

 	 v12   = if(edge1 + 1 < count1, vert1s[edge1+1] , vert1s[0)

		' // var dv = b2Math.SubtractVV(v12, v11)
 	 dvX   = v12.x - v11.x

 	 dvY   = v12.y - v11.y

		' // var sideNormal = b2Math.b2MulMV(poly1.m_R, b2Math.SubtractVV(v12, v11))
 	 sideNormalX   = v12.x - v11.x

 	 sideNormalY   = v12.y - v11.y

 	 tX   = sideNormalX

 	 tMat   = poly1.m_R

		sideNormalX = tMat.col1.x * tX + tMat.col2.x * sideNormalY
		sideNormalY = tMat.col1.y * tX + tMat.col2.y * sideNormalY
		' //  ^^^^ sideNormal.MulM(poly1.m_R)
 	 invLength   = 1.0 / sqrt(sideNormalX*sideNormalX + sideNormalY*sideNormalY)

		sideNormalX *= invLength
		sideNormalY *= invLength
		' //  ^^^^ sideNormal.Normalize()
		' // var frontNormal = b2Math.b2CrossVF(sideNormal, 1.0)
 	 frontNormalX   = sideNormalX

 	 frontNormalY   = sideNormalY

		tX = frontNormalX
		frontNormalX = frontNormalY
		frontNormalY = -tX
		' //  ^^^^ frontNormal.CrossVF(1.0)
		' //  Expanded for performance
		' // v11 = b2Math.AddVV(poly1.m_position, b2Math.b2MulMV(poly1.m_R, v11))
 	 v11X   = v11.x

 	 v11Y   = v11.y

		tX = v11X
		tMat = poly1.m_R
		v11X = tMat.col1.x * tX + tMat.col2.x * v11Y
		v11Y = tMat.col1.y * tX + tMat.col2.y * v11Y
		' //  ^^^^ v11.MulM(poly1.m_R)
		v11X += poly1.m_position.x
		v11Y += poly1.m_position.y
		' // v12 = b2Math.AddVV(poly1.m_position, b2Math.b2MulMV(poly1.m_R, v12))
 	 v12X   = v12.x

 	 v12Y   = v12.y

		tX = v12X
		tMat = poly1.m_R
		v12X = tMat.col1.x * tX + tMat.col2.x * v12Y
		v12Y = tMat.col1.y * tX + tMat.col2.y * v12Y
		' //  ^^^^ v12.MulM(poly1.m_R)
		v12X += poly1.m_position.x
		v12Y += poly1.m_position.y
		' // var frontOffset = b2Math.b2Dot(frontNormal, v11)
 	 frontOffset   = frontNormalX * v11X + frontNormalY * v11Y

		' // var sideOffset1 = -b2Math.b2Dot(sideNormal, v11)
 	 sideOffset1   = -(sideNormalX * v11X + sideNormalY * v11Y)

		' // var sideOffset2 = b2Math.b2Dot(sideNormal, v12)
 	 sideOffset2   = sideNormalX * v12X + sideNormalY * v12Y

		' //  Clip incident edge against extruded edge1 side edges.
 	 clipPoints1   = [new ClipVertex(), new ClipVertex()]

 	 clipPoints2   = [new ClipVertex(), new ClipVertex()]

 	 np   = 0

		' //  Clip to box side 1
		b2Collision.b2CollidePolyTempVec.Set(-sideNormalX, -sideNormalY)
		np = b2Collision.ClipSegmentToLine(clipPoints1, incidentEdge, b2Collision.b2CollidePolyTempVec, sideOffset1)
		if (np < 2) then 
			return
	endif

		' //  Clip to negative box side 1
		b2Collision.b2CollidePolyTempVec.Set(sideNormalX, sideNormalY)
		np = b2Collision.ClipSegmentToLine(clipPoints2, clipPoints1,  b2Collision.b2CollidePolyTempVec, sideOffset2)
		if (np < 2) then
			return
        endif
        

		' //  Now clipPoints2 contains the clipped points.
		if (flip) then 
			manifold.normal.Set(-frontNormalX, -frontNormalY)
		else
			manifold.normal.Set(frontNormalX, frontNormalY)
		' //  ^^^^ manifold.normal = flip ? frontNormal.Negative() : frontNormal
 	 	endif
 	 	
 	 	
 	 pointCount   = 0

		for i = 0 to b2Settings.b2_maxManifoldPoints
			' // var separation = b2Math.b2Dot(frontNormal, clipPoints2[i].v) - frontOffset
 		 tVec   = clipPoints2[i].v

 		 separation   = (frontNormalX * tVec.x + frontNormalY * tVec.y) - frontOffset

			if (separation <= 0.0 or conservative = true) then
			    cp   = manifold.points[ pointCount ]
				cp.separation = separation
				cp.position.SetV( clipPoints2[i].v )
				cp.id.Set( clipPoints2[i].id )
				cp.id.features.flip = flip
				pointCount +=1
			endif
		next
		manifold.pointCount = pointCount
end






public  sub b2CollideCircle (manifold as variant, circle1 as variant, circle2 as variant, conservative as variant) as variant ''funcion
dim 		 dX  as variant
dim 		 dY  as variant
dim 		 distSqr  as variant
dim 		 radiusSum  as variant 
dim 		separation  as variant

dim 			 dist  as variant
dim 			 a  as variant 
dim 		 tPoint  as varian

		manifold.pointCount = 0
		' // var d = b2Math.SubtractVV(circle2.m_position, circle1.m_position)
		 dX  = circle2.m_position.x - circle1.m_position.x

		 dY  = circle2.m_position.y - circle1.m_position.y

		' // var distSqr = b2Math.b2Dot(d, d)
		 distSqr  = dX * dX + dY * dY

		 radiusSum  = circle1.m_radius + circle2.m_radius

		if (distSqr > radiusSum * radiusSum and conservative = false) then 
			return
 		endif
		
		if (distSqr < Number.MIN_VALUE) then 
			separation = -radiusSum
			manifold.normal.Set(0.0, 1.0)
		else
			 dist  = Math.sqrt(distSqr)
			separation = dist - radiusSum
			 a  = 1.0 / dist
			manifold.normal.x = a * dX
			manifold.normal.y = a * dY
		endif	
			
     		manifold.pointCount = 1
	     	 tPoint  = manifold.points[0]
	    

		tPoint.id.set_key(0)
		tPoint.separation = separation
		' // tPoint.position = b2Math.SubtractVV(circle2.m_position, b2Math.MulFV(circle2.m_radius, manifold.normal))
		tPoint.position.x = circle2.m_position.x - (circle2.m_radius * manifold.normal.x)
		tPoint.position.y = circle2.m_position.y - (circle2.m_radius * manifold.normal.y)
end


public  sub b2CollidePolyAndCircle (manifold as variant, poly as variant, circle as variant, conservative as variant)  ''funcio as variant ''funcio as variant ''funcio as variant ''funcio as variant ''funcion
	
dim 		tPoint  as variant
dim 		dX  as variant
dim 		dY  as variant
		' //  Compute circle position in the frame of the polygon.
		' // var xLocal = b2Math.b2MulTMV(poly.m_R, b2Math.SubtractVV(circle.m_position, poly.m_position))
dim 		 xLocalX  as variant = circle.m_position.x - poly.m_position.x

dim 		 xLocalY  as variant = circle.m_position.y - poly.m_position.y

dim 		 tMat  as variant = poly.m_R

dim 		 tX  as variant = xLocalX * tMat.col1.x + xLocalY * tMat.col1.y



dim 		dist  as variant
		' //  Find the min separating edge.
dim 		 normalIndex  as variant = 0

dim 		 separation  as variant = -Number.MAX_VALUE

dim 		 radius  as variant = circle.m_radius

dim i as integer

dim 			 s  as variant
dim 			 tVec  as variant



dim 		 vertIndex1  as variant
dim 		 vertIndex2  as variant

dim 		 eX  as variant 
dim 		 eY  as variant 

dim 		 length  as variant


dim 		 u  as variant 
dim 		pX, pY  as variant

	manifold.pointCount = 0
		xLocalY = xLocalX * tMat.col2.x + xLocalY * tMat.col2.y
		xLocalX = tX


		for  i = 0 then poly.m_vertexCount
			' // var s = b2Math.b2Dot(poly.m_normals[i], b2Math.SubtractVV(xLocal, poly.m_vertices[i]))
 			 s  = poly.m_normals[i].x * (xLocalX-poly.m_vertices[i].x) + poly.m_normals[i].y * (xLocalY-poly.m_vertices[i].y)

			if (s > radius) then 
				// Early out.
				return
            endif

			
			if (s > separation) then 
			    separation = s
				normalIndex = i
			endif
		next
		' //  If the center is inside the polygon ...
		if (separation < Number.MIN_VALUE) then
			manifold.pointCount = 1
			' // manifold.normal = b2Math.b2MulMV(poly.m_R, poly.m_normals[normalIndex])
 			tVec   = poly.m_normals[normalIndex]

			manifold.normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y
			manifold.normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y
			tPoint = manifold.points[0]
			tPoint.id.features.incidentEdge = normalIndex
			tPoint.id.features.incidentVertex = b2Collision.b2_nullFeature
			tPoint.id.features.referenceFace = b2Collision.b2_nullFeature
			tPoint.id.features.flip = 0
			tPoint.position.x = circle.m_position.x - radius * manifold.normal.x
			tPoint.position.y = circle.m_position.y - radius * manifold.normal.y
			' // tPoint.position = b2Math.SubtractVV(circle.m_position , b2Math.MulFV(radius , manifold.normal))
			tPoint.separation = separation - radius
			return
		endif


		' //  Project the circle center onto the edge segment.
		 vertIndex1 = normalIndex

		 vertIndex2 =if( vertIndex1 + 1 < poly.m_vertexCount , vertIndex1 + 1 , 0)

		' // var e = b2Math.SubtractVV(poly.m_vertices[vertIndex2] , poly.m_vertices[vertIndex1])
		 eX = poly.m_vertices[vertIndex2].x - poly.m_vertices[vertIndex1].x

		 eY = poly.m_vertices[vertIndex2].y - poly.m_vertices[vertIndex1].y

		' // var length = e.Normalize()
		 length = Math.sqrt(eX*eX + eY*eY)

		eX /= length
		eY /= length
		' //  If the edge length is zero ...
		if (length < Number.MIN_VALUE) then 
			' // d = b2Math.SubtractVV(xLocal , poly.m_vertices[vertIndex1])
			dX = xLocalX - poly.m_vertices[vertIndex1].x
			dY = xLocalY - poly.m_vertices[vertIndex1].y
			' // dist = d.Normalize()
			dist = Math.sqrt(dX*dX + dY*dY)
			dX /= dist
			dY /= dist
			if (dist > radius)
						return
				endif
 '' TODO: posible funcion (revisar)

			
			manifold.pointCount = 1
			' // manifold.normal = b2Math.b2MulMV(poly.m_R, d)
			manifold.normal.Set(tMat.col1.x * dX + tMat.col2.x * dY, tMat.col1.y * dX + tMat.col2.y * dY)
			tPoint = manifold.points[0]
			tPoint.id.features.incidentEdge = b2Collision.b2_nullFeature
			tPoint.id.features.incidentVertex = vertIndex1
			tPoint.id.features.referenceFace = b2Collision.b2_nullFeature
			tPoint.id.features.flip = 0
			' // tPoint.position = b2Math.SubtractVV(circle.m_position , b2Math.MulFV(radius , manifold.normal))
			tPoint.position.x = circle.m_position.x - radius * manifold.normal.x
			tPoint.position.y = circle.m_position.y - radius * manifold.normal.y
			tPoint.separation = dist - radius
			return
		endif
 '' TODO: posible funcion (revisar)

		' //  Project the center onto the edge.
		' // var u = b2Math.b2Dot(b2Math.SubtractVV(xLocal , poly.m_vertices[vertIndex1]) , e)
		 u = (xLocalX-poly.m_vertices[vertIndex1].x) * eX + (xLocalY-poly.m_vertices[vertIndex1].y) * eY

		tPoint = manifold.points[0]
		tPoint.id.features.incidentEdge = b2Collision.b2_nullFeature
		tPoint.id.features.incidentVertex = b2Collision.b2_nullFeature
		tPoint.id.features.referenceFace = b2Collision.b2_nullFeature
		tPoint.id.features.flip = 0

		if (u <= 0.0) then
			pX = poly.m_vertices[vertIndex1].x
			pY = poly.m_vertices[vertIndex1].y
			tPoint.id.features.incidentVertex = vertIndex1
		else if (u >= length)
			pX = poly.m_vertices[vertIndex2].x
			pY = poly.m_vertices[vertIndex2].y
			tPoint.id.features.incidentVertex = vertIndex2
		else
			' // p = b2Math.AddVV(poly.m_vertices[vertIndex1] , b2Math.MulFV(u, e))
			pX = eX * u + poly.m_vertices[vertIndex1].x
			pY = eY * u + poly.m_vertices[vertIndex1].y
			tPoint.id.features.incidentEdge = vertIndex1
		endif
		endif
		
		' // d = b2Math.SubtractVV(xLocal , p)
		dX = xLocalX - pX
		dY = xLocalY - pY
		' // dist = d.Normalize()
		dist = Math.sqrt(dX*dX + dY*dY)
		dX /= dist
		dY /= dist
		if (dist > radius) then 
			return
		endif
		
 '' TODO: posible funcion (revisar)

		manifold.pointCount = 1
		' // manifold.normal = b2Math.b2MulMV(poly.m_R, d)
		manifold.normal.Set(tMat.col1.x * dX + tMat.col2.x * dY, tMat.col1.y * dX + tMat.col2.y * dY)
		' // tPoint.position = b2Math.SubtractVV(circle.m_position , b2Math.MulFV(radius , manifold.normal))
		tPoint.position.x = circle.m_position.x - radius * manifold.normal.x
		tPoint.position.y = circle.m_position.y - radius * manifold.normal.y
		tPoint.separation = dist - radius
end


'-----------------------------------------------------
public  sub b2TestOverlap (a as variant, b as variant) as boolean''funcio as variant ''funcio as variant ''funcion
dim 		 t1  as variant = b.minVertex

dim 		 t2  as variant = a.maxVertex

		' // d1 = b2Math.SubtractVV(b.minVertex, a.maxVertex)
dim 		 d1X  as variant = t1.x - t2.x

dim 		 d1Y  as variant = t1.y - t2.y

dim 		 d2X  as variant = t1.x - t2.x

dim 		 d2Y  as variant = t1.y - t2.y

		' // d2 = b2Math.SubtractVV(a.minVertex, b.maxVertex)
		t1 = a.minVertex
		t2 = b.maxVertex

		if (d1X > 0.0 and d1Y > 0.0) then 
			return false
		endif
		
		if (d2X > 0.0 and d2Y > 0.0)
			return false
		endif

		return true
end