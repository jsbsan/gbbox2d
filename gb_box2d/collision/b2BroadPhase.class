' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
' you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' /* 
'This broad phase uses the Sweep and Prune algorithm in:
'Collision Detection in Interactive 3D Environments by Gino van den Bergen
'Also, some ideas, such integral values for fast compares comes from
'Bullet (http:/www.bulletphysics.com).
' */
' //  Notes:
' //  - we use bound arrays instead of linked lists for cache coherence.
' //  - we use quantized integral values for fast compares.
' //  - we use short indices rather than pointers to save memory.
' //  - we use a stabbing count for fast overlap queries (less than order N).
' //  - we also use a time stamp on each proxy to speed up the registration of
' //    overlap query results.
' //  - where possible, we compare bound indices instead of values to reduce
' //    cache misses (TODO_ERIN).
' //  - no broadphase is perfect and neither is this one: it is not great for huge
' //    worlds (use a multi-SAP instead), it is not great for large objects.

' // public:
Public 	m_pairManager as new 2PairManager()

Public 	m_proxyPool as new variant[b2Settings.b2_maxPairs]
public 	m_freeProxy as integer= 0


Public m_bounds as  new variant[2*b2Settings.b2_maxProxies]

Public 	m_queryResults s  new variant[b2Settings.b2_maxProxies]
public	m_queryResultCount as integer=0
public m_worldAABB as variant= null

Public 	m_quantizationFactor as  new b2Vec2()
	public m_proxyCount as integer= 0
	public m_timeStamp as integer= 0
public s_validate as boolean = false
public b2_invalid as variant = b2Settings.USHRT_MAX
public b2_nullEdge as variant = b2Settings.USHRT_MAX







public  sub 	_new(worldAABB as variant, callback as variant)

dim  i  as integer= 0
dim  j  as integer= 0

		' // var d = b2Math.SubtractVV(worldAABB.maxVertex, worldAABB.minVertex)
dim 		 dX  as variant = worldAABB.maxVertex.x

dim 		 dY  as variant = worldAABB.maxVertex.y
dim 		tProxy  as b2Proxy()

		' //  initialize instance variables for references
		 me.m_pairManager = new b2PairManager()
		 me.m_proxyPool = new b2Settings.b2_maxPairs[]
		 me.m_bounds = new b2Settings.b2_maxProxies[] 'con doble 
		 me.m_queryResults = new b2Settings.b2_maxProxies[]
		 me.m_quantizationFactor = new b2Vec2()
		' // 
		' // b2Settings.b2Assert(worldAABB.IsValid())


		 me.m_pairManager.Initialize(me, callback)
		 me.m_worldAABB = worldAABB
		 me.m_proxyCount = 0
		' //  query results
	for i=0 to  b2Settings.b2_maxProxies
			 me.m_queryResults[i] = 0
	next
		' //  bounds array
		 me.m_bounds = new variant[2][2*b2Settings.b2_maxProxies]
		
		for i=0 to 2
		'	 me.m_bounds.add(new variant[][]))) 'new Array(2*b2Settings.b2_maxProxies)
				for j=0 to  			 2*b2Settings.b2_maxProxies
				 me.m_bounds[i][j] = new b2Bound()
				next
		next
			


		dX -= worldAABB.minVertex.x
		dY -= worldAABB.minVertex.y
		 me.m_quantizationFactor.x = b2Settings.USHRT_MAX / dX
		 me.m_quantizationFactor.y = b2Settings.USHRT_MAX / dY



		for i = 0 to b2Settings.b2_maxProxies - 1
			tProxy = new b2Proxy()
			 me.m_proxyPool[i] = tProxy
			tProxy.SetNext(i + 1)
			tProxy.timeStamp = 0
			tProxy.overlapCount = b2BroadPhase.b2_invalid
			tProxy.userData = null
		next
		
		tProxy = new b2Proxy()
		 me.m_proxyPool[b2Settings.b2_maxProxies-1] = tProxy
		tProxy.SetNext(b2Pair.b2_nullProxy)
		tProxy.timeStamp = 0
		tProxy.overlapCount = b2BroadPhase.b2_invalid
		tProxy.userData = null
		 me.m_freeProxy = 0
		 me.m_timeStamp = 1
		 me.m_queryResultCount = 0
	' // ~b2BroadPhase()
	' //  Use this to see if your proxy is in range. If it is not in range
	' //  it should be destroyed. Otherwise you may get O(m^2) pairs, where m
	' //  is the number of proxies that are out of range.
end

public  sub 	InRange(aabb as variant) as boolean ''funcion
		' // var d = b2Math.b2MaxV(b2Math.SubtractVV(aabb.minVertex, me.m_worldAABB.maxVertex), b2Math.SubtractVV( me.m_worldAABB.minVertex, aabb.maxVertex))
	dim dX  as variant
	dim dY as variant
	dim d2X  as variant
	dim d2Y  as variant

		dX = aabb.minVertex.x
		dY = aabb.minVertex.y
		dX -= me.m_worldAABB.maxVertex.x
		dY -= me.m_worldAABB.maxVertex.y
		d2X = me.m_worldAABB.minVertex.x
		d2Y = me.m_worldAABB.minVertex.y
		d2X -= aabb.maxVertex.x
		d2Y -= aabb.maxVertex.y
		dX = b2Math.b2Max(dX, d2X)
		dY = b2Math.b2Max(dY, d2Y)
		return b2Math.b2Max(dX, dY) < 0.0
 '' TODO: posible funcion (revisar)

	' //  Get a single proxy. Returns NULL if the id is invalid.
end

public  sub GetProxy(proxyId as variant) as variant ''funcio as variant ''funcion
		if (proxyId = b2Pair.b2_nullProxy and me.m_proxyPool[proxyId].IsValid() = false)
			return null
			endif
		return me.m_proxyPool[ proxyId ]
end

public  sub CreateProxy(aabb as variant, userData as variant) as variant ''funcion
 	dim  index  as variant = 0

 	dim proxy  as variant
		' // b2Settings.b2Assert( me.m_proxyCount < b2_maxProxies)
		' // b2Settings.b2Assert( me.m_freeProxy != b2Pair.b2_nullProxy)
 	dim  proxyId  as variant = me.m_freeProxy


	dim  boundCount  as integer = 2 * me.m_proxyCount

 	dim  lowerValues  as new variant[] 

 	dim  upperValues  as new variant[] 

	dim axis as integer = 0 


 	dim 	 bounds  as variant

dim 			 lowerIndex  as variant

dim 			 upperIndex  as variant

dim 			 lowerIndexOut  as variant

dim 			 upperIndexOut  as variant

dim j as integer
			
dim 			 tIndex  as variant 

dim 	tArr as new variant[]


dim 				 proxy2  as variant

		proxy = me.m_proxyPool[ proxyId ]
		 me.m_freeProxy = proxy.GetNext()
		proxy.overlapCount = 0
		proxy.userData = userData
 	
 	
		 me.ComputeBounds(lowerValues, upperValues, aabb)
		
		for  axis = 0 to   2
 			 	 bounds  = me.m_bounds[axis]

	 			 lowerIndex  = 0

	 			 upperIndex  = 0

				 lowerIndexOut  = [lowerIndex]

	 			 upperIndexOut  = [upperIndex]

			 me.Query(lowerIndexOut, upperIndexOut, lowerValues[axis], upperValues[axis], bounds, boundCount, axis)
			lowerIndex = lowerIndexOut[0]
			upperIndex = upperIndexOut[0]
			' //  Replace memmove calls
			' // memmove(bounds + upperIndex + 2, bounds + upperIndex, (edgeCount - upperIndex) * sizeof(b2Bound))
			 tArr   = new variant[]
	
			 j   = 0

			 tEnd   = boundCount - upperIndex
	
 
			' //  make temp array
			for j = 0 to tEnd
				tArr[j] = new b2Bound()
				tBound1 = tArr[j]
				tBound2 = bounds[upperIndex+j]
				tBound1.value = tBound2.value
				tBound1.proxyId = tBound2.proxyId
				tBound1.stabbingCount = tBound2.stabbingCount
			next
			' //  move temp array back in to bounds
			tEnd = tArr.length
			
			
	
 			 tIndex = upperIndex+2

			for j = 0 to tEnd
				' // bounds[tIndex+j] = tArr[j]
				tBound2 = tArr[j]
				tBound1 = bounds[tIndex+j]
				tBound1.value = tBound2.value
				tBound1.proxyId = tBound2.proxyId
				tBound1.stabbingCount = tBound2.stabbingCount
			next
			' // memmove(bounds + lowerIndex + 1, bounds + lowerIndex, (upperIndex - lowerIndex) * sizeof(b2Bound))
			' //  make temp array
		tArr = new variant[]
			tEnd = upperIndex - lowerIndex
			
			for j=0 to  tEnd
				tArr[j] = new b2Bound()
				tBound1 = tArr[j]
				tBound2 = bounds[lowerIndex+j]
				tBound1.value = tBound2.value
				tBound1.proxyId = tBound2.proxyId
				tBound1.stabbingCount = tBound2.stabbingCount
			next
			' //  move temp array back in to bounds
			tEnd = tArr.count
			tIndex = lowerIndex+1
			
			for j=0 to  tEnd
				' // bounds[tIndex+j] = tArr[j]
				tBound2 = tArr[j]
				tBound1 = bounds[tIndex+j]
				tBound1.value = tBound2.value
				tBound1.proxyId = tBound2.proxyId
				tBound1.stabbingCount = tBound2.stabbingCount
			next
			' //  The upper index has increased because of the lower bound insertion.
			upperIndex +=1
			' //  Copy in the new bounds.
			bounds[lowerIndex].value = lowerValues[axis]
			bounds[lowerIndex].proxyId = proxyId
			bounds[upperIndex].value = upperValues[axis]
			bounds[upperIndex].proxyId = proxyId
			bounds[lowerIndex].stabbingCount =if( lowerIndex = 0,0, bounds[lowerIndex-1].stabbingCount)
			bounds[upperIndex].stabbingCount = bounds[upperIndex-1].stabbingCount
			' //  Adjust the stabbing count between the new bounds.
			for index = lowerIndex to  upperIndex
				bounds[index].stabbingCount+=1
			next
			' //  Adjust the all the affected bound indices.
			
			for index = lowerIndex to   boundCount + 2
			
 				 proxy2   = me.m_proxyPool[ bounds[index].proxyId ]

				if (bounds[index].IsLower()) then 
				
					proxy2.lowerBounds[axis] = index
				
				else
				
					proxy2.upperBounds[axis] = index
				endif
			next
		next
		
			
		 me.m_proxyCount +=1
		 
		' // b2Settings.b2Assert( me.m_queryResultCount < b2Settings.b2_maxProxies)
		for  i = 0 to me.m_queryResultCount
			' // b2Settings.b2Assert( me.m_queryResults[i] < b2_maxProxies)
			' // b2Settings.b2Assert( me.m_proxyPool[ me.m_queryResults[i]].IsValid())
			 me.m_pairManager.AddBufferedPair(proxyId, me.m_queryResults[i])
		next
		 me.m_pairManager.Commit()
		' //  Prepare for next query.
		 me.m_queryResultCount = 0
		 me.IncrementTimeStamp()
		return proxyId
end

public  sub 	DestroyProxy(proxyId as variant)

		' // b2Settings.b2Assert(0 < me.m_proxyCount && me.m_proxyCount <= b2_maxProxies)
dim 		 proxy  as variant = me.m_proxyPool[ proxyId ]

		' // b2Settings.b2Assert(proxy.IsValid())
dim 		 boundCount  as variant = 2 * me.m_proxyCount

dim axis as inteter

dim 			 bounds  as variant 

dim 			 lowerIndex  as variant 

dim 			 upperIndex  as variant 

dim 			 lowerValue  as variant 

dim 			 upperValue  as variant 

			' //  replace memmove calls
			' // memmove(bounds + lowerIndex, bounds + lowerIndex + 1, (upperIndex - lowerIndex - 1) * sizeof(b2Bound))
dim 			 tArr  as variant 

dim 			 j  as  integer = 0

dim 			 tEnd  as integer

dim 			tBound1  as variant
dim 			tBound2  as variant		
		
dim 			 tIndex  as variant	


dim index as integer
dim 				 proxy2  as variant 


dim index2 as variant
dim j as integer

		for  axis = 0 to  2
			 bounds   = me.m_bounds[axis]

			 lowerIndex   = proxy.lowerBounds[axis]

			 upperIndex   = proxy.upperBounds[axis]

			 lowerValue   = bounds[lowerIndex].value

			 upperValue   = bounds[upperIndex].value

			' //  replace memmove calls
			' // memmove(bounds + lowerIndex, bounds + lowerIndex + 1, (upperIndex - lowerIndex - 1) * sizeof(b2Bound))
			 tArr   = new Array()

			 j   = 0

			 tEnd   = upperIndex - lowerIndex - 1

			tBound1 = new variant
			tBound2 =new  variant
			' //  make temp array
			for j = 0 to tEnd
				tArr[j] = new b2Bound()
				tBound1 = tArr[j]
				tBound2 = bounds[lowerIndex+1+j]
				tBound1.value = tBound2.value
				tBound1.proxyId = tBound2.proxyId
				tBound1.stabbingCount = tBound2.stabbingCount
			next
			' //  move temp array back in to bounds
			tEnd = tArr.count
			
			 tIndex  = lowerIndex

			for j = 0 to tEnd
				' // bounds[tIndex+j] = tArr[j]
				tBound2 = tArr[j]
				tBound1 = bounds[tIndex+j]
				tBound1.value = tBound2.value
				tBound1.proxyId = tBound2.proxyId
				tBound1.stabbingCount = tBound2.stabbingCount
			next
			' // memmove(bounds + upperIndex-1, bounds + upperIndex + 1, (edgeCount - upperIndex - 1) * sizeof(b2Bound))
			' //  make temp array
			tArr = new variant[]
			tEnd = boundCount - upperIndex - 1
			for j = 0 to  tEnd
				tArr[j] = new b2Bound()
				tBound1 = tArr[j]
				tBound2 = bounds[upperIndex+1+j]
				tBound1.value = tBound2.value
				tBound1.proxyId = tBound2.proxyId
				tBound1.stabbingCount = tBound2.stabbingCount
			next
			' //  move temp array back in to bounds
			tEnd = tArr.count
			tIndex = upperIndex-1
			
			for j = 0 to  tEnd
				' // bounds[tIndex+j] = tArr[j]
				tBound2 = tArr[j]
				tBound1 = bounds[tIndex+j]
				tBound1.value = tBound2.value
				tBound1.proxyId = tBound2.proxyId
				tBound1.stabbingCount = tBound2.stabbingCount
			next
			
			' //  Fix bound indices.
			tEnd = boundCount - 2
			for index = lowerIndex to  tEnd
			
 				proxy2  = me.m_proxyPool[ bounds[index].proxyId ]

				if (bounds[index].IsLower()) then 
				 proxy2.lowerBounds[axis] = index
				else
					proxy2.upperBounds[axis] = index
				endif
			next
			
			' //  Fix stabbing count.
			tEnd = upperIndex - 1
			for index2 = lowerIndex to tEnd
			
				bounds[index2].stabbingCount-=1
			next
			' //  me.Query for pairs to be removed. lowerIndex and upperIndex are not needed.
			' //  make lowerIndex and upper output using an array and do this for others if compiler doesn't pick them up
			 me.Query([0], [0], lowerValue, upperValue, bounds, boundCount - 2, axis)
		next
		' // b2Settings.b2Assert( me.m_queryResultCount < b2Settings.b2_maxProxies)
		for i = 0 to me.m_queryResultCount
			' // b2Settings.b2Assert( me.m_proxyPool[ me.m_queryResults[i]].IsValid())
			 me.m_pairManager.RemoveBufferedPair(proxyId, me.m_queryResults[i])
		next
		
		 me.m_pairManager.Commit()
		' //  Prepare for next query.
		 me.m_queryResultCount = 0
		 me.IncrementTimeStamp()
		' //  Return the proxy to the pool.
		proxy.userData = null
		proxy.overlapCount = b2BroadPhase.b2_invalid
		proxy.lowerBounds[0] = b2BroadPhase.b2_invalid
		proxy.lowerBounds[1] = b2BroadPhase.b2_invalid
		proxy.upperBounds[0] = b2BroadPhase.b2_invalid
		proxy.upperBounds[1] = b2BroadPhase.b2_invalid
		proxy.SetNext( me.m_freeProxy)
		 me.m_freeProxy = proxyId
	 me.m_proxyCount -=1
	
end


' //  Call me.MoveProxy times like, then when you are done
	' //  call me.Commit to finalized the proxy pairs (for your time step).


public  sub 	MoveProxy(proxyId as variant, aabb as variant) as variant ''funcio as variant ''funcion
dim 		 axis  as variant = 0

dim 		 index  as variant = 0

dim 		bound  as variant
dim 		prevBound as variant
dim 		nextBound as variant
dim 		 nextProxyId  as variant = 0
dim 		nextProxy  as variant



dim 		 boundCount  as variant 

dim 		 proxy  as variant 

	
dim 		 newValues  as variant

		
dim 		 oldValues  as variant



dim 			 bounds  as variant

dim 			 lowerIndex  as variant 

dim 			 upperIndex  as variant 

dim 			 lowerValue  as variant

dim 			 upperValue  as variant 

dim 			 deltaLower  as variant 

dim 			 deltaUpper  as variant 

dim 					 prevProxyId  as variant

dim 					 prevProxy  as variant 



		if (proxyId = b2Pair.b2_nullProxy and b2Settings.b2_maxProxies <= proxyId) then 
			' // b2Settings.b2Assert(false)
			return
		endif
		
 

		if (aabb.IsValid() = false) then 
			' // b2Settings.b2Assert(false)
			return
 
		endif

 			boundCount = 2 * me.m_proxyCount

 			proxy = me.m_proxyPool[ proxyId ]

		' //  Get new bound values
 			newValues = new b2BoundValues()

		 me.ComputeBounds(newValues.lowerValues, newValues.upperValues, aabb)
		' //  Get old bound values
 			oldValues = new b2BoundValues()



		for axis = 0 to  2
			oldValues.lowerValues[axis] = me.m_bounds[axis][proxy.lowerBounds[axis]].value
			oldValues.upperValues[axis] = me.m_bounds[axis][proxy.upperBounds[axis]].value
		next
			
		for axis = 0 to 2
		
 			bounds  = me.m_bounds[axis]

 			lowerIndex  = proxy.lowerBounds[axis]

 			upperIndex  = proxy.upperBounds[axis]

 			lowerValue  = newValues.lowerValues[axis]

 			upperValue  = newValues.upperValues[axis]

 			deltaLower  = lowerValue - bounds[lowerIndex].value

 			deltaUpper  = upperValue - bounds[upperIndex].value

			bounds[lowerIndex].value = lowerValue
			bounds[upperIndex].value = upperValue
			' // 
			' //  Expanding adds overlaps
			' // 
			' //  Should we move the lower bound down?
			if (deltaLower < 0) then 
			
				index = lowerIndex
				while (index > 0 && lowerValue < bounds[index-1].value)
					bound = bounds[index]
					prevBound = bounds[index - 1]
					 prevProxyId  = prevBound.proxyId

					 prevProxy  = me.m_proxyPool[ prevBound.proxyId ]

				 	prevBound.stabbingCount+=1
				 	
					if (prevBound.IsUpper() = true) then 
					
						if ( me.TestOverlap(newValues, prevProxy)) then 
						 me.m_pairManager.AddBufferedPair(proxyId, prevProxyId)
						endif
						
						prevProxy.upperBounds[axis]+=1
						bound.stabbingCount+=1
					
					else
					
						prevProxy.lowerBounds[axis]+=1
						bound.stabbingCount-=1
					endif
					
					proxy.lowerBounds[axis]-=1
					' //  swap
					' // var temp = bound
					' // bound = prevEdge
					' // prevEdge = temp
					bound.Swap(prevBound)
					' // b2Math.b2Swap(bound, prevEdge)
					index -=1
				wend
			endif
			
			
			' //  Should we move the upper bound up?
			if (deltaUpper > 0) thhen 
			
				index = upperIndex
				while (index < boundCount-1 && bounds[index+1].value <= upperValue)
				
					bound = bounds[ index ]
					nextBound = bounds[ index + 1 ]
					nextProxyId = nextBound.proxyId
					nextProxy = me.m_proxyPool[ nextProxyId ]
					nextBound.stabbingCount+=1
					if (nextBound.IsLower() = true)
					 	if ( me.TestOverlap(newValues, nextProxy))
							 me.m_pairManager.AddBufferedPair(proxyId, nextProxyId)
						endif
						
						nextProxy.lowerBounds[axis]-=1
						bound.stabbingCount+=1
					
					else
						nextProxy.upperBounds[axis]-=1
						bound.stabbingCount-=1
					endif
					
					proxy.upperBounds[axis]+=1
					' //  swap
					' // var temp = bound
					' // bound = nextEdge
					' // nextEdge = temp
					bound.Swap(nextBound)
					' // b2Math.b2Swap(bound, nextEdge)
					index+=1
				wend
				
			endif
			
			
			' // 
			' //  Shrinking removes overlaps
			' // 
			' //  Should we move the lower bound up?
			if (deltaLower > 0) then 
			
				index = lowerIndex
				while (index < boundCount-1 && bounds[index+1].value <= lowerValue)
				
					bound = bounds[ index ]
					nextBound = bounds[ index + 1 ]
					nextProxyId = nextBound.proxyId
					nextProxy = me.m_proxyPool[ nextProxyId ]
					nextBound.stabbingCount-=1
					if (nextBound.IsUpper())
					
						if ( me.TestOverlap(oldValues, nextProxy))
						
							 me.m_pairManager.RemoveBufferedPair(proxyId, nextProxyId)
						endif
						
						nextProxy.upperBounds[axis]-=1
						bound.stabbingCount-=1
					
					else
					
						nextProxy.lowerBounds[axis]-=1
						bound.stabbingCount+=1
					endif
					
					proxy.lowerBounds[axis]+=1
					' //  swap
					' // var temp = bound
					' // bound = nextEdge
					' // nextEdge = temp
					bound.Swap(nextBound)
					' // b2Math.b2Swap(bound, nextEdge)
					index+=1
				wend
			endif
			
			' //  Should we move the upper bound down?
			if (deltaUpper < 0) then
			
				index = upperIndex
				while (index > 0 && upperValue < bounds[index-1].value)
				
					bound = bounds[index]
					prevBound = bounds[index - 1]
					prevProxyId = prevBound.proxyId
					prevProxy = me.m_proxyPool[ prevProxyId ]
					prevBound.stabbingCount-=1
					if (prevBound.IsLower() = true) then 
					 	if ( me.TestOverlap(oldValues, prevProxy))
							 me.m_pairManager.RemoveBufferedPair(proxyId, prevProxyId)
						endif
						
						prevProxy.lowerBounds[axis]+=1
						bound.stabbingCount-=1
					
					else
					
						prevProxy.upperBounds[axis]+=1
						bound.stabbingCount+=1
					endif
					
					proxy.upperBounds[axis]-=1
					' //  swap
					' // var temp = bound
					' // bound = prevEdge
					' // prevEdge = temp
					bound.Swap(prevBound)
					' // b2Math.b2Swap(bound, prevEdge)
					index-=1
				wend
				
			endif
	next	
			
end

public  sub Commit()  ''funcion
		 me.m_pairManager.Commit()
	
end

' //  me.Query an AABB for overlapping proxies, returns the user data and '' TODO: posible funcion (revisar)
' //  the count, up to the supplied maximum count.

public  sub 	QueryAABB(aabb as variant, userData as variant, maxCount as variant) as variant ''funcion
dim 		 lowerValues  as new variant[]

dim 		 upperValues  as new variant[]

	
dim 		 lowerIndex  as variant = 0

dim 		 upperIndex  as variant = 0

dim 		 lowerIndexOut  as new variant[] = [lowerIndex]

dim 		 upperIndexOut  as new variant[] = [upperIndex]
dim 		 count  as integer = 0
dim i as integer
dim 			 proxy  as variant
	 me.ComputeBounds(lowerValues, upperValues, aabb)
		 me.Query(lowerIndexOut, upperIndexOut, lowerValues[0], upperValues[0], me.m_bounds[0], 2* me.m_proxyCount, 0)
		 me.Query(lowerIndexOut, upperIndexOut, lowerValues[1], upperValues[1], me.m_bounds[1], 2* me.m_proxyCount, 1)
		' // b2Settings.b2Assert( me.m_queryResultCount < b2Settings.b2_maxProxies)


 		 lowerIndexOut  = [lowerIndex]

 		 upperIndexOut  = [upperIndex]

		i=0
		while (i<  me.m_queryResultCount && count < maxCount)
		  i+=1
		  count=+1
		  ' // b2Settings.b2Assert( me.m_queryResults[i] < b2Settings.b2_maxProxies)
		 proxy  = me.m_proxyPool[ me.m_queryResults[i] ]

			' // b2Settings.b2Assert(proxy.IsValid())
			userData[i] = proxy.userData
		wend
		
		' //  Prepare for next query.
		 me.m_queryResultCount = 0
		 me.IncrementTimeStamp()
		return count

end

public  sub Validate()

dim 		pair  as variant
dim 		proxy1  as variant
dim 		proxy2  as variant
dim 		overlap  as variant

dim axis as integer


dim 			 bounds  as variant

dim 			 boundCount  as variant 

dim 			 stabbingCount  as integer= 0
dim i as integer
dim 				 bound  as variant

		for axis = 0 to 2
				 bounds   = me.m_bounds[axis]

				 boundCount   = 2 * me.m_proxyCount

				 stabbingCount   = 0

			for  i = 0 to boundCount
	 			bound   = bounds[i]

				' // b2Settings.b2Assert(i == 0 || bounds[i-1].value <= bound->value)
				' // b2Settings.b2Assert(bound->proxyId != b2_nullProxy)
				' // b2Settings.b2Assert( me.m_proxyPool[bound->proxyId].IsValid())
				if (bound.IsLower() = true)
				
					' // b2Settings.b2Assert( me.m_proxyPool[bound.proxyId].lowerBounds[axis] == i)
					stabbingCount=-1
				
				else
				
					' // b2Settings.b2Assert( me.m_proxyPool[bound.proxyId].upperBounds[axis] == i)
					stabbingCount--
				endif
			next	
				' // b2Settings.b2Assert(bound.stabbingCount == stabbingCount)
			next

end



public  sub 	ComputeBounds(lowerValues as variant, upperValues as variant, aabb as variant)

		' // b2Settings.b2Assert(aabb.maxVertex.x > aabb.minVertex.x)
		' // b2Settings.b2Assert(aabb.maxVertex.y > aabb.minVertex.y)
		' // var minVertex = b2Math.b2ClampV(aabb.minVertex, me.m_worldAABB.minVertex, me.m_worldAABB.maxVertex)
dim 		 minVertexX  as variant = aabb.minVertex.x

dim 		 minVertexY  as variant = aabb.minVertex.y
dim 		 maxVertexX  as variant = aabb.maxVertex.x

dim 		 maxVertexY  as variant = aabb.maxVertex.y

		minVertexX = b2Math.b2Min(minVertexX, me.m_worldAABB.maxVertex.x)
		minVertexY = b2Math.b2Min(minVertexY, me.m_worldAABB.maxVertex.y)
		minVertexX = b2Math.b2Max(minVertexX, me.m_worldAABB.minVertex.x)
		minVertexY = b2Math.b2Max(minVertexY, me.m_worldAABB.minVertex.y)
		' // var maxVertex = b2Math.b2ClampV(aabb.maxVertex, me.m_worldAABB.minVertex, me.m_worldAABB.maxVertex)


		maxVertexX = b2Math.b2Min(maxVertexX, me.m_worldAABB.maxVertex.x)
		maxVertexY = b2Math.b2Min(maxVertexY, me.m_worldAABB.maxVertex.y)
		maxVertexX = b2Math.b2Max(maxVertexX, me.m_worldAABB.minVertex.x)
		maxVertexY = b2Math.b2Max(maxVertexY, me.m_worldAABB.minVertex.y)
		' //  Bump lower bounds downs and upper bounds up. This ensures correct sorting of
		' //  lower/upper bounds that would have equal values.
		' //  TODO_ERIN implement fast float to uint16 conversion.
		lowerValues[0] = ' /* uint*/( me.m_quantizationFactor.x * (minVertexX - me.m_worldAABB.minVertex.x)) & (b2Settings.USHRT_MAX - 1)
		upperValues[0] = (' /* uint*/( me.m_quantizationFactor.x * (maxVertexX - me.m_worldAABB.minVertex.x))& 0x0000ffff) | 1
		lowerValues[1] = ' /* uint*/( me.m_quantizationFactor.y * (minVertexY - me.m_worldAABB.minVertex.y)) & (b2Settings.USHRT_MAX - 1)
		upperValues[1] = (' /* uint*/( me.m_quantizationFactor.y * (maxVertexY - me.m_worldAABB.minVertex.y))& 0x0000ffff) | 1
	' //  This one is only used for validation.
end

public  sub 	TestOverlapValidate(p1 as variant, p2 as variant) as variant ''funcio as variant ''funcio as variant ''funcion
	dim 		axis  as integer	
	dim 		 bounds  as variant		
		
		for  axis = 0 to 2
 			 bounds  = me.m_bounds[axis]

			' // b2Settings.b2Assert(p1.lowerBounds[axis] < 2 * me.m_proxyCount)
			' // b2Settings.b2Assert(p1.upperBounds[axis] < 2 * me.m_proxyCount)
			' // b2Settings.b2Assert(p2.lowerBounds[axis] < 2 * me.m_proxyCount)
			' // b2Settings.b2Assert(p2.upperBounds[axis] < 2 * me.m_proxyCount)
			if (bounds[p1.lowerBounds[axis]].value > bounds[p2.upperBounds[axis]].value)
				return false
			endif
 
			if (bounds[p1.upperBounds[axis]].value < bounds[p2.lowerBounds[axis]].value)
				return false
			endif
 
		return true
end

public  sub 	TestOverlap(b as variant, p as variant) as variant ''funcio as variant ''funcio as variant ''funcion
dim  axis as integer
dim  bounds  as variant

		for axis = 0 to 2
	 bounds = me.m_bounds[axis]

			' // b2Settings.b2Assert(p.lowerBounds[axis] < 2 * me.m_proxyCount)
			' // b2Settings.b2Assert(p.upperBounds[axis] < 2 * me.m_proxyCount)
			if (b.lowerValues[axis] > bounds[p.upperBounds[axis]].value) then
				return false
			endif
			
			if (b.upperValues[axis] < bounds[p.lowerBounds[axis]].value) then
				return false
 			endif

		return true


end

public  sub 	Query(lowerQueryOut as variant, upperQueryOut as variant, lowerValue as variant, upperValue as variant, bounds as variant, boundCount as variant, axis as variant)
dim 		 lowerQuery  as variant = b2BroadPhase.BinarySearch(bounds, boundCount, lowerValue)
dim 		 upperQuery  as variant = b2BroadPhase.BinarySearch(bounds, boundCount, upperValue)
dim j as integer
dim 					 proxy  as variant
		' //  Easy case: lowerQuery <= lowerIndex(i) < upperQuery
		' //  Solution: search query range for min bounds.
		for j = lowerQuery to upperQuery
			if (bounds[j].IsLower())
				 me.IncrementOverlapCount(bounds[j].proxyId)
			endif
		next
		' //  Hard case: lowerIndex(i) < lowerQuery < upperIndex(i)
		' //  Solution: use the stabbing count to search down the bound array.
		if (lowerQuery > 0) then 
 			 i = lowerQuery - 1

 			 s = bounds[i].stabbingCount

			' //  Find the s overlaps.
			while (s)
				' // b2Settings.b2Assert(i >= 0)
				if (bounds[i].IsLower()) then 
	 					 proxy  = me.m_proxyPool[ bounds[i].proxyId ]

					if (lowerQuery <= proxy.upperBounds[axis]) then
						 me.IncrementOverlapCount(bounds[i].proxyId)
						s=-1
					endif
				endif
				i=-1
			wend
		endif
	
	    lowerQueryOut[0] = lowerQuery
		upperQueryOut[0] = upperQuery
end

public  sub 	IncrementOverlapCount(proxyId as variant)

dim 		 proxy  as variant = me.m_proxyPool[ proxyId ]

		if (proxy.timeStamp < me.m_timeStamp) then 
			proxy.timeStamp = me.m_timeStamp
			proxy.overlapCount = 1
		else
			proxy.overlapCount = 2
			' // b2Settings.b2Assert( me.m_queryResultCount < b2Settings.b2_maxProxies)
			 me.m_queryResults[ me.m_queryResultCount] = proxyId
			 me.m_queryResultCount+=1
		endif
end

public  sub 	IncrementTimeStamp()
		dim i as integer
		
		if ( me.m_timeStamp = b2Settings.USHRT_MAX)
			for  i = 0 to b2Settings.b2_maxProxies
				 me.m_proxyPool[i].timeStamp = 0
			next
			 me.m_timeStamp = 1
		else
			++ me.m_timeStamp
		endif
end


public  sub BinarySearch (bounds as variant, count as variant, value as variant) as variant ''funcio as variant ''funcion
dim 		 low  as variant = 0

dim 		 high  as variant = count - 1
dim 		 midd  as integer


		while (low <= high)
			 midd  = Math.floor((low + high) / 2)
			if (bounds[midd].value > value) then 
				high = midd - 1
			else 
				if (bounds[midd].value < value) then 
					low = midd + 1
				else
					return (midd)
 				endif
		wend
		
		return (low)

end
