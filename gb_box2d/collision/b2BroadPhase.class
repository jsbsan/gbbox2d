' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' /* 
This broad phase uses the Sweep and Prune algorithm in:
Collision Detection in Interactive 3D Environments by Gino van den Bergen
Also, some ideas, such integral values for fast compares comes from
Bullet (http:/www.bulletphysics.com).
' */
' //  Notes:
' //  - we use bound arrays instead of linked lists for cache coherence.
' //  - we use quantized integral values for fast compares.
' //  - we use short indices rather than pointers to save memory.
' //  - we use a stabbing count for fast overlap queries (less than order N).
' //  - we also use a time stamp on each proxy to speed up the registration of
' //    overlap query results.
' //  - where possible, we compare bound indices instead of values to reduce
' //    cache misses (TODO_ERIN).
' //  - no broadphase is perfect and neither is this one: it is not great for huge
' //    worlds (use a multi-SAP instead), it is not great for large objects.
dim  b2BroadPhase  as variant = Class.create()

b2BroadPhase.prototype = 
' // public:
end

public  sub 	initialize(worldAABB as variant, callback as variant)

		' //  initialize instance variables for references
		 me.m_pairManager = new b2PairManager()
		 me.m_proxyPool = new Array(b2Settings.b2_maxPairs)
		 me.m_bounds = new Array(2*b2Settings.b2_maxProxies)
		 me.m_queryResults = new Array(b2Settings.b2_maxProxies)
		 me.m_quantizationFactor = new b2Vec2()
		' // 
		' // b2Settings.b2Assert(worldAABB.IsValid())
dim 		 i  as variant = 0

		 me.m_pairManager.Initialize(this, callback)
		 me.m_worldAABB = worldAABB
		 me.m_proxyCount = 0
		' //  query results
		for (i = 0; i < b2Settings.b2_maxProxies; i++)
			 me.m_queryResults[i] = 0
		' //  bounds array
		 me.m_bounds = new Array(2)
		for (i = 0; i < 2; i++)
			 me.m_bounds[i] = new Array(2*b2Settings.b2_maxProxies)
			for (var j = 0; j < 2*b2Settings.b2_maxProxies; j++)
				 me.m_bounds[i][j] = new b2Bound()
			
		' // var d = b2Math.SubtractVV(worldAABB.maxVertex, worldAABB.minVertex)
dim 		 dX  as variant = worldAABB.maxVertex.x

dim 		 dY  as variant = worldAABB.maxVertex.y

		dX -= worldAABB.minVertex.x
		dY -= worldAABB.minVertex.y
		 me.m_quantizationFactor.x = b2Settings.USHRT_MAX / dX
		 me.m_quantizationFactor.y = b2Settings.USHRT_MAX / dY
dim 		tProxy
 as variant
		for (i = 0; i < b2Settings.b2_maxProxies - 1; ++i)
			tProxy = new b2Proxy()
			 me.m_proxyPool[i] = tProxy
			tProxy.SetNext(i + 1)
			tProxy.timeStamp = 0
			tProxy.overlapCount = b2BroadPhase.b2_invalid
			tProxy.userData = null
		tProxy = new b2Proxy()
		 me.m_proxyPool[b2Settings.b2_maxProxies-1] = tProxy
		tProxy.SetNext(b2Pair.b2_nullProxy)
		tProxy.timeStamp = 0
		tProxy.overlapCount = b2BroadPhase.b2_invalid
		tProxy.userData = null
		 me.m_freeProxy = 0
		 me.m_timeStamp = 1
		 me.m_queryResultCount = 0
	' // ~b2BroadPhase()
	' //  Use this to see if your proxy is in range. If it is not in range
	' //  it should be destroyed. Otherwise you may get O(m^2) pairs, where m
	' //  is the number of proxies that are out of range.
end

public  sub 	InRange(aabb as variant) as variant ''funcion
		' // var d = b2Math.b2MaxV(b2Math.SubtractVV(aabb.minVertex, me.m_worldAABB.maxVertex), b2Math.SubtractVV( me.m_worldAABB.minVertex, aabb.maxVertex))
dim 		dX
 as variant
dim 		dY
 as variant
dim 		d2X
 as variant
dim 		d2Y
 as variant
		dX = aabb.minVertex.x
		dY = aabb.minVertex.y
		dX -= me.m_worldAABB.maxVertex.x
		dY -= me.m_worldAABB.maxVertex.y
		d2X = me.m_worldAABB.minVertex.x
		d2Y = me.m_worldAABB.minVertex.y
		d2X -= aabb.maxVertex.x
		d2Y -= aabb.maxVertex.y
		dX = b2Math.b2Max(dX, d2X)
		dY = b2Math.b2Max(dY, d2Y)
		return b2Math.b2Max(dX, dY) < 0.0
 '' TODO: posible funcion (revisar)

	' //  Get a single proxy. Returns NULL if the id is invalid.
end

public  sub 	GetProxy(proxyId as variant) as variant ''funcio as variant ''funcion
		if (proxyId == b2Pair.b2_nullProxy || me.m_proxyPool[proxyId].IsValid() == false)
			return null
 '' TODO: posible funcion (revisar)

		return me.m_proxyPool[ proxyId ]
 '' TODO: posible funcion (revisar)

	' //  Create and destroy proxies. These call Flush first.
end

public  sub 	CreateProxy(aabb as variant, userData as variant) as variant ''funcion
dim 		 index  as variant = 0

dim 		proxy
 as variant
		' // b2Settings.b2Assert( me.m_proxyCount < b2_maxProxies)
		' // b2Settings.b2Assert( me.m_freeProxy != b2Pair.b2_nullProxy)
dim 		 proxyId  as variant = me.m_freeProxy

		proxy = me.m_proxyPool[ proxyId ]
		 me.m_freeProxy = proxy.GetNext()
		proxy.overlapCount = 0
		proxy.userData = userData
dim 		 boundCount  as variant = 2 * me.m_proxyCount

dim 		 lowerValues  as variant = new Array()

dim 		 upperValues  as variant = new Array()

		 me.ComputeBounds(lowerValues, upperValues, aabb)
		for (var axis = 0; axis < 2; ++axis)
dim 			 bounds  as variant = me.m_bounds[axis]

dim 			 lowerIndex  as variant = 0

dim 			 upperIndex  as variant = 0

dim 			 lowerIndexOut  as variant = [lowerIndex]

dim 			 upperIndexOut  as variant = [upperIndex]

			 me.Query(lowerIndexOut, upperIndexOut, lowerValues[axis], upperValues[axis], bounds, boundCount, axis)
			lowerIndex = lowerIndexOut[0]
			upperIndex = upperIndexOut[0]
			' //  Replace memmove calls
			' // memmove(bounds + upperIndex + 2, bounds + upperIndex, (edgeCount - upperIndex) * sizeof(b2Bound))
dim 			 tArr  as variant = new Array()

dim 			 j  as variant = 0

dim 			 tEnd  as variant = boundCount - upperIndex
dim 			tBound1
 as variant
dim 			tBound2
 as variant
			' //  make temp array
			for (j = 0; j < tEnd; j++)
				tArr[j] = new b2Bound()
				tBound1 = tArr[j]
				tBound2 = bounds[upperIndex+j]
				tBound1.value = tBound2.value
				tBound1.proxyId = tBound2.proxyId
				tBound1.stabbingCount = tBound2.stabbingCount
			
			' //  move temp array back in to bounds
			tEnd = tArr.length
dim 			 tIndex  as variant = upperIndex+2

			for (j = 0; j < tEnd; j++)
				' // bounds[tIndex+j] = tArr[j]
				tBound2 = tArr[j]
				tBound1 = bounds[tIndex+j]
				tBound1.value = tBound2.value
				tBound1.proxyId = tBound2.proxyId
				tBound1.stabbingCount = tBound2.stabbingCount
			
			' // memmove(bounds + lowerIndex + 1, bounds + lowerIndex, (upperIndex - lowerIndex) * sizeof(b2Bound))
			' //  make temp array
			tArr = new Array()
			tEnd = upperIndex - lowerIndex
			for (j = 0; j < tEnd; j++)
				tArr[j] = new b2Bound()
				tBound1 = tArr[j]
				tBound2 = bounds[lowerIndex+j]
				tBound1.value = tBound2.value
				tBound1.proxyId = tBound2.proxyId
				tBound1.stabbingCount = tBound2.stabbingCount
			
			' //  move temp array back in to bounds
			tEnd = tArr.length
			tIndex = lowerIndex+1
			for (j = 0; j < tEnd; j++)
				' // bounds[tIndex+j] = tArr[j]
				tBound2 = tArr[j]
				tBound1 = bounds[tIndex+j]
				tBound1.value = tBound2.value
				tBound1.proxyId = tBound2.proxyId
				tBound1.stabbingCount = tBound2.stabbingCount
			
			' //  The upper index has increased because of the lower bound insertion.
			++upperIndex
			' //  Copy in the new bounds.
			bounds[lowerIndex].value = lowerValues[axis]
			bounds[lowerIndex].proxyId = proxyId
			bounds[upperIndex].value = upperValues[axis]
			bounds[upperIndex].proxyId = proxyId
			bounds[lowerIndex].stabbingCount = lowerIndex == 0 ? 0 : bounds[lowerIndex-1].stabbingCount
			bounds[upperIndex].stabbingCount = bounds[upperIndex-1].stabbingCount
			' //  Adjust the stabbing count between the new bounds.
			for (index = lowerIndex; index < upperIndex; ++index)
			
				bounds[index].stabbingCount++
			
			' //  Adjust the all the affected bound indices.
			for (index = lowerIndex; index < boundCount + 2; ++index)
			
dim 				 proxy2  as variant = me.m_proxyPool[ bounds[index].proxyId ]

				if (bounds[index].IsLower())
				
					proxy2.lowerBounds[axis] = index
				
				else
				
					proxy2.upperBounds[axis] = index
				
			
		++ me.m_proxyCount
		' // b2Settings.b2Assert( me.m_queryResultCount < b2Settings.b2_maxProxies)
		for (var i = 0; i < me.m_queryResultCount; ++i)
			' // b2Settings.b2Assert( me.m_queryResults[i] < b2_maxProxies)
			' // b2Settings.b2Assert( me.m_proxyPool[ me.m_queryResults[i]].IsValid())
			 me.m_pairManager.AddBufferedPair(proxyId, me.m_queryResults[i])
		 me.m_pairManager.Commit()
		' //  Prepare for next query.
		 me.m_queryResultCount = 0
		 me.IncrementTimeStamp()
		return proxyId
 '' TODO: posible funcion (revisar)

end

public  sub 	DestroyProxy(proxyId as variant)

		' // b2Settings.b2Assert(0 < me.m_proxyCount && me.m_proxyCount <= b2_maxProxies)
dim 		 proxy  as variant = me.m_proxyPool[ proxyId ]

		' // b2Settings.b2Assert(proxy.IsValid())
dim 		 boundCount  as variant = 2 * me.m_proxyCount

		for (var axis = 0; axis < 2; ++axis)
dim 			 bounds  as variant = me.m_bounds[axis]

dim 			 lowerIndex  as variant = proxy.lowerBounds[axis]

dim 			 upperIndex  as variant = proxy.upperBounds[axis]

dim 			 lowerValue  as variant = bounds[lowerIndex].value

dim 			 upperValue  as variant = bounds[upperIndex].value

			' //  replace memmove calls
			' // memmove(bounds + lowerIndex, bounds + lowerIndex + 1, (upperIndex - lowerIndex - 1) * sizeof(b2Bound))
dim 			 tArr  as variant = new Array()

dim 			 j  as variant = 0

dim 			 tEnd  as variant = upperIndex - lowerIndex - 1

dim 			tBound1
 as variant
dim 			tBound2
 as variant
			' //  make temp array
			for (j = 0; j < tEnd; j++)
				tArr[j] = new b2Bound()
				tBound1 = tArr[j]
				tBound2 = bounds[lowerIndex+1+j]
				tBound1.value = tBound2.value
				tBound1.proxyId = tBound2.proxyId
				tBound1.stabbingCount = tBound2.stabbingCount
			
			' //  move temp array back in to bounds
			tEnd = tArr.length
dim 			 tIndex  as variant = lowerIndex

			for (j = 0; j < tEnd; j++)
				' // bounds[tIndex+j] = tArr[j]
				tBound2 = tArr[j]
				tBound1 = bounds[tIndex+j]
				tBound1.value = tBound2.value
				tBound1.proxyId = tBound2.proxyId
				tBound1.stabbingCount = tBound2.stabbingCount
			
			' // memmove(bounds + upperIndex-1, bounds + upperIndex + 1, (edgeCount - upperIndex - 1) * sizeof(b2Bound))
			' //  make temp array
			tArr = new Array()
			tEnd = boundCount - upperIndex - 1
			for (j = 0; j < tEnd; j++)
				tArr[j] = new b2Bound()
				tBound1 = tArr[j]
				tBound2 = bounds[upperIndex+1+j]
				tBound1.value = tBound2.value
				tBound1.proxyId = tBound2.proxyId
				tBound1.stabbingCount = tBound2.stabbingCount
			
			' //  move temp array back in to bounds
			tEnd = tArr.length
			tIndex = upperIndex-1
			for (j = 0; j < tEnd; j++)
				' // bounds[tIndex+j] = tArr[j]
				tBound2 = tArr[j]
				tBound1 = bounds[tIndex+j]
				tBound1.value = tBound2.value
				tBound1.proxyId = tBound2.proxyId
				tBound1.stabbingCount = tBound2.stabbingCount
			
			' //  Fix bound indices.
			tEnd = boundCount - 2
			for (var index = lowerIndex; index < tEnd; ++index)
			
dim 				 proxy2  as variant = me.m_proxyPool[ bounds[index].proxyId ]

				if (bounds[index].IsLower())
				
					proxy2.lowerBounds[axis] = index
				
				else
				
					proxy2.upperBounds[axis] = index
				
			
			' //  Fix stabbing count.
			tEnd = upperIndex - 1
			for (var index2 = lowerIndex; index2 < tEnd; ++index2)
			
				bounds[index2].stabbingCount--
			
			' //  me.Query for pairs to be removed. lowerIndex and upperIndex are not needed.
			' //  make lowerIndex and upper output using an array and do this for others if compiler doesn't pick them up
			 me.Query([0], [0], lowerValue, upperValue, bounds, boundCount - 2, axis)
		' // b2Settings.b2Assert( me.m_queryResultCount < b2Settings.b2_maxProxies)
		for (var i = 0; i < me.m_queryResultCount; ++i)
			' // b2Settings.b2Assert( me.m_proxyPool[ me.m_queryResults[i]].IsValid())
			 me.m_pairManager.RemoveBufferedPair(proxyId, me.m_queryResults[i])
		 me.m_pairManager.Commit()
		' //  Prepare for next query.
		 me.m_queryResultCount = 0
		 me.IncrementTimeStamp()
		' //  Return the proxy to the pool.
		proxy.userData = null
		proxy.overlapCount = b2BroadPhase.b2_invalid
		proxy.lowerBounds[0] = b2BroadPhase.b2_invalid
		proxy.lowerBounds[1] = b2BroadPhase.b2_invalid
		proxy.upperBounds[0] = b2BroadPhase.b2_invalid
		proxy.upperBounds[1] = b2BroadPhase.b2_invalid
		proxy.SetNext( me.m_freeProxy)
		 me.m_freeProxy = proxyId
		-- me.m_proxyCount
	' //  Call me.MoveProxy times like, then when you are done
	' //  call me.Commit to finalized the proxy pairs (for your time step).
end

public  sub 	MoveProxy(proxyId as variant, aabb as variant) as variant ''funcio as variant ''funcion
dim 		 axis  as variant = 0

dim 		 index  as variant = 0

dim 		bound
 as variant
dim 		prevBound as variant
dim 		nextBound as variant
dim 		 nextProxyId  as variant = 0

dim 		nextProxy
 as variant
		if (proxyId == b2Pair.b2_nullProxy || b2Settings.b2_maxProxies <= proxyId)
			' // b2Settings.b2Assert(false)
			return
 '' TODO: posible funcion (revisar)

		if (aabb.IsValid() == false)
			' // b2Settings.b2Assert(false)
			return
 '' TODO: posible funcion (revisar)

dim 		 boundCount  as variant = 2 * me.m_proxyCount

dim 		 proxy  as variant = me.m_proxyPool[ proxyId ]

		' //  Get new bound values
dim 		 newValues  as variant = new b2BoundValues()

		 me.ComputeBounds(newValues.lowerValues, newValues.upperValues, aabb)
		' //  Get old bound values
dim 		 oldValues  as variant = new b2BoundValues()

		for (axis = 0; axis < 2; ++axis)
			oldValues.lowerValues[axis] = me.m_bounds[axis][proxy.lowerBounds[axis]].value
			oldValues.upperValues[axis] = me.m_bounds[axis][proxy.upperBounds[axis]].value
		for (axis = 0; axis < 2; ++axis)
dim 			 bounds  as variant = me.m_bounds[axis]

dim 			 lowerIndex  as variant = proxy.lowerBounds[axis]

dim 			 upperIndex  as variant = proxy.upperBounds[axis]

dim 			 lowerValue  as variant = newValues.lowerValues[axis]

dim 			 upperValue  as variant = newValues.upperValues[axis]

dim 			 deltaLower  as variant = lowerValue - bounds[lowerIndex].value

dim 			 deltaUpper  as variant = upperValue - bounds[upperIndex].value

			bounds[lowerIndex].value = lowerValue
			bounds[upperIndex].value = upperValue
			' // 
			' //  Expanding adds overlaps
			' // 
			' //  Should we move the lower bound down?
			if (deltaLower < 0)
			
				index = lowerIndex
				while (index > 0 && lowerValue < bounds[index-1].value)
				
					bound = bounds[index]
					prevBound = bounds[index - 1]
dim 					 prevProxyId  as variant = prevBound.proxyId

dim 					 prevProxy  as variant = me.m_proxyPool[ prevBound.proxyId ]

					prevBound.stabbingCount++
					if (prevBound.IsUpper() == true)
					
						if ( me.TestOverlap(newValues, prevProxy))
						
							 me.m_pairManager.AddBufferedPair(proxyId, prevProxyId)
						
						prevProxy.upperBounds[axis]++
						bound.stabbingCount++
					
					else
					
						prevProxy.lowerBounds[axis]++
						bound.stabbingCount--
					
					proxy.lowerBounds[axis]--
					' //  swap
					' // var temp = bound
					' // bound = prevEdge
					' // prevEdge = temp
					bound.Swap(prevBound)
					' // b2Math.b2Swap(bound, prevEdge)
					--index
				
			
			' //  Should we move the upper bound up?
			if (deltaUpper > 0)
			
				index = upperIndex
				while (index < boundCount-1 && bounds[index+1].value <= upperValue)
				
					bound = bounds[ index ]
					nextBound = bounds[ index + 1 ]
					nextProxyId = nextBound.proxyId
					nextProxy = me.m_proxyPool[ nextProxyId ]
					nextBound.stabbingCount++
					if (nextBound.IsLower() == true)
					
						if ( me.TestOverlap(newValues, nextProxy))
						
							 me.m_pairManager.AddBufferedPair(proxyId, nextProxyId)
						
						nextProxy.lowerBounds[axis]--
						bound.stabbingCount++
					
					else
					
						nextProxy.upperBounds[axis]--
						bound.stabbingCount--
					
					proxy.upperBounds[axis]++
					' //  swap
					' // var temp = bound
					' // bound = nextEdge
					' // nextEdge = temp
					bound.Swap(nextBound)
					' // b2Math.b2Swap(bound, nextEdge)
					index++
				
			
			' // 
			' //  Shrinking removes overlaps
			' // 
			' //  Should we move the lower bound up?
			if (deltaLower > 0)
			
				index = lowerIndex
				while (index < boundCount-1 && bounds[index+1].value <= lowerValue)
				
					bound = bounds[ index ]
					nextBound = bounds[ index + 1 ]
					nextProxyId = nextBound.proxyId
					nextProxy = me.m_proxyPool[ nextProxyId ]
					nextBound.stabbingCount--
					if (nextBound.IsUpper())
					
						if ( me.TestOverlap(oldValues, nextProxy))
						
							 me.m_pairManager.RemoveBufferedPair(proxyId, nextProxyId)
						
						nextProxy.upperBounds[axis]--
						bound.stabbingCount--
					
					else
					
						nextProxy.lowerBounds[axis]--
						bound.stabbingCount++
					
					proxy.lowerBounds[axis]++
					' //  swap
					' // var temp = bound
					' // bound = nextEdge
					' // nextEdge = temp
					bound.Swap(nextBound)
					' // b2Math.b2Swap(bound, nextEdge)
					index++
				
			
			' //  Should we move the upper bound down?
			if (deltaUpper < 0)
			
				index = upperIndex
				while (index > 0 && upperValue < bounds[index-1].value)
				
					bound = bounds[index]
					prevBound = bounds[index - 1]
					prevProxyId = prevBound.proxyId
					prevProxy = me.m_proxyPool[ prevProxyId ]
					prevBound.stabbingCount--
					if (prevBound.IsLower() == true)
					
						if ( me.TestOverlap(oldValues, prevProxy))
						
							 me.m_pairManager.RemoveBufferedPair(proxyId, prevProxyId)
						
						prevProxy.lowerBounds[axis]++
						bound.stabbingCount--
					
					else
					
						prevProxy.upperBounds[axis]++
						bound.stabbingCount++
					
					proxy.upperBounds[axis]--
					' //  swap
					' // var temp = bound
					' // bound = prevEdge
					' // prevEdge = temp
					bound.Swap(prevBound)
					' // b2Math.b2Swap(bound, prevEdge)
					index--
				
			
end

public  sub 	Commit() as variant ''funcion
		 me.m_pairManager.Commit()
	' //  me.Query an AABB for overlapping proxies, returns the user data and '' TODO: posible funcion (revisar)

	' //  the count, up to the supplied maximum count.
end

public  sub 	QueryAABB(aabb as variant, userData as variant, maxCount as variant) as variant ''funcion
dim 		 lowerValues  as variant = new Array()

dim 		 upperValues  as variant = new Array()

		 me.ComputeBounds(lowerValues, upperValues, aabb)
dim 		 lowerIndex  as variant = 0

dim 		 upperIndex  as variant = 0

dim 		 lowerIndexOut  as variant = [lowerIndex]

dim 		 upperIndexOut  as variant = [upperIndex]

		 me.Query(lowerIndexOut, upperIndexOut, lowerValues[0], upperValues[0], me.m_bounds[0], 2* me.m_proxyCount, 0)
		 me.Query(lowerIndexOut, upperIndexOut, lowerValues[1], upperValues[1], me.m_bounds[1], 2* me.m_proxyCount, 1)
		' // b2Settings.b2Assert( me.m_queryResultCount < b2Settings.b2_maxProxies)
dim 		 count  as variant = 0

		for (var i = 0; i < me.m_queryResultCount && count < maxCount; ++i, ++count)
			' // b2Settings.b2Assert( me.m_queryResults[i] < b2Settings.b2_maxProxies)
dim 			 proxy  as variant = me.m_proxyPool[ me.m_queryResults[i] ]

			' // b2Settings.b2Assert(proxy.IsValid())
			userData[i] = proxy.userData
		' //  Prepare for next query.
		 me.m_queryResultCount = 0
		 me.IncrementTimeStamp()
		return count
 '' TODO: posible funcion (revisar)

end

public  sub 	Validate()

dim 		pair
 as variant
dim 		proxy1
 as variant
dim 		proxy2
 as variant
dim 		overlap
 as variant
		for (var axis = 0; axis < 2; ++axis)
dim 			 bounds  as variant = me.m_bounds[axis]

dim 			 boundCount  as variant = 2 * me.m_proxyCount

dim 			 stabbingCount  as variant = 0

			for (var i = 0; i < boundCount; ++i)
			
dim 				 bound  as variant = bounds[i]

				' // b2Settings.b2Assert(i == 0 || bounds[i-1].value <= bound->value)
				' // b2Settings.b2Assert(bound->proxyId != b2_nullProxy)
				' // b2Settings.b2Assert( me.m_proxyPool[bound->proxyId].IsValid())
				if (bound.IsLower() == true)
				
					' // b2Settings.b2Assert( me.m_proxyPool[bound.proxyId].lowerBounds[axis] == i)
					stabbingCount++
				
				else
				
					' // b2Settings.b2Assert( me.m_proxyPool[bound.proxyId].upperBounds[axis] == i)
					stabbingCount--
				
				' // b2Settings.b2Assert(bound.stabbingCount == stabbingCount)
			
' // private:
end

public  sub 	ComputeBounds(lowerValues as variant, upperValues as variant, aabb as variant)

		' // b2Settings.b2Assert(aabb.maxVertex.x > aabb.minVertex.x)
		' // b2Settings.b2Assert(aabb.maxVertex.y > aabb.minVertex.y)
		' // var minVertex = b2Math.b2ClampV(aabb.minVertex, me.m_worldAABB.minVertex, me.m_worldAABB.maxVertex)
dim 		 minVertexX  as variant = aabb.minVertex.x

dim 		 minVertexY  as variant = aabb.minVertex.y

		minVertexX = b2Math.b2Min(minVertexX, me.m_worldAABB.maxVertex.x)
		minVertexY = b2Math.b2Min(minVertexY, me.m_worldAABB.maxVertex.y)
		minVertexX = b2Math.b2Max(minVertexX, me.m_worldAABB.minVertex.x)
		minVertexY = b2Math.b2Max(minVertexY, me.m_worldAABB.minVertex.y)
		' // var maxVertex = b2Math.b2ClampV(aabb.maxVertex, me.m_worldAABB.minVertex, me.m_worldAABB.maxVertex)
dim 		 maxVertexX  as variant = aabb.maxVertex.x

dim 		 maxVertexY  as variant = aabb.maxVertex.y

		maxVertexX = b2Math.b2Min(maxVertexX, me.m_worldAABB.maxVertex.x)
		maxVertexY = b2Math.b2Min(maxVertexY, me.m_worldAABB.maxVertex.y)
		maxVertexX = b2Math.b2Max(maxVertexX, me.m_worldAABB.minVertex.x)
		maxVertexY = b2Math.b2Max(maxVertexY, me.m_worldAABB.minVertex.y)
		' //  Bump lower bounds downs and upper bounds up. This ensures correct sorting of
		' //  lower/upper bounds that would have equal values.
		' //  TODO_ERIN implement fast float to uint16 conversion.
		lowerValues[0] = ' /* uint*/( me.m_quantizationFactor.x * (minVertexX - me.m_worldAABB.minVertex.x)) & (b2Settings.USHRT_MAX - 1)
		upperValues[0] = (' /* uint*/( me.m_quantizationFactor.x * (maxVertexX - me.m_worldAABB.minVertex.x))& 0x0000ffff) | 1
		lowerValues[1] = ' /* uint*/( me.m_quantizationFactor.y * (minVertexY - me.m_worldAABB.minVertex.y)) & (b2Settings.USHRT_MAX - 1)
		upperValues[1] = (' /* uint*/( me.m_quantizationFactor.y * (maxVertexY - me.m_worldAABB.minVertex.y))& 0x0000ffff) | 1
	' //  This one is only used for validation.
end

public  sub 	TestOverlapValidate(p1 as variant, p2 as variant) as variant ''funcio as variant ''funcio as variant ''funcion
		for (var axis = 0; axis < 2; ++axis)
dim 			 bounds  as variant = me.m_bounds[axis]

			' // b2Settings.b2Assert(p1.lowerBounds[axis] < 2 * me.m_proxyCount)
			' // b2Settings.b2Assert(p1.upperBounds[axis] < 2 * me.m_proxyCount)
			' // b2Settings.b2Assert(p2.lowerBounds[axis] < 2 * me.m_proxyCount)
			' // b2Settings.b2Assert(p2.upperBounds[axis] < 2 * me.m_proxyCount)
			if (bounds[p1.lowerBounds[axis]].value > bounds[p2.upperBounds[axis]].value)
				return false
 '' TODO: posible funcion (revisar)

			if (bounds[p1.upperBounds[axis]].value < bounds[p2.lowerBounds[axis]].value)
				return false
 '' TODO: posible funcion (revisar)

		return true
 '' TODO: posible funcion (revisar)

end

public  sub 	TestOverlap(b as variant, p as variant) as variant ''funcio as variant ''funcio as variant ''funcion
		for (var axis = 0; axis < 2; ++axis)
dim 			 bounds  as variant = me.m_bounds[axis]

			' // b2Settings.b2Assert(p.lowerBounds[axis] < 2 * me.m_proxyCount)
			' // b2Settings.b2Assert(p.upperBounds[axis] < 2 * me.m_proxyCount)
			if (b.lowerValues[axis] > bounds[p.upperBounds[axis]].value)
				return false
 '' TODO: posible funcion (revisar)

			if (b.upperValues[axis] < bounds[p.lowerBounds[axis]].value)
				return false
 '' TODO: posible funcion (revisar)

		return true
 '' TODO: posible funcion (revisar)

end

public  sub 	Query(lowerQueryOut as variant, upperQueryOut as variant, lowerValue as variant, upperValue as variant, bounds as variant, boundCount as variant, axis as variant)

dim 		 lowerQuery  as variant = b2BroadPhase.BinarySearch(bounds, boundCount, lowerValue)

dim 		 upperQuery  as variant = b2BroadPhase.BinarySearch(bounds, boundCount, upperValue)

		' //  Easy case: lowerQuery <= lowerIndex(i) < upperQuery
		' //  Solution: search query range for min bounds.
		for (var j = lowerQuery; j < upperQuery; ++j)
			if (bounds[j].IsLower())
			
				 me.IncrementOverlapCount(bounds[j].proxyId)
			
		' //  Hard case: lowerIndex(i) < lowerQuery < upperIndex(i)
		' //  Solution: use the stabbing count to search down the bound array.
		if (lowerQuery > 0)
dim 			 i  as variant = lowerQuery - 1

dim 			 s  as variant = bounds[i].stabbingCount

			' //  Find the s overlaps.
			while (s)
			
				' // b2Settings.b2Assert(i >= 0)
				if (bounds[i].IsLower())
				
dim 					 proxy  as variant = me.m_proxyPool[ bounds[i].proxyId ]

					if (lowerQuery <= proxy.upperBounds[axis])
					
						 me.IncrementOverlapCount(bounds[i].proxyId)
						--s
					
				
				--i
			
		lowerQueryOut[0] = lowerQuery
		upperQueryOut[0] = upperQuery
end

public  sub 	IncrementOverlapCount(proxyId as variant)

dim 		 proxy  as variant = me.m_proxyPool[ proxyId ]

		if (proxy.timeStamp < me.m_timeStamp)
			proxy.timeStamp = me.m_timeStamp
			proxy.overlapCount = 1
		else
			proxy.overlapCount = 2
			' // b2Settings.b2Assert( me.m_queryResultCount < b2Settings.b2_maxProxies)
			 me.m_queryResults[ me.m_queryResultCount] = proxyId
			++ me.m_queryResultCount
end

public  sub 	IncrementTimeStamp()

		if ( me.m_timeStamp == b2Settings.USHRT_MAX)
			for (var i = 0; i < b2Settings.b2_maxProxies; ++i)
			
				 me.m_proxyPool[i].timeStamp = 0
			
			 me.m_timeStamp = 1
		else
			++ me.m_timeStamp
' // public:
Public r: new b2PairManager(), as new 2PairManager(),
Public l: new Array(b2Settings.b2_maxPairs), as new rray(b2Settings.b2_maxPairs),
	m_freeProxy: 0
Public s: new Array(2*b2Settings.b2_maxProxies), as new rray(2*b2Settings.b2_maxProxies),
Public s: new Array(b2Settings.b2_maxProxies), as new rray(b2Settings.b2_maxProxies),
	m_queryResultCount: 0
	m_worldAABB: null
Public r: new b2Vec2(), as new 2Vec2(),
	m_proxyCount: 0
	m_timeStamp: 0
b2BroadPhase.s_validate = false
b2BroadPhase.b2_invalid = b2Settings.USHRT_MAX
b2BroadPhase.b2_nullEdge = b2Settings.USHRT_MAX
end

public  sub BinarySearch (bounds as variant, count as variant, value as variant) as variant ''funcio as variant ''funcion
dim 		 low  as variant = 0

dim 		 high  as variant = count - 1

		while (low <= high)
dim 			 mid  as variant = Math.floor((low + high) / 2)

			if (bounds[mid].value > value)
			
				high = mid - 1
			
			else if (bounds[mid].value < value)
			
				low = mid + 1
			
			else
			
				return ' /* uint*/(mid)
 '' TODO: posible funcion (revisar)

			
		return ' /* uint*/(low)
 '' TODO: posible funcion (revisar)
