' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2Math  as variant = Class.create()

b2Math.prototype = 
	' /* static public function b2InvSqrt(x)
		float32 xhalf = 0.5f * x
		int32 i = *(int32*)&x
		i = 0x5f3759df - (i >> 1)
		x = *(float32*)&i
		x = x * (1.5f - xhalf * x * x)
		return x
 '' TODO: posible funcion (revisar)

	*/
	' //  A * B
	' //  A^T * B
	' //  b2Math.b2Random number in range [-1,1]
	' /* inline float32 b2Math.b2Random(float32 lo, float32 hi)
		float32 r = (float32)rand()
		r /= RAND_MAX
		r = (hi - lo) * r + lo
		return r
 '' TODO: posible funcion (revisar)

	*/
	' //  "Next Largest Power of 2
	' //  Given a binary integer value x, the next largest power of 2 can be computed by a SWAR algorithm
	' //  that recursively "folds" the upper bits into the lower bits. This process yields a bit vector with
	' //  the same most significant 1, but all 1's below it. Adding 1 to that value yields the next
	' //  largest power of 2. For a 32-bit value:"
	' //  Temp vector functions to reduce calls to 'new'
	' /* static public var tempVec = new b2Vec2()
	static public var tempAABB = new b2AABB()
	*/
public  sub 	initialize()
 
public  sub b2IsValid (x as variant) as variant ''funcion
		return isFinite(x)
 '' TODO: posible funcion (revisar)

end

public  sub b2Dot (a as variant, b as variant) as variant ''funcion
		return a.x * b.x + a.y * b.y
 '' TODO: posible funcion (revisar)

end

public  sub b2CrossVV (a as variant, b as variant) as variant ''funcion
		return a.x * b.y - a.y * b.x
 '' TODO: posible funcion (revisar)

end

public  sub b2CrossVF (a as variant, s as variant) as variant ''funcion
dim 		 v  as variant = new b2Vec2(s * a.y, -s * a.x)

		return v
 '' TODO: posible funcion (revisar)

end

public  sub b2CrossFV (s as variant, a as variant) as variant ''funcion
dim 		 v  as variant = new b2Vec2(-s * a.y, s * a.x)

		return v
 '' TODO: posible funcion (revisar)

end

public  sub b2MulMV (A as variant, v as variant) as variant ''funcion
dim 		 u  as variant = new b2Vec2(A.col1.x * v.x + A.col2.x * v.y, A.col1.y * v.x + A.col2.y * v.y)

		return u
 '' TODO: posible funcion (revisar)

end

public  sub b2MulTMV (A as variant, v as variant) as variant ''funcion
dim 		 u  as variant = new b2Vec2(b2Math.b2Dot(v, A.col1), b2Math.b2Dot(v, A.col2))

		return u
 '' TODO: posible funcion (revisar)

end

public  sub AddVV (a as variant, b as variant) as variant ''funcion
dim 		 v  as variant = new b2Vec2(a.x + b.x, a.y + b.y)

		return v
 '' TODO: posible funcion (revisar)

end

public  sub SubtractVV (a as variant, b as variant) as variant ''funcion
dim 		 v  as variant = new b2Vec2(a.x - b.x, a.y - b.y)

		return v
 '' TODO: posible funcion (revisar)

end

public  sub MulFV (s as variant, a as variant) as variant ''funcion
dim 		 v  as variant = new b2Vec2(s * a.x, s * a.y)

		return v
 '' TODO: posible funcion (revisar)

end

public  sub AddMM (A as variant, B as variant) as variant ''funcion
dim 		 C  as variant = new b2Mat22(0, b2Math.AddVV(A.col1, B.col1), b2Math.AddVV(A.col2, B.col2))

		return C
 '' TODO: posible funcion (revisar)

end

public  sub b2MulMM (A as variant, B as variant) as variant ''funcion
dim 		 C  as variant = new b2Mat22(0, b2Math.b2MulMV(A, B.col1), b2Math.b2MulMV(A, B.col2))

		return C
 '' TODO: posible funcion (revisar)

end

public  sub b2MulTMM (A as variant, B as variant) as variant ''funcion
dim 		 c1  as variant = new b2Vec2(b2Math.b2Dot(A.col1, B.col1), b2Math.b2Dot(A.col2, B.col1))

dim 		 c2  as variant = new b2Vec2(b2Math.b2Dot(A.col1, B.col2), b2Math.b2Dot(A.col2, B.col2))

dim 		 C  as variant = new b2Mat22(0, c1, c2)

		return C
 '' TODO: posible funcion (revisar)

end

public  sub b2Abs (a as variant) as variant ''funcion
		return a > 0.0 ? a : -a
 '' TODO: posible funcion (revisar)

end

public  sub b2AbsV (a as variant) as variant ''funcion
dim 		 b  as variant = new b2Vec2(b2Math.b2Abs(a.x), b2Math.b2Abs(a.y))

		return b
 '' TODO: posible funcion (revisar)

end

public  sub b2AbsM (A as variant) as variant ''funcion
dim 		 B  as variant = new b2Mat22(0, b2Math.b2AbsV(A.col1), b2Math.b2AbsV(A.col2))

		return B
 '' TODO: posible funcion (revisar)

end

public  sub b2Min (a as variant, b as variant) as variant ''funcion
		return a < b ? a : b
 '' TODO: posible funcion (revisar)

end

public  sub b2MinV (a as variant, b as variant) as variant ''funcion
dim 		 c  as variant = new b2Vec2(b2Math.b2Min(a.x, b.x), b2Math.b2Min(a.y, b.y))

		return c
 '' TODO: posible funcion (revisar)

end

public  sub b2Max (a as variant, b as variant) as variant ''funcion
		return a > b ? a : b
 '' TODO: posible funcion (revisar)

end

public  sub b2MaxV (a as variant, b as variant) as variant ''funcion
dim 		 c  as variant = new b2Vec2(b2Math.b2Max(a.x, b.x), b2Math.b2Max(a.y, b.y))

		return c
 '' TODO: posible funcion (revisar)

end

public  sub b2Clamp (a as variant, low as variant, high as variant) as variant ''funcion
		return b2Math.b2Max(low, b2Math.b2Min(a, high))
 '' TODO: posible funcion (revisar)

end

public  sub b2ClampV (a as variant, low as variant, high as variant) as variant ''funcion
		return b2Math.b2MaxV(low, b2Math.b2MinV(a, high))
 '' TODO: posible funcion (revisar)

end

public  sub b2Swap (a as variant, b as variant)

dim 		 tmp  as variant = a[0]

		a[0] = b[0]
		b[0] = tmp
end

public  sub b2Random () as variant ''funcion
		return Math.random() * 2 - 1
 '' TODO: posible funcion (revisar)

end

public  sub b2NextPowerOfTwo (x as variant) as variant ''funcion
		x |= (x >> 1) & 0x7FFFFFFF
		x |= (x >> 2) & 0x3FFFFFFF
		x |= (x >> 4) & 0x0FFFFFFF
		x |= (x >> 8) & 0x00FFFFFF
		x |= (x >> 16)& 0x0000FFFF
		return x + 1
 '' TODO: posible funcion (revisar)

end

public  sub b2IsPowerOfTwo (x as variant) as variant ''funcion
dim 		 result  as variant = x > 0 && (x & (x - 1)) == 0

		return result
 '' TODO: posible funcion (revisar)

b2Math.tempVec2 = new b2Vec2()
b2Math.tempVec3 = new b2Vec2()
b2Math.tempVec4 = new b2Vec2()
b2Math.tempVec5 = new b2Vec2()
b2Math.tempMat = new b2Mat22()
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2Mat22  as variant = Class.create()

b2Mat22.prototype = 
end

public  sub 	initialize(angle as variant, c1 as variant, c2 as variant)

		if (angle==null) angle = 0
		' //  initialize instance variables for references
		 me.col1 = new b2Vec2()
		 me.col2 = new b2Vec2()
		' // 
		if (c1!=null && c2!=null)
			 me.col1.SetV(c1)
			 me.col2.SetV(c2)
		else
dim 			 c  as variant = Math.cos(angle)

dim 			 s  as variant = Math.sin(angle)

			 me.col1.x = c
 me.col2.x = -s
			 me.col1.y = s
 me.col2.y = c
end

public  sub 	Set(angle as variant)

dim 		 c  as variant = Math.cos(angle)

dim 		 s  as variant = Math.sin(angle)

		 me.col1.x = c
 me.col2.x = -s
		 me.col1.y = s
 me.col2.y = c
end

public  sub 	SetVV(c1 as variant, c2 as variant)

		 me.col1.SetV(c1)
		 me.col2.SetV(c2)
end

public  sub 	Copy() as variant ''funcion
		return new b2Mat22(0, me.col1, me.col2)
 '' TODO: posible funcion (revisar)

end

public  sub 	SetM(m as variant)

		 me.col1.SetV(m.col1)
		 me.col2.SetV(m.col2)
end

public  sub 	AddM(m as variant)

		 me.col1.x += m.col1.x
		 me.col1.y += m.col1.y
		 me.col2.x += m.col2.x
		 me.col2.y += m.col2.y
end

public  sub 	SetIdentity()

		 me.col1.x = 1.0
 me.col2.x = 0.0
		 me.col1.y = 0.0
 me.col2.y = 1.0
end

public  sub 	SetZero()

		 me.col1.x = 0.0
 me.col2.x = 0.0
		 me.col1.y = 0.0
 me.col2.y = 0.0
end

public  sub 	Invert(out as variant) as variant ''funcion
dim 		 a  as variant = me.col1.x

dim 		 b  as variant = me.col2.x

dim 		 c  as variant = me.col1.y

dim 		 d  as variant = me.col2.y

		' // var B = new b2Mat22()
dim 		 det  as variant = a * d - b * c

		' // b2Settings.b2Assert(det != 0.0)
		det = 1.0 / det
		out.col1.x =  det * d
	out.col2.x = -det * b
		out.col1.y = -det * c
	out.col2.y =  det * a
		return out
 '' TODO: posible funcion (revisar)

	' //  me.Solve A * x = b
end

public  sub 	Solve(out as variant, bX as variant, bY as variant) as variant ''funcion
		' // float32 a11 = me.col1.x, a12 = me.col2.x, a21 = me.col1.y, a22 = me.col2.y
dim 		 a11  as variant = me.col1.x

dim 		 a12  as variant = me.col2.x

dim 		 a21  as variant = me.col1.y

dim 		 a22  as variant = me.col2.y

		' // float32 det = a11 * a22 - a12 * a21
dim 		 det  as variant = a11 * a22 - a12 * a21

		' // b2Settings.b2Assert(det != 0.0)
		det = 1.0 / det
		out.x = det * (a22 * bX - a12 * bY)
		out.y = det * (a11 * bY - a21 * bX)
		return out
 '' TODO: posible funcion (revisar)

end

public  sub 	Abs()

		 me.col1.Abs()
		 me.col2.Abs()
Public 1: new b2Vec2(), as new 2Vec2(),
Public 2: new b2Vec2()
 as new 2Vec2()

﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  b2Vec2 has no constructor so that it
' //  can be placed in a union.
dim  b2Vec2  as variant = Class.create()

b2Vec2.prototype = 
end

public  sub 	initialize(x_ as variant, y_ as variant)
  me.x=x_
 me.y=y_
end

public  sub 	SetZero()
  me.x = 0.0
 me.y = 0.0
 
end

public  sub 	Set(x_ as variant, y_ as variant)
  me.x=x_
 me.y=y_
end

public  sub 	SetV(v as variant)
  me.x=v.x
 me.y=v.y
end

public  sub 	Negative()
 return new b2Vec2(- me.x, - me.y)
  '' TODO: posible funcion (revisar)

end

public  sub 	Copy() as variant ''funcion
		return new b2Vec2( me.x, me.y)
 '' TODO: posible funcion (revisar)

end

public  sub 	Add(v as variant)

		 me.x += v.x
 me.y += v.y
end

public  sub 	Subtract(v as variant)

		 me.x -= v.x
 me.y -= v.y
end

public  sub 	Multiply(a as variant)

		 me.x *= a
 me.y *= a
end

public  sub 	MulM(A as variant)

dim 		 tX  as variant = me.x

		 me.x = A.col1.x * tX + A.col2.x * me.y
		 me.y = A.col1.y * tX + A.col2.y * me.y
end

public  sub 	MulTM(A as variant)

dim 		 tX  as variant = b2Math.b2Dot(this, A.col1)

		 me.y = b2Math.b2Dot(this, A.col2)
		 me.x = tX
end

public  sub 	CrossVF(s as variant)

dim 		 tX  as variant = me.x

		 me.x = s * me.y
		 me.y = -s * tX
end

public  sub 	CrossFV(s as variant)

dim 		 tX  as variant = me.x

		 me.x = -s * me.y
		 me.y = s * tX
end

public  sub 	MinV(b as variant)

		 me.x = me.x < b.x ? me.x : b.x
		 me.y = me.y < b.y ? me.y : b.y
end

public  sub 	MaxV(b as variant)

		 me.x = me.x > b.x ? me.x : b.x
		 me.y = me.y > b.y ? me.y : b.y
end

public  sub 	Abs()

		 me.x = Math.abs( me.x)
		 me.y = Math.abs( me.y)
end

public  sub 	Length() as variant ''funcion
		return Math.sqrt( me.x * me.x + me.y * me.y)
 '' TODO: posible funcion (revisar)

end

public  sub 	Normalize() as variant ''funcio as variant ''funcion
dim 		 length  as variant = me.Length()

		if (length < Number.MIN_VALUE)
			return 0.0
 '' TODO: posible funcion (revisar)

dim 		 invLength  as variant = 1.0 / length

		 me.x *= invLength
		 me.y *= invLength
		return length
 '' TODO: posible funcion (revisar)

end

public  sub 	IsValid() as variant ''funcion
		return b2Math.b2IsValid( me.x) && b2Math.b2IsValid( me.y)
 '' TODO: posible funcion (revisar)

	x: null
	y: null
end

public  sub Make (x_ as variant, y_ as variant) as variant ''funcion
		return new b2Vec2(x_, y_)
 '' TODO: posible funcion (revisar)

﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2Settings  as variant = Class.create()

b2Settings.prototype = 
	' //  Define your unit system here. The default system is
	' //  meters-kilograms-seconds. For the tuning to work well
	' //  your dynamic objects should be bigger than a pebble and smaller
	' //  than a house.
	' // static public const b2Settings.b2_lengthUnitsPerMeter = 1.0
	' //  Use this for pixels:
	' //  Global tuning constants based on MKS units.
	' //  Collision
	' //  Dynamics
	' //  Sleep
	' //  assert
end

public  sub 	initialize()
 
b2Settings.USHRT_MAX = 0x0000ffff
b2Settings.b2_pi = Math.PI
b2Settings.b2_massUnitsPerKilogram = 1.0
b2Settings.b2_timeUnitsPerSecond = 1.0
b2Settings.b2_lengthUnitsPerMeter = 30.0
b2Settings.b2_maxManifoldPoints = 2
b2Settings.b2_maxShapesPerBody = 64
b2Settings.b2_maxPolyVertices = 8
b2Settings.b2_maxProxies = 1024
b2Settings.b2_maxPairs = 8 * b2Settings.b2_maxProxies
b2Settings.b2_linearSlop = 0.005 * b2Settings.b2_lengthUnitsPerMeter
b2Settings.b2_angularSlop = 2.0 / 180.0 * b2Settings.b2_pi
b2Settings.b2_velocityThreshold = 1.0 * b2Settings.b2_lengthUnitsPerMeter / b2Settings.b2_timeUnitsPerSecond
b2Settings.b2_maxLinearCorrection = 0.2 * b2Settings.b2_lengthUnitsPerMeter
b2Settings.b2_maxAngularCorrection = 8.0 / 180.0 * b2Settings.b2_pi
b2Settings.b2_contactBaumgarte = 0.2
b2Settings.b2_timeToSleep = 0.5 * b2Settings.b2_timeUnitsPerSecond
b2Settings.b2_linearSleepTolerance = 0.01 * b2Settings.b2_lengthUnitsPerMeter / b2Settings.b2_timeUnitsPerSecond
b2Settings.b2_angularSleepTolerance = 2.0 / 180.0 / b2Settings.b2_timeUnitsPerSecond
end

public  sub b2Assert (a as variant)

		if (!a)
dim 			nullVec
 as variant
			nullVec.x++
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2CircleDef  as variant = Class.create()

inherits , b2ShapeDef
inherits 
end

public  sub 	initialize()

		' //  The constructor for b2ShapeDef
		 me.type = b2Shape.e_unknownShape
		 me.userData = null
		 me.localPosition = new b2Vec2(0.0, 0.0)
		 me.localRotation = 0.0
		 me.friction = 0.2
		 me.restitution = 0.0
		 me.density = 0.0
		 me.categoryBits = 0x0001
		 me.maskBits = 0xFFFF
		 me.groupIndex = 0
	
		' // 
		 me.type = b2Shape.e_circleShape
		 me.radius = 1.0
	radius: null)
' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  A convex polygon. The position of the polygon (m_position) is the
' //  position of the centroid. The vertices of the incoming polygon are pre-rotated
' //  according to the local rotation. The vertices are also shifted to be centered
' //  on the centroid. Since the local rotation is absorbed into the vertex
' //  coordinates, the polygon rotation is equal to the body rotation. However
' //  the polygon position is centered on the polygon centroid. This simplifies
' //  some collision algorithms.
dim  b2PolyShape  as variant = Class.create()

inherits , b2Shape
inherits 
end

public  sub 	TestPoint(p as variant) as variant ''funcio as variant ''funcion
		' // var pLocal = b2Math.b2MulTMV( me.m_R, b2Math.SubtractVV(p, me.m_position))
dim 		 pLocal  as variant = new b2Vec2()

		pLocal.SetV(p)
		pLocal.Subtract( me.m_position)
		pLocal.MulTM( me.m_R)
		for (var i = 0; i < me.m_vertexCount; ++i)
			' // var dot = b2Math.b2Dot( me.m_normals[i], b2Math.SubtractVV(pLocal, me.m_vertices[i]))
dim 			 tVec  as variant = new b2Vec2()

			tVec.SetV(pLocal)
			tVec.Subtract( me.m_vertices[i])
dim 			 dot  as variant = b2Math.b2Dot( me.m_normals[i], tVec)

			if (dot > 0.0)
			
				return false
 '' TODO: posible funcion (revisar)

			
		return true
 '' TODO: posible funcion (revisar)

	' // --------------- Internals Below -------------------
	' //  Temp vec for b2Shape.PolyCentroid
end

public  sub 	initialize(def as variant, body as variant, newOrigin as variant)

		' //  initialize instance variables for references
		 me.m_R = new b2Mat22()
		 me.m_position = new b2Vec2()
		' // 
		' //  The constructor for b2Shape
		 me.m_userData = def.userData
		 me.m_friction = def.friction
		 me.m_restitution = def.restitution
		 me.m_body = body
		 me.m_proxyId = b2Pair.b2_nullProxy
		 me.m_maxRadius = 0.0
		 me.m_categoryBits = def.categoryBits
		 me.m_maskBits = def.maskBits
		 me.m_groupIndex = def.groupIndex
		' // 
		' //  initialize instance variables for references
		 me.syncAABB = new b2AABB()
		 me.syncMat = new b2Mat22()
		 me.m_localCentroid = new b2Vec2()
		 me.m_localOBB = new b2OBB()
		' // 
		' // super(def, body)
dim 		 i  as variant = 0

dim 		hX
 as variant
dim 		hY
 as variant
dim 		tVec
 as variant
dim 		 aabb  as variant = new b2AABB()

		' //  Vertices
		 me.m_vertices = new Array(b2Settings.b2_maxPolyVertices)
		 me.m_coreVertices = new Array(b2Settings.b2_maxPolyVertices)
		' // for (i = 0; i < b2Settings.b2_maxPolyVertices; i++)
		' // 	 me.m_vertices[i] = new b2Vec2()
		' //  Normals
		 me.m_normals = new Array(b2Settings.b2_maxPolyVertices)
		' // for (i = 0; i < b2Settings.b2_maxPolyVertices; i++)
		' // 	 me.m_normals[i] = new b2Vec2()
		' // b2Settings.b2Assert(def.type == b2Shape.e_boxShape || def.type == b2Shape.e_polyShape)
		 me.m_type = b2Shape.e_polyShape
dim 		 localR  as variant = new b2Mat22(def.localRotation)

		' //  Get the vertices transformed into the body frame.
		if (def.type == b2Shape.e_boxShape)
			' // me.m_localCentroid = def.localPosition - newOrigin
			 me.m_localCentroid.x = def.localPosition.x - newOrigin.x
			 me.m_localCentroid.y = def.localPosition.y - newOrigin.y
dim 			 box  as variant = def

			 me.m_vertexCount = 4
			hX = box.extents.x
			hY = box.extents.y
			' // hc.x = b2Max(0.0f, h.x - 2.0f * b2_linearSlop)
dim 			 hcX  as variant = Math.max(0.0, hX - 2.0 * b2Settings.b2_linearSlop)

			' // hc.y = b2Max(0.0f, h.y - 2.0f * b2_linearSlop)
dim 			 hcY  as variant = Math.max(0.0, hY - 2.0 * b2Settings.b2_linearSlop)

			' // me.m_vertices[0] = b2Mul(localR, b2Vec2(h.x, h.y))
			tVec = me.m_vertices[0] = new b2Vec2()
			tVec.x = localR.col1.x * hX + localR.col2.x * hY
			tVec.y = localR.col1.y * hX + localR.col2.y * hY
			' // me.m_vertices[1] = b2Mul(localR, b2Vec2(-h.x, h.y))
			tVec = me.m_vertices[1] = new b2Vec2()
			tVec.x = localR.col1.x * -hX + localR.col2.x * hY
			tVec.y = localR.col1.y * -hX + localR.col2.y * hY
			' // me.m_vertices[2] = b2Mul(localR, b2Vec2(-h.x, -h.y))
			tVec = me.m_vertices[2] = new b2Vec2()
			tVec.x = localR.col1.x * -hX + localR.col2.x * -hY
			tVec.y = localR.col1.y * -hX + localR.col2.y * -hY
			' // me.m_vertices[3] = b2Mul(localR, b2Vec2(h.x, -h.y))
			tVec = me.m_vertices[3] = new b2Vec2()
			tVec.x = localR.col1.x * hX + localR.col2.x * -hY
			tVec.y = localR.col1.y * hX + localR.col2.y * -hY
			' // me.m_coreVertices[0] = b2Mul(localR, b2Vec2(hc.x, hc.y))
			tVec = me.m_coreVertices[0] = new b2Vec2()
			tVec.x = localR.col1.x * hcX + localR.col2.x * hcY
			tVec.y = localR.col1.y * hcX + localR.col2.y * hcY
			' // me.m_coreVertices[1] = b2Mul(localR, b2Vec2(-hc.x, hc.y))
			tVec = me.m_coreVertices[1] = new b2Vec2()
			tVec.x = localR.col1.x * -hcX + localR.col2.x * hcY
			tVec.y = localR.col1.y * -hcX + localR.col2.y * hcY
			' // me.m_coreVertices[2] = b2Mul(localR, b2Vec2(-hc.x, -hc.y))
			tVec = me.m_coreVertices[2] = new b2Vec2()
			tVec.x = localR.col1.x * -hcX + localR.col2.x * -hcY
			tVec.y = localR.col1.y * -hcX + localR.col2.y * -hcY
			' // me.m_coreVertices[3] = b2Mul(localR, b2Vec2(hc.x, -hc.y))
			tVec = me.m_coreVertices[3] = new b2Vec2()
			tVec.x = localR.col1.x * hcX + localR.col2.x * -hcY
			tVec.y = localR.col1.y * hcX + localR.col2.y * -hcY
		else
dim 			 poly  as variant = def

			 me.m_vertexCount = poly.vertexCount
			' // b2Settings.b2Assert(3 <= me.m_vertexCount && me.m_vertexCount <= b2Settings.b2_maxPolyVertices)
			' // b2Vec2 centroid = b2Shape.PolyCentroid(poly->vertices, poly->vertexCount)
			b2Shape.PolyCentroid(poly.vertices, poly.vertexCount, b2PolyShape.tempVec)
dim 			 centroidX  as variant = b2PolyShape.tempVec.x

dim 			 centroidY  as variant = b2PolyShape.tempVec.y

			' // me.m_localCentroid = def->localPosition + b2Mul(localR, centroid) - newOrigin
			 me.m_localCentroid.x = def.localPosition.x + (localR.col1.x * centroidX + localR.col2.x * centroidY) - newOrigin.x
			 me.m_localCentroid.y = def.localPosition.y + (localR.col1.y * centroidX + localR.col2.y * centroidY) - newOrigin.y
			for (i = 0; i < me.m_vertexCount; ++i)
			
				 me.m_vertices[i] = new b2Vec2()
				 me.m_coreVertices[i] = new b2Vec2()
				' // me.m_vertices[i] = b2Mul(localR, poly->vertices[i] - centroid)
				hX = poly.vertices[i].x - centroidX
				hY = poly.vertices[i].y - centroidY
				 me.m_vertices[i].x = localR.col1.x * hX + localR.col2.x * hY
				 me.m_vertices[i].y = localR.col1.y * hX + localR.col2.y * hY
				' // b2Vec2 u = me.m_vertices[i]
dim 				 uX  as variant = me.m_vertices[i].x

dim 				 uY  as variant = me.m_vertices[i].y

				' // float32 length = u.Length()
dim 				 length  as variant = Math.sqrt(uX*uX + uY*uY)

				if (length > Number.MIN_VALUE)
				
					uX *= 1.0 / length
					uY *= 1.0 / length
				
				' // me.m_coreVertices[i] = me.m_vertices[i] - 2.0f * b2_linearSlop * u
				 me.m_coreVertices[i].x = me.m_vertices[i].x - 2.0 * b2Settings.b2_linearSlop * uX
				 me.m_coreVertices[i].y = me.m_vertices[i].y - 2.0 * b2Settings.b2_linearSlop * uY
			
		' //  Compute bounding box. TODO_ERIN optimize OBB
		' // var minVertex = new b2Vec2(Number.MAX_VALUE, Number.MAX_VALUE)
dim 		 minVertexX  as variant = Number.MAX_VALUE

dim 		 minVertexY  as variant = Number.MAX_VALUE

dim 		 maxVertexX  as variant = -Number.MAX_VALUE

dim 		 maxVertexY  as variant = -Number.MAX_VALUE

		 me.m_maxRadius = 0.0
		for (i = 0; i < me.m_vertexCount; ++i)
dim 			 v  as variant = me.m_vertices[i]

			' // minVertex = b2Math.b2MinV(minVertex, me.m_vertices[i])
			minVertexX = Math.min(minVertexX, v.x)
			minVertexY = Math.min(minVertexY, v.y)
			' // maxVertex = b2Math.b2MaxV(maxVertex, me.m_vertices[i])
			maxVertexX = Math.max(maxVertexX, v.x)
			maxVertexY = Math.max(maxVertexY, v.y)
			' // me.m_maxRadius = b2Max( me.m_maxRadius, v.Length())
			 me.m_maxRadius = Math.max( me.m_maxRadius, v.Length())
		 me.m_localOBB.R.SetIdentity()
		' // me.m_localOBB.center = 0.5 * (minVertex + maxVertex)
		 me.m_localOBB.center.Set((minVertexX + maxVertexX) * 0.5, (minVertexY + maxVertexY) * 0.5)
		' // me.m_localOBB.extents = 0.5 * (maxVertex - minVertex)
		 me.m_localOBB.extents.Set((maxVertexX - minVertexX) * 0.5, (maxVertexY - minVertexY) * 0.5)
		' //  Compute the edge normals and next index map.
dim 		 i1  as variant = 0

dim 		 i2  as variant = 0

		for (i = 0; i < me.m_vertexCount; ++i)
			 me.m_normals[i] =  new b2Vec2()
			i1 = i
			i2 = i + 1 < me.m_vertexCount ? i + 1 : 0
			' // b2Vec2 edge = me.m_vertices[i2] - me.m_vertices[i1]
			' // var edgeX = me.m_vertices[i2].x - me.m_vertices[i1].x
			' // var edgeY = me.m_vertices[i2].y - me.m_vertices[i1].y
			' // me.m_normals[i] = b2Cross(edge, 1.0f)
			 me.m_normals[i].x = me.m_vertices[i2].y - me.m_vertices[i1].y
			 me.m_normals[i].y = -( me.m_vertices[i2].x - me.m_vertices[i1].x)
			 me.m_normals[i].Normalize()
		' //  Ensure the polygon in convex. TODO_ERIN compute convex hull.
		for (i = 0; i < me.m_vertexCount; ++i)
			i1 = i
			i2 = i + 1 < me.m_vertexCount ? i + 1 : 0
			' // b2Settings.b2Assert(b2Math.b2CrossVV( me.m_normals[i1], me.m_normals[i2]) > Number.MIN_VALUE)
		 me.m_R.SetM( me.m_body.m_R)
		' // me.m_position.SetV( me.m_body.m_position  + b2Mul( me.m_body-> me.m_R, me.m_localCentroid) )
		 me.m_position.x = me.m_body.m_position.x + ( me.m_R.col1.x * me.m_localCentroid.x + me.m_R.col2.x * me.m_localCentroid.y)
		 me.m_position.y = me.m_body.m_position.y + ( me.m_R.col1.y * me.m_localCentroid.x + me.m_R.col2.y * me.m_localCentroid.y)
		' // var R = b2Math.b2MulMM( me.m_R, me.m_localOBB.R)
			' // R.col1 = b2MulMV( me.m_R, me.m_localOBB.R.col1)
			b2PolyShape.tAbsR.col1.x = me.m_R.col1.x * me.m_localOBB.R.col1.x + me.m_R.col2.x * me.m_localOBB.R.col1.y
			b2PolyShape.tAbsR.col1.y = me.m_R.col1.y * me.m_localOBB.R.col1.x + me.m_R.col2.y * me.m_localOBB.R.col1.y
			' // R.col2 = b2MulMV( me.m_R, me.m_localOBB.R.col2)
			b2PolyShape.tAbsR.col2.x = me.m_R.col1.x * me.m_localOBB.R.col2.x + me.m_R.col2.x * me.m_localOBB.R.col2.y
			b2PolyShape.tAbsR.col2.y = me.m_R.col1.y * me.m_localOBB.R.col2.x + me.m_R.col2.y * me.m_localOBB.R.col2.y
		' // var absR = b2Math.b2AbsM(R)
		b2PolyShape.tAbsR.Abs()
		' // h = b2Math.b2MulMV(b2PolyShape.tAbsR, me.m_localOBB.extents)
		hX = b2PolyShape.tAbsR.col1.x * me.m_localOBB.extents.x + b2PolyShape.tAbsR.col2.x * me.m_localOBB.extents.y
		hY = b2PolyShape.tAbsR.col1.y * me.m_localOBB.extents.x + b2PolyShape.tAbsR.col2.y * me.m_localOBB.extents.y
		' // var position = me.m_position + b2Mul( me.m_R, me.m_localOBB.center)
dim 		 positionX  as variant = me.m_position.x + ( me.m_R.col1.x * me.m_localOBB.center.x + me.m_R.col2.x * me.m_localOBB.center.y)

dim 		 positionY  as variant = me.m_position.y + ( me.m_R.col1.y * me.m_localOBB.center.x + me.m_R.col2.y * me.m_localOBB.center.y)

		' // aabb.minVertex = b2Math.SubtractVV( me.m_position, h)
		aabb.minVertex.x = positionX - hX
		aabb.minVertex.y = positionY - hY
		' // aabb.maxVertex = b2Math.AddVV( me.m_position, h)
		aabb.maxVertex.x = positionX + hX
		aabb.maxVertex.y = positionY + hY
dim 		 broadPhase  as variant = me.m_body.m_world.m_broadPhase

		if (broadPhase.InRange(aabb))
			 me.m_proxyId = broadPhase.CreateProxy(aabb, this)
		else
			 me.m_proxyId = b2Pair.b2_nullProxy
		if ( me.m_proxyId == b2Pair.b2_nullProxy)
			 me.m_body.Freeze()
	' //  Temp AABB for Synch function
Public B: new b2AABB(), as new 2AABB(),
Public t: new b2Mat22(), as new 2Mat22(),
end

public  sub 	Synchronize(position1 as variant, R1 as variant, position2 as variant, R2 as variant) as variant ''funcion
		' //  The body transform is copied for convenience.
		 me.m_R.SetM(R2)
		' // me.m_position = me.m_body-> me.m_position + b2Mul( me.m_body-> me.m_R, me.m_localCentroid)
		 me.m_position.x = me.m_body.m_position.x + (R2.col1.x * me.m_localCentroid.x + R2.col2.x * me.m_localCentroid.y)
		 me.m_position.y = me.m_body.m_position.y + (R2.col1.y * me.m_localCentroid.x + R2.col2.y * me.m_localCentroid.y)
		if ( me.m_proxyId == b2Pair.b2_nullProxy)
			return
 '' TODO: posible funcion (revisar)

		' // b2AABB aabb1, aabb2
dim 		hX
 as variant
dim 		hY
 as variant
		' // b2Mat22 obbR = b2Mul(R1, me.m_localOBB.R)
dim 			 v1  as variant = R1.col1

dim 			 v2  as variant = R1.col2

dim 			 v3  as variant = me.m_localOBB.R.col1

dim 			 v4  as variant = me.m_localOBB.R.col2

			' // me.syncMat.col1 = b2MulMV(R1, me.m_localOBB.R.col1)
			 me.syncMat.col1.x = v1.x * v3.x + v2.x * v3.y
			 me.syncMat.col1.y = v1.y * v3.x + v2.y * v3.y
			' // me.syncMat.col2 = b2MulMV(R1, me.m_localOBB.R.col2)
			 me.syncMat.col2.x = v1.x * v4.x + v2.x * v4.y
			 me.syncMat.col2.y = v1.y * v4.x + v2.y * v4.y
		' // b2Mat22 absR = b2Abs(obbR)
		 me.syncMat.Abs()
		' // b2Vec2 center = position1 + b2Mul(R1, me.m_localCentroid + me.m_localOBB.center)
		hX = me.m_localCentroid.x + me.m_localOBB.center.x
		hY = me.m_localCentroid.y + me.m_localOBB.center.y
dim 		 centerX  as variant = position1.x + (R1.col1.x * hX + R1.col2.x * hY)

dim 		 centerY  as variant = position1.y + (R1.col1.y * hX + R1.col2.y * hY)

		' // b2Vec2 h = b2Mul( me.syncMat, me.m_localOBB.extents)
		hX = me.syncMat.col1.x * me.m_localOBB.extents.x + me.syncMat.col2.x * me.m_localOBB.extents.y
		hY = me.syncMat.col1.y * me.m_localOBB.extents.x + me.syncMat.col2.y * me.m_localOBB.extents.y
		' // aabb1.minVertex = center - h
		 me.syncAABB.minVertex.x = centerX - hX
		 me.syncAABB.minVertex.y = centerY - hY
		' // aabb1.maxVertex = center + h
		 me.syncAABB.maxVertex.x = centerX + hX
		 me.syncAABB.maxVertex.y = centerY + hY
		' // b2Mat22 obbR = b2Mul(R2, me.m_localOBB.R)
			v1 = R2.col1
			v2 = R2.col2
			v3 = me.m_localOBB.R.col1
			v4 = me.m_localOBB.R.col2
			' // me.syncMat.col1 = b2MulMV(R1, me.m_localOBB.R.col1)
			 me.syncMat.col1.x = v1.x * v3.x + v2.x * v3.y
			 me.syncMat.col1.y = v1.y * v3.x + v2.y * v3.y
			' // me.syncMat.col2 = b2MulMV(R1, me.m_localOBB.R.col2)
			 me.syncMat.col2.x = v1.x * v4.x + v2.x * v4.y
			 me.syncMat.col2.y = v1.y * v4.x + v2.y * v4.y
		' // b2Mat22 absR = b2Abs(obbR)
		 me.syncMat.Abs()
		' // b2Vec2 center = position2 + b2Mul(R2, me.m_localCentroid + me.m_localOBB.center)
		hX = me.m_localCentroid.x + me.m_localOBB.center.x
		hY = me.m_localCentroid.y + me.m_localOBB.center.y
		centerX = position2.x + (R2.col1.x * hX + R2.col2.x * hY)
		centerY = position2.y + (R2.col1.y * hX + R2.col2.y * hY)
		' // b2Vec2 h = b2Mul(absR, me.m_localOBB.extents)
		hX = me.syncMat.col1.x * me.m_localOBB.extents.x + me.syncMat.col2.x * me.m_localOBB.extents.y
		hY = me.syncMat.col1.y * me.m_localOBB.extents.x + me.syncMat.col2.y * me.m_localOBB.extents.y
		' // aabb2.minVertex = center - h
		' // aabb2.maxVertex = center + h
		' // aabb.minVertex = b2Min(aabb1.minVertex, aabb2.minVertex)
		 me.syncAABB.minVertex.x = Math.min( me.syncAABB.minVertex.x, centerX - hX)
		 me.syncAABB.minVertex.y = Math.min( me.syncAABB.minVertex.y, centerY - hY)
		' // aabb.maxVertex = b2Max(aabb1.maxVertex, aabb2.maxVertex)
		 me.syncAABB.maxVertex.x = Math.max( me.syncAABB.maxVertex.x, centerX + hX)
		 me.syncAABB.maxVertex.y = Math.max( me.syncAABB.maxVertex.y, centerY + hY)
dim 		 broadPhase  as variant = me.m_body.m_world.m_broadPhase

		if (broadPhase.InRange( me.syncAABB))
			broadPhase.MoveProxy( me.m_proxyId, me.syncAABB)
		else
			 me.m_body.Freeze()
end

public  sub 	QuickSync(position as variant, R as variant)

		' // me.m_R = R
		 me.m_R.SetM(R)
		' // me.m_position = position + b2Mul(R, me.m_localCentroid)
		 me.m_position.x = position.x + (R.col1.x * me.m_localCentroid.x + R.col2.x * me.m_localCentroid.y)
		 me.m_position.y = position.y + (R.col1.y * me.m_localCentroid.x + R.col2.y * me.m_localCentroid.y)
end

public  sub 	ResetProxy(broadPhase as variant) as variant ''funcion
		if ( me.m_proxyId == b2Pair.b2_nullProxy)
			return
 '' TODO: posible funcion (revisar)

dim 		 proxy  as variant = broadPhase.GetProxy( me.m_proxyId)

		broadPhase.DestroyProxy( me.m_proxyId)
		proxy = null
dim 		 R  as variant = b2Math.b2MulMM( me.m_R, me.m_localOBB.R)

dim 		 absR  as variant = b2Math.b2AbsM(R)

dim 		 h  as variant = b2Math.b2MulMV(absR, me.m_localOBB.extents)

		' // var position = me.m_position + b2Mul( me.m_R, me.m_localOBB.center)
dim 		 position  as variant = b2Math.b2MulMV( me.m_R, me.m_localOBB.center)

		position.Add( me.m_position)
dim 		 aabb  as variant = new b2AABB()

		' // aabb.minVertex = position - h
		aabb.minVertex.SetV(position)
		aabb.minVertex.Subtract(h)
		' // aabb.maxVertex = position + h
		aabb.maxVertex.SetV(position)
		aabb.maxVertex.Add(h)
		if (broadPhase.InRange(aabb))
			 me.m_proxyId = broadPhase.CreateProxy(aabb, this)
		else
			 me.m_proxyId = b2Pair.b2_nullProxy
		if ( me.m_proxyId == b2Pair.b2_nullProxy)
			 me.m_body.Freeze()
end

public  sub 	Support(dX as variant, dY as variant, out as variant) as variant ''funcion
		' // b2Vec2 dLocal = b2MulT( me.m_R, d)
dim 		 dLocalX  as variant = (dX* me.m_R.col1.x + dY* me.m_R.col1.y)

dim 		 dLocalY  as variant = (dX* me.m_R.col2.x + dY* me.m_R.col2.y)

dim 		 bestIndex  as variant = 0

		' // float32 bestValue = b2Dot( me.m_vertices[0], dLocal)
dim 		 bestValue  as variant = ( me.m_coreVertices[0].x * dLocalX + me.m_coreVertices[0].y * dLocalY)

		for (var i = 1; i < me.m_vertexCount; ++i)
			' // float32 value = b2Dot( me.m_vertices[i], dLocal)
dim 			 value  as variant = ( me.m_coreVertices[i].x * dLocalX + me.m_coreVertices[i].y * dLocalY)

			if (value > bestValue)
			
				bestIndex = i
				bestValue = value
			
		' // return me.m_position + b2Mul( me.m_R, me.m_vertices[bestIndex])
 '' TODO: posible funcion (revisar)

		out.Set(	 me.m_position.x + ( me.m_R.col1.x * me.m_coreVertices[bestIndex].x + me.m_R.col2.x * me.m_coreVertices[bestIndex].y)
					 me.m_position.y + ( me.m_R.col1.y * me.m_coreVertices[bestIndex].x + me.m_R.col2.y * me.m_coreVertices[bestIndex].y))
	' //  Local position of the shape centroid in parent body frame.
Public d: new b2Vec2(), as new 2Vec2(),
	' //  Local position oriented bounding box. The OBB center is relative to
	' //  shape centroid.
Public B: new b2OBB(), as new 2OBB(),
	m_vertices: null
	m_coreVertices: null
	m_vertexCount: 0
	m_normals: null)
b2PolyShape.tempVec = new b2Vec2()
b2PolyShape.tAbsR = new b2Mat22()
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2PolyDef  as variant = Class.create()

inherits , b2ShapeDef
inherits 
end

public  sub 	initialize()

		' //  The constructor for b2ShapeDef
		 me.type = b2Shape.e_unknownShape
		 me.userData = null
		 me.localPosition = new b2Vec2(0.0, 0.0)
		 me.localRotation = 0.0
		 me.friction = 0.2
		 me.restitution = 0.0
		 me.density = 0.0
		 me.categoryBits = 0x0001
		 me.maskBits = 0xFFFF
		 me.groupIndex = 0
	
		' // 
		' //  initialize instance variables for references
		 me.vertices = new Array(b2Settings.b2_maxPolyVertices)
		' // 
		 me.type = b2Shape.e_polyShape
		 me.vertexCount = 0
		for (var i = 0; i < b2Settings.b2_maxPolyVertices; i++)
			 me.vertices[i] = new b2Vec2()
Public s: new Array(b2Settings.b2_maxPolyVertices), as new rray(b2Settings.b2_maxPolyVertices),
	vertexCount: 0)
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2BoxDef  as variant = Class.create()

inherits , b2ShapeDef
inherits 
end

public  sub 	initialize()

		' //  The constructor for b2ShapeDef
		 me.type = b2Shape.e_unknownShape
		 me.userData = null
		 me.localPosition = new b2Vec2(0.0, 0.0)
		 me.localRotation = 0.0
		 me.friction = 0.2
		 me.restitution = 0.0
		 me.density = 0.0
		 me.categoryBits = 0x0001
		 me.maskBits = 0xFFFF
		 me.groupIndex = 0
	
		' // 
		 me.type = b2Shape.e_boxShape
		 me.extents = new b2Vec2(1.0, 1.0)
	extents: null)
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2ShapeDef  as variant = Class.create()

b2ShapeDef.prototype = 
end

public  sub 	initialize()

		 me.type = b2Shape.e_unknownShape
		 me.userData = null
		 me.localPosition = new b2Vec2(0.0, 0.0)
		 me.localRotation = 0.0
		 me.friction = 0.2
		 me.restitution = 0.0
		 me.density = 0.0
		 me.categoryBits = 0x0001
		 me.maskBits = 0xFFFF
		 me.groupIndex = 0
	' // virtual ~b2ShapeDef() 
end

public  sub 	ComputeMass(massData as variant)

		massData.center = new b2Vec2(0.0, 0.0)
		if ( me.density == 0.0)
			massData.mass = 0.0
			massData.center.Set(0.0, 0.0)
			massData.I = 0.0
		switch ( me.type)
		case b2Shape.e_circleShape:
			
dim 				 circle  as variant = this

				massData.mass = me.density * b2Settings.b2_pi * circle.radius * circle.radius
				massData.center.Set(0.0, 0.0)
				massData.I = 0.5 * (massData.mass) * circle.radius * circle.radius
			
			break
		case b2Shape.e_boxShape:
			
dim 				 box  as variant = this

				massData.mass = 4.0 * me.density * box.extents.x * box.extents.y
				massData.center.Set(0.0, 0.0)
				massData.I = massData.mass / 3.0 * b2Math.b2Dot(box.extents, box.extents)
			
			break
		case b2Shape.e_polyShape:
			
dim 				 poly  as variant = this

				b2Shape.PolyMass(massData, poly.vertices, poly.vertexCount, me.density)
			
			break
		default:
			massData.mass = 0.0
			massData.center.Set(0.0, 0.0)
			massData.I = 0.0
			break
	type: 0
	userData: null
	localPosition: null
	localRotation: null
	friction: null
	restitution: null
	density: null
	' //  The collision category bits. Normally you would just set one bit.
	categoryBits: 0
	' //  The collision mask bits. This states the categories that this
	' //  shape would accept for collision.
	maskBits: 0
	' //  Collision groups allow a certain group of objects to never collide (negative)
	' //  or always collide (positive). Zero means no collision group. Non-zero group
	' //  filtering always wins against the mask bits.
	groupIndex: 0
' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  Shapes are created automatically when a body is created.
' //  Client code does not normally interact with shapes.
dim  b2Shape  as variant = Class.create()

b2Shape.prototype = 
end

public  sub 	TestPoint(p as variant)
return false '' TODO: posible funcion (revisar)

end

public  sub 	GetUserData()
return me.m_userData
 '' TODO: posible funcion (revisar)

end

public  sub 	GetType() as variant ''funcion
		return me.m_type
 '' TODO: posible funcion (revisar)

	' //  Get the parent body of this shape.
end

public  sub 	GetBody() as variant ''funcion
		return me.m_body
 '' TODO: posible funcion (revisar)

end

public  sub 	GetPosition() as variant ''funcion
		return me.m_position
 '' TODO: posible funcion (revisar)

end

public  sub 	GetRotationMatrix() as variant ''funcion
		return me.m_R
 '' TODO: posible funcion (revisar)

	' //  Remove and then add proxy from the broad-phase.
	' //  This is used to refresh the collision filters.
end

public  sub 	ResetProxy(broadPhase as variant)

	' //  Get the next shape in the parent body's shape list.
end

public  sub 	GetNext() as variant ''funcion
		return me.m_next
 '' TODO: posible funcion (revisar)

	' // --------------- Internals Below -------------------
end

public  sub 	initialize(def as variant, body as variant)

		' //  initialize instance variables for references
		 me.m_R = new b2Mat22()
		 me.m_position = new b2Vec2()
		' // 
		 me.m_userData = def.userData
		 me.m_friction = def.friction
		 me.m_restitution = def.restitution
		 me.m_body = body
		 me.m_proxyId = b2Pair.b2_nullProxy
		 me.m_maxRadius = 0.0
		 me.m_categoryBits = def.categoryBits
		 me.m_maskBits = def.maskBits
		 me.m_groupIndex = def.groupIndex
	' //  Internal use only. Do not call.
	' // b2Shape::~b2Shape()
	' // 
	' // 	 me.m_body->m_world->m_broadPhase-> me.DestroyProxy( me.m_proxyId)
	' // 
end

public  sub 	DestroyProxy()

		if ( me.m_proxyId != b2Pair.b2_nullProxy)
			 me.m_body.m_world.m_broadPhase.DestroyProxy( me.m_proxyId)
			 me.m_proxyId = b2Pair.b2_nullProxy
	' //  Internal use only. Do not call.
end

public  sub 	Synchronize(position1 as variant, R1 as variant, position2 as variant, R2 as variant)

end

public  sub 	QuickSync(position as variant, R as variant)

end

public  sub 	Support(dX as variant, dY as variant, out as variant)

end

public  sub 	GetMaxRadius() as variant ''funcion
		return me.m_maxRadius
 '' TODO: posible funcion (revisar)

	m_next: null
Public R: new b2Mat22(), as new 2Mat22(),
Public n: new b2Vec2(), as new 2Vec2(),
	m_type: 0
	m_userData: null
	m_body: null
	m_friction: null
	m_restitution: null
	m_maxRadius: null
	m_proxyId: 0
	m_categoryBits: 0
	m_maskBits: 0
	m_groupIndex: 0
	' //  b2ShapeType
end

public  sub Create (def as variant, body as variant, center as variant) as variant ''funcio as variant ''funcio as variant ''funcion
		switch (def.type)
		case b2Shape.e_circleShape:
			
				' // void* mem = body->m_world->m_blockAllocator.Allocate(sizeof(b2CircleShape))
				return new b2CircleShape(def, body, center)
 '' TODO: posible funcion (revisar)

			
		case b2Shape.e_boxShape:
		case b2Shape.e_polyShape:
			
				' // void* mem = body->m_world->m_blockAllocator.Allocate(sizeof(b2PolyShape))
				return new b2PolyShape(def, body, center)
 '' TODO: posible funcion (revisar)

			
		' // b2Settings.b2Assert(false)
		return null
 '' TODO: posible funcion (revisar)

end

public  sub Destroy (shape as variant)

		' /* b2BlockAllocator& allocator = shape->m_body->m_world->m_blockAllocator
		switch (shape.m_type)
		case b2Shape.e_circleShape:
			shape->~b2Shape()
			allocator.Free(shape, sizeof(b2CircleShape))
			break
		case b2Shape.e_polyShape:
			shape->~b2Shape()
			allocator.Free(shape, sizeof(b2PolyShape))
			break
		default:
			b2Assert(false)
		shape = NULL
*/
		' //  FROM DESTRUCTOR
		if (shape.m_proxyId != b2Pair.b2_nullProxy)
			shape.m_body.m_world.m_broadPhase.DestroyProxy(shape.m_proxyId)
b2Shape.e_unknownShape = -1
b2Shape.e_circleShape = 0
b2Shape.e_boxShape = 1
b2Shape.e_polyShape = 2
b2Shape.e_meshShape = 3
b2Shape.e_shapeTypeCount = 4
end

public  sub PolyMass (massData as variant, vs as variant, count as variant, rho as variant)

		' // b2Settings.b2Assert(count >= 3)
		' // var center = new b2Vec2(0.0, 0.0)
dim 		 center  as variant = new b2Vec2()

		center.SetZero()
dim 		 area  as variant = 0.0

dim 		 I  as variant = 0.0

		' //  pRef is the reference point for forming triangles.
		' //  It's location doesn't change the result (except for rounding error).
dim 		 pRef  as variant = new b2Vec2(0.0, 0.0)

dim 		 inv3  as variant = 1.0 / 3.0

		for (var i = 0; i < count; ++i)
			' //  Triangle vertices.
dim 			 p1  as variant = pRef

dim 			 p2  as variant = vs[i]

dim 			 p3  as variant = i + 1 < count ? vs[i+1] : vs[0]

dim 			 e1  as variant = b2Math.SubtractVV(p2, p1)

dim 			 e2  as variant = b2Math.SubtractVV(p3, p1)

dim 			 D  as variant = b2Math.b2CrossVV(e1, e2)

dim 			 triangleArea  as variant = 0.5 * D

			area += triangleArea
			' //  Area weighted centroid
			' //  center += triangleArea * inv3 * (p1 + p2 + p3)
dim 			 tVec  as variant = new b2Vec2()

			tVec.SetV(p1)
			tVec.Add(p2)
			tVec.Add(p3)
			tVec.Multiply(inv3*triangleArea)
			center.Add(tVec)
dim 			 px  as variant = p1.x

dim 			 py  as variant = p1.y

dim 			 ex1  as variant = e1.x

dim 			 ey1  as variant = e1.y

dim 			 ex2  as variant = e2.x

dim 			 ey2  as variant = e2.y

dim 			 intx2  as variant = inv3 * (0.25 * (ex1*ex1 + ex2*ex1 + ex2*ex2) + (px*ex1 + px*ex2)) + 0.5*px*px

dim 			 inty2  as variant = inv3 * (0.25 * (ey1*ey1 + ey2*ey1 + ey2*ey2) + (py*ey1 + py*ey2)) + 0.5*py*py

			I += D * (intx2 + inty2)
		' //  Total mass
		massData.mass = rho * area
		' //  Center of mass
		' // b2Settings.b2Assert(area > Number.MIN_VALUE)
		center.Multiply( 1.0 / area )
		massData.center = center
		' //  Inertia tensor relative to the center.
		I = rho * (I - area * b2Math.b2Dot(center, center))
		massData.I = I
end

public  sub PolyCentroid (vs as variant, count as variant, out as variant) as variant ''funcio as variant ''funcion
		' // b2Settings.b2Assert(count >= 3)
		' // b2Vec2 c
 c.Set(0.0f, 0.0f)
dim 		 cX  as variant = 0.0

dim 		 cY  as variant = 0.0

		' // float32 area = 0.0f
dim 		 area  as variant = 0.0

		' //  pRef is the reference point for forming triangles.
		' //  It's location doesn't change the result (except for rounding error).
		' // b2Vec2 pRef(0.0f, 0.0f)
dim 		 pRefX  as variant = 0.0

dim 		 pRefY  as variant = 0.0

	' /* 
		' //  This code would put the reference point inside the polygon.
		for (var i = 0; i < count; ++i)
			' // pRef += vs[i]
			pRef.x += vs[i].x
			pRef.y += vs[i].y
		pRef.x *= 1.0 / count
		pRef.y *= 1.0 / count
' 	*/
		' // const float32 inv3 = 1.0f / 3.0f
dim 		 inv3  as variant = 1.0 / 3.0

		for (var i = 0; i < count; ++i)
			' //  Triangle vertices.
			' // b2Vec2 p1 = pRef
dim 			 p1X  as variant = pRefX

dim 			 p1Y  as variant = pRefY

			' // b2Vec2 p2 = vs[i]
dim 			 p2X  as variant = vs[i].x

dim 			 p2Y  as variant = vs[i].y

			' // b2Vec2 p3 = i + 1 < count ? vs[i+1] : vs[0]
dim 			 p3X  as variant = i + 1 < count ? vs[i+1].x : vs[0].x

dim 			 p3Y  as variant = i + 1 < count ? vs[i+1].y : vs[0].y

			' // b2Vec2 e1 = p2 - p1
dim 			 e1X  as variant = p2X - p1X

dim 			 e1Y  as variant = p2Y - p1Y

			' // b2Vec2 e2 = p3 - p1
dim 			 e2X  as variant = p3X - p1X

dim 			 e2Y  as variant = p3Y - p1Y

			' // float32 D = b2Cross(e1, e2)
dim 			 D  as variant = (e1X * e2Y - e1Y * e2X)

			' // float32 triangleArea = 0.5f * D
dim 			 triangleArea  as variant = 0.5 * D

			area += triangleArea
			' //  Area weighted centroid
			' // c += triangleArea * inv3 * (p1 + p2 + p3)
			cX += triangleArea * inv3 * (p1X + p2X + p3X)
			cY += triangleArea * inv3 * (p1Y + p2Y + p3Y)
		' //  Centroid
		' // b2Settings.b2Assert(area > Number.MIN_VALUE)
		cX *= 1.0 / area
		cY *= 1.0 / area
		' //  Replace return with 'out' vector '' TODO: posible funcion (revisar)

		' // return c
 '' TODO: posible funcion (revisar)

		out.Set(cX, cY)
' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2CircleShape  as variant = Class.create()

inherits , b2Shape
inherits 
end

public  sub 	TestPoint(p as variant) as variant ''funcion
		' // var d = b2Math.SubtractVV(p, me.m_position)
dim 		 d  as variant = new b2Vec2()

		d.SetV(p)
		d.Subtract( me.m_position)
		return b2Math.b2Dot(d, d) <= me.m_radius * me.m_radius
 '' TODO: posible funcion (revisar)

	' // --------------- Internals Below -------------------
end

public  sub 	initialize(def as variant, body as variant, localCenter as variant)

		' //  initialize instance variables for references
		 me.m_R = new b2Mat22()
		 me.m_position = new b2Vec2()
		' // 
		' //  The constructor for b2Shape
		 me.m_userData = def.userData
		 me.m_friction = def.friction
		 me.m_restitution = def.restitution
		 me.m_body = body
		 me.m_proxyId = b2Pair.b2_nullProxy
		 me.m_maxRadius = 0.0
		 me.m_categoryBits = def.categoryBits
		 me.m_maskBits = def.maskBits
		 me.m_groupIndex = def.groupIndex
		' // 
		' //  initialize instance variables for references
		 me.m_localPosition = new b2Vec2()
		' // 
		' // super(def, body)
		' // b2Settings.b2Assert(def.type == b2Shape.e_circleShape)
dim 		 circle  as variant = def

		' // me.m_localPosition = def.localPosition - localCenter
		 me.m_localPosition.Set(def.localPosition.x - localCenter.x, def.localPosition.y - localCenter.y)
		 me.m_type = b2Shape.e_circleShape
		 me.m_radius = circle.radius
		 me.m_R.SetM( me.m_body.m_R)
		' // b2Vec2 r = b2Mul( me.m_body-> me.m_R, me.m_localPosition)
dim 		 rX  as variant = me.m_R.col1.x * me.m_localPosition.x + me.m_R.col2.x * me.m_localPosition.y

dim 		 rY  as variant = me.m_R.col1.y * me.m_localPosition.x + me.m_R.col2.y * me.m_localPosition.y

		' // me.m_position = me.m_body-> me.m_position + r
		 me.m_position.x = me.m_body.m_position.x + rX
		 me.m_position.y = me.m_body.m_position.y + rY
		' // me.m_maxRadius = r.Length() + me.m_radius
		 me.m_maxRadius = Math.sqrt(rX*rX+rY*rY) + me.m_radius
dim 		 aabb  as variant = new b2AABB()

		aabb.minVertex.Set( me.m_position.x - me.m_radius, me.m_position.y - me.m_radius)
		aabb.maxVertex.Set( me.m_position.x + me.m_radius, me.m_position.y + me.m_radius)
dim 		 broadPhase  as variant = me.m_body.m_world.m_broadPhase

		if (broadPhase.InRange(aabb))
			 me.m_proxyId = broadPhase.CreateProxy(aabb, this)
		else
			 me.m_proxyId = b2Pair.b2_nullProxy
		if ( me.m_proxyId == b2Pair.b2_nullProxy)
			 me.m_body.Freeze()
end

public  sub 	Synchronize(position1 as variant, R1 as variant, position2 as variant, R2 as variant) as variant ''funcion
		 me.m_R.SetM(R2)
		' // me.m_position = position2 + b2Mul(R2, me.m_localPosition)
		 me.m_position.x = (R2.col1.x * me.m_localPosition.x + R2.col2.x * me.m_localPosition.y) + position2.x
		 me.m_position.y = (R2.col1.y * me.m_localPosition.x + R2.col2.y * me.m_localPosition.y) + position2.y
		if ( me.m_proxyId == b2Pair.b2_nullProxy)
			return
 '' TODO: posible funcion (revisar)

		' //  Compute an AABB that covers the swept shape (may miss some rotation effect).
		' // b2Vec2 p1 = position1 + b2Mul(R1, me.m_localPosition)
dim 		 p1X  as variant = position1.x + (R1.col1.x * me.m_localPosition.x + R1.col2.x * me.m_localPosition.y)

dim 		 p1Y  as variant = position1.y + (R1.col1.y * me.m_localPosition.x + R1.col2.y * me.m_localPosition.y)

		' // b2Vec2 lower = b2Min(p1, me.m_position)
dim 		 lowerX  as variant = Math.min(p1X, me.m_position.x)

dim 		 lowerY  as variant = Math.min(p1Y, me.m_position.y)

		' // b2Vec2 upper = b2Max(p1, me.m_position)
dim 		 upperX  as variant = Math.max(p1X, me.m_position.x)

dim 		 upperY  as variant = Math.max(p1Y, me.m_position.y)

dim 		 aabb  as variant = new b2AABB()

		aabb.minVertex.Set(lowerX - me.m_radius, lowerY - me.m_radius)
		aabb.maxVertex.Set(upperX + me.m_radius, upperY + me.m_radius)
dim 		 broadPhase  as variant = me.m_body.m_world.m_broadPhase

		if (broadPhase.InRange(aabb))
			broadPhase.MoveProxy( me.m_proxyId, aabb)
		else
			 me.m_body.Freeze()
end

public  sub 	QuickSync(position as variant, R as variant)

		 me.m_R.SetM(R)
		' // me.m_position = position + b2Mul(R, me.m_localPosition)
		 me.m_position.x = (R.col1.x * me.m_localPosition.x + R.col2.x * me.m_localPosition.y) + position.x
		 me.m_position.y = (R.col1.y * me.m_localPosition.x + R.col2.y * me.m_localPosition.y) + position.y
end

public  sub 	ResetProxy(broadPhase as variant) as variant ''funcion
		if ( me.m_proxyId == b2Pair.b2_nullProxy)
			return
 '' TODO: posible funcion (revisar)

dim 		 proxy  as variant = broadPhase.GetProxy( me.m_proxyId)

		broadPhase.DestroyProxy( me.m_proxyId)
		proxy = null
dim 		 aabb  as variant = new b2AABB()

		aabb.minVertex.Set( me.m_position.x - me.m_radius, me.m_position.y - me.m_radius)
		aabb.maxVertex.Set( me.m_position.x + me.m_radius, me.m_position.y + me.m_radius)
		if (broadPhase.InRange(aabb))
			 me.m_proxyId = broadPhase.CreateProxy(aabb, this)
		else
			 me.m_proxyId = b2Pair.b2_nullProxy
		if ( me.m_proxyId == b2Pair.b2_nullProxy)
			 me.m_body.Freeze()
end

public  sub 	Support(dX as variant, dY as variant, out as variant) as variant ''funcion
		' // b2Vec2 u = d
		' // u.Normalize()
dim 		 len  as variant = Math.sqrt(dX*dX + dY*dY)

		dX /= len
		dY /= len
		' // return me.m_position + me.m_radius * u
 '' TODO: posible funcion (revisar)

		out.Set(	 me.m_position.x + me.m_radius*dX
					 me.m_position.y + me.m_radius*dY)
	' //  Local position in parent body
Public n: new b2Vec2(), as new 2Vec2(),
	m_radius: null)
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2MassData  as variant = Class.create()

b2MassData.prototype = 
	mass: 0.0
Public r: new b2Vec2(0,0), as new 2Vec2(0,0),
	I: 0.0
end

public  sub 	initialize()
 
		' //  initialize instance variables for references
		 me.center = new b2Vec2(0,0)
		' // 
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  The pair manager is used by the broad-phase to quickly add/remove/find pairs
' //  of overlapping proxies. It is based closely on code provided by Pierre Terdiman.
' //  http:
dim  b2Pair  as variant = Class.create()

b2Pair.prototype = 
end

public  sub 	SetBuffered()
	 me.status |= b2Pair.e_pairBuffered
 
end

public  sub 	ClearBuffered()
	 me.status &= ~b2Pair.e_pairBuffered
 
end

public  sub 	IsBuffered()
 return ( me.status & b2Pair.e_pairBuffered) == b2Pair.e_pairBuffered
  '' TODO: posible funcion (revisar)

end

public  sub 	SetRemoved()
		 me.status |= b2Pair.e_pairRemoved
 
end

public  sub 	ClearRemoved()
	 me.status &= ~b2Pair.e_pairRemoved
 
end

public  sub 	IsRemoved()
 return ( me.status & b2Pair.e_pairRemoved) == b2Pair.e_pairRemoved
  '' TODO: posible funcion (revisar)

end

public  sub 	SetFinal()
		 me.status |= b2Pair.e_pairFinal
 
end

public  sub 	IsFinal()
 return ( me.status & b2Pair.e_pairFinal) == b2Pair.e_pairFinal
  '' TODO: posible funcion (revisar)

	userData: null
	proxyId1: 0
	proxyId2: 0
	next: 0
	status: 0
	' //  STATIC
	' //  enum
end

public  sub 	initialize()
 
b2Pair.b2_nullPair = b2Settings.USHRT_MAX
b2Pair.b2_nullProxy = b2Settings.USHRT_MAX
b2Pair.b2_tableCapacity = b2Settings.b2_maxPairs
b2Pair.b2_tableMask = b2Pair.b2_tableCapacity - 1
b2Pair.e_pairBuffered = 0x0001
b2Pair.e_pairRemoved = 0x0002
b2Pair.e_pairFinal = 0x0004
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2BoundValues  as variant = Class.create()

b2BoundValues.prototype = 
	lowerValues: [0,0]
	upperValues: [0,0]
end

public  sub 	initialize()
 
		' //  initialize instance variables for references
		 me.lowerValues = [0,0]
		 me.upperValues = [0,0]
		' // 
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2BufferedPair  as variant = Class.create()

b2BufferedPair.prototype = 
	proxyId1: 0
	proxyId2: 0
end

public  sub 	initialize()
 
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  ClipVertex  as variant = Class.create()

ClipVertex.prototype = 
Public v: new b2Vec2(), as new 2Vec2(),
Public d: new b2ContactID(), as new 2ContactID(),
end

public  sub 	initialize()
 
		' //  initialize instance variables for references
		 me.v = new b2Vec2()
		 me.id = new b2ContactID()
		' // 
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  We use contact ids to facilitate warm starting.
dim  b2ContactPoint  as variant = Class.create()

b2ContactPoint.prototype = 
Public n: new b2Vec2(), as new 2Vec2(),
	separation: null
	normalImpulse: null
	tangentImpulse: null
Public d: new b2ContactID(), as new 2ContactID(),
end

public  sub 	initialize()
 
		' //  initialize instance variables for references
		 me.position = new b2Vec2()
		 me.id = new b2ContactID()
		' // 
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  A manifold for two touching convex shapes.
dim  b2AABB  as variant = Class.create()

b2AABB.prototype = 
end

public  sub 	IsValid() as variant ''funcion
		' // var d = b2Math.SubtractVV( me.maxVertex, me.minVertex)
dim 		 dX  as variant = me.maxVertex.x

dim 		 dY  as variant = me.maxVertex.y

		dX = me.maxVertex.x
		dY = me.maxVertex.y
		dX -= me.minVertex.x
		dY -= me.minVertex.y
dim 		 valid  as variant = dX >= 0.0 && dY >= 0.0

		valid = valid && me.minVertex.IsValid() && me.maxVertex.IsValid()
		return valid
 '' TODO: posible funcion (revisar)

Public x: new b2Vec2(), as new 2Vec2(),
Public x: new b2Vec2(), as new 2Vec2(),
end

public  sub 	initialize()
 
		' //  initialize instance variables for references
		 me.minVertex = new b2Vec2()
		 me.maxVertex = new b2Vec2()
		' // 
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2Proxy  as variant = Class.create()

b2Proxy.prototype = 
end

public  sub 	GetNext()
 return me.lowerBounds[0]
  '' TODO: posible funcion (revisar)

end

public  sub 	SetNext(next as variant)
  me.lowerBounds[0] = next ' /* & 0x0000ffff*/
 
end

public  sub 	IsValid()
 return me.overlapCount != b2BroadPhase.b2_invalid
  '' TODO: posible funcion (revisar)

	lowerBounds: [' /* uint*/(0), ' /* uint*/(0)]
	upperBounds: [' /* uint*/(0), ' /* uint*/(0)]
	overlapCount: 0
	timeStamp: 0
	userData: null
end

public  sub 	initialize()
 
		' //  initialize instance variables for references
		 me.lowerBounds = [' /* uint*/(0), ' /* uint*/(0)]
		 me.upperBounds = [' /* uint*/(0), ' /* uint*/(0)]
		' // 
' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2Distance  as variant = Class.create()

b2Distance.prototype = 
	' //  GJK using Voronoi regions (Christer Ericson) and region selection
	' //  optimizations (Casey Muratori).
	' //  The origin is either in the region of points[1] or in the edge region. The origin is
	' //  not in region of points[0] because that is the old point.
	' //  Possible regions:
	' //  - points[2]
	' //  - edge points[0]-points[2]
	' //  - edge points[1]-points[2]
	' //  - inside the triangle
end

public  sub 	initialize()
 
end

public  sub ProcessTwo (p1Out as variant, p2Out as variant, p1s as variant, p2s as variant, points as variant) as variant ''funcio as variant ''funcion
		' //  If in point[1] region
		' // b2Vec2 r = -points[1]
dim 		 rX  as variant = -points[1].x

dim 		 rY  as variant = -points[1].y

		' // b2Vec2 d = points[1] - points[0]
dim 		 dX  as variant = points[0].x - points[1].x

dim 		 dY  as variant = points[0].y - points[1].y

		' // float32 length = d.Normalize()
dim 		 length  as variant = Math.sqrt(dX*dX + dY*dY)

		dX /= length
		dY /= length
		' // float32 lambda = b2Dot(r, d)
dim 		 lambda  as variant = rX * dX + rY * dY

		if (lambda <= 0.0 || length < Number.MIN_VALUE)
			' //  The simplex is reduced to a point.
			' // *p1Out = p1s[1]
			p1Out.SetV(p1s[1])
			' // *p2Out = p2s[1]
			p2Out.SetV(p2s[1])
			' // p1s[0] = p1s[1]
			p1s[0].SetV(p1s[1])
			' // p2s[0] = p2s[1]
			p2s[0].SetV(p2s[1])
			points[0].SetV(points[1])
			return 1
 '' TODO: posible funcion (revisar)

		' //  Else in edge region
		lambda /= length
		' // *p1Out = p1s[1] + lambda * (p1s[0] - p1s[1])
		p1Out.x = p1s[1].x + lambda * (p1s[0].x - p1s[1].x)
		p1Out.y = p1s[1].y + lambda * (p1s[0].y - p1s[1].y)
		' // *p2Out = p2s[1] + lambda * (p2s[0] - p2s[1])
		p2Out.x = p2s[1].x + lambda * (p2s[0].x - p2s[1].x)
		p2Out.y = p2s[1].y + lambda * (p2s[0].y - p2s[1].y)
		return 2
 '' TODO: posible funcion (revisar)

end

public  sub ProcessThree (p1Out as variant, p2Out as variant, p1s as variant, p2s as variant, points as variant) as variant ''funcio as variant ''funcio as variant ''funcio as variant ''funcion
		' // b2Vec2 a = points[0]
dim 		 aX  as variant = points[0].x

dim 		 aY  as variant = points[0].y

		' // b2Vec2 b = points[1]
dim 		 bX  as variant = points[1].x

dim 		 bY  as variant = points[1].y

		' // b2Vec2 c = points[2]
dim 		 cX  as variant = points[2].x

dim 		 cY  as variant = points[2].y

		' // b2Vec2 ab = b - a
dim 		 abX  as variant = bX - aX

dim 		 abY  as variant = bY - aY

		' // b2Vec2 ac = c - a
dim 		 acX  as variant = cX - aX

dim 		 acY  as variant = cY - aY

		' // b2Vec2 bc = c - b
dim 		 bcX  as variant = cX - bX

dim 		 bcY  as variant = cY - bY

		' // float32 sn = -b2Dot(a, ab), sd = b2Dot(b, ab)
dim 		 sn  as variant = -(aX * abX + aY * abY)

dim 		 sd  as variant = (bX * abX + bY * abY)

		' // float32 tn = -b2Dot(a, ac), td = b2Dot(c, ac)
dim 		 tn  as variant = -(aX * acX + aY * acY)

dim 		 td  as variant = (cX * acX + cY * acY)

		' // float32 un = -b2Dot(b, bc), ud = b2Dot(c, bc)
dim 		 un  as variant = -(bX * bcX + bY * bcY)

dim 		 ud  as variant = (cX * bcX + cY * bcY)

		' //  In vertex c region?
		if (td <= 0.0 && ud <= 0.0)
			' //  Single point
			' // *p1Out = p1s[2]
			p1Out.SetV(p1s[2])
			' // *p2Out = p2s[2]
			p2Out.SetV(p2s[2])
			' // p1s[0] = p1s[2]
			p1s[0].SetV(p1s[2])
			' // p2s[0] = p2s[2]
			p2s[0].SetV(p2s[2])
			points[0].SetV(points[2])
			return 1
 '' TODO: posible funcion (revisar)

		' //  Should not be in vertex a or b region.
		' // b2Settings.b2Assert(sn > 0.0 || tn > 0.0)
		' // b2Settings.b2Assert(sd > 0.0 || un > 0.0)
		' // float32 n = b2Cross(ab, ac)
dim 		 n  as variant = abX * acY - abY * acX

		' //  Should not be in edge ab region.
		' // float32 vc = n * b2Cross(a, b)
dim 		 vc  as variant = n * (aX * bY - aY * bX)

		' // b2Settings.b2Assert(vc > 0.0 || sn > 0.0 || sd > 0.0)
		' //  In edge bc region?
		' // float32 va = n * b2Cross(b, c)
dim 		 va  as variant = n * (bX * cY - bY * cX)

		if (va <= 0.0 && un >= 0.0 && ud >= 0.0)
			' // b2Settings.b2Assert(un + ud > 0.0)
			' // float32 lambda = un / (un + ud)
dim 			 lambda  as variant = un / (un + ud)

			' // *p1Out = p1s[1] + lambda * (p1s[2] - p1s[1])
			p1Out.x = p1s[1].x + lambda * (p1s[2].x - p1s[1].x)
			p1Out.y = p1s[1].y + lambda * (p1s[2].y - p1s[1].y)
			' // *p2Out = p2s[1] + lambda * (p2s[2] - p2s[1])
			p2Out.x = p2s[1].x + lambda * (p2s[2].x - p2s[1].x)
			p2Out.y = p2s[1].y + lambda * (p2s[2].y - p2s[1].y)
			' // p1s[0] = p1s[2]
			p1s[0].SetV(p1s[2])
			' // p2s[0] = p2s[2]
			p2s[0].SetV(p2s[2])
			' // points[0] = points[2]
			points[0].SetV(points[2])
			return 2
 '' TODO: posible funcion (revisar)

		' //  In edge ac region?
		' // float32 vb = n * b2Cross(c, a)
dim 		 vb  as variant = n * (cX * aY - cY * aX)

		if (vb <= 0.0 && tn >= 0.0 && td >= 0.0)
			' // b2Settings.b2Assert(tn + td > 0.0)
			' // float32 lambda = tn / (tn + td)
dim 			 lambda  as variant = tn / (tn + td)

			' // *p1Out = p1s[0] + lambda * (p1s[2] - p1s[0])
			p1Out.x = p1s[0].x + lambda * (p1s[2].x - p1s[0].x)
			p1Out.y = p1s[0].y + lambda * (p1s[2].y - p1s[0].y)
			' // *p2Out = p2s[0] + lambda * (p2s[2] - p2s[0])
			p2Out.x = p2s[0].x + lambda * (p2s[2].x - p2s[0].x)
			p2Out.y = p2s[0].y + lambda * (p2s[2].y - p2s[0].y)
			' // p1s[1] = p1s[2]
			p1s[1].SetV(p1s[2])
			' // p2s[1] = p2s[2]
			p2s[1].SetV(p2s[2])
			' // points[1] = points[2]
			points[1].SetV(points[2])
			return 2
 '' TODO: posible funcion (revisar)

		' //  Inside the triangle, compute barycentric coordinates
		' // float32 denom = va + vb + vc
dim 		 denom  as variant = va + vb + vc

		' // b2Settings.b2Assert(denom > 0.0)
		denom = 1.0 / denom
		' // float32 u = va * denom
dim 		 u  as variant = va * denom

		' // float32 v = vb * denom
dim 		 v  as variant = vb * denom

		' // float32 w = 1.0f - u - v
dim 		 w  as variant = 1.0 - u - v

		' // *p1Out = u * p1s[0] + v * p1s[1] + w * p1s[2]
		p1Out.x = u * p1s[0].x + v * p1s[1].x + w * p1s[2].x
		p1Out.y = u * p1s[0].y + v * p1s[1].y + w * p1s[2].y
		' // *p2Out = u * p2s[0] + v * p2s[1] + w * p2s[2]
		p2Out.x = u * p2s[0].x + v * p2s[1].x + w * p2s[2].x
		p2Out.y = u * p2s[0].y + v * p2s[1].y + w * p2s[2].y
		return 3
 '' TODO: posible funcion (revisar)

end

public  sub InPoinsts (w as variant, points as variant, pointCount as variant) as variant ''funcio as variant ''funcion
		for (var i = 0; i < pointCount; ++i)
			if (w.x == points[i].x && w.y == points[i].y)
			
				return true
 '' TODO: posible funcion (revisar)

			
		return false
 '' TODO: posible funcion (revisar)

end

public  sub Distance (p1Out as variant, p2Out as variant, shape1 as variant, shape2 as variant) as variant ''funcio as variant ''funcio as variant ''funcio as variant ''funcio as variant ''funcion
		' // b2Vec2 p1s[3], p2s[3]
dim 		 p1s  as variant = new Array(3)

dim 		 p2s  as variant = new Array(3)

		' // b2Vec2 points[3]
dim 		 points  as variant = new Array(3)

		' // int32 pointCount = 0
dim 		 pointCount  as variant = 0

		' // *p1Out = shape1->m_position
		p1Out.SetV(shape1.m_position)
		' // *p2Out = shape2->m_position
		p2Out.SetV(shape2.m_position)
dim 		 vSqr  as variant = 0.0

dim 		 maxIterations  as variant = 20

		for (var iter = 0; iter < maxIterations; ++iter)
			' // b2Vec2 v = *p2Out - *p1Out
dim 			 vX  as variant = p2Out.x - p1Out.x

dim 			 vY  as variant = p2Out.y - p1Out.y

			' // b2Vec2 w1 = shape1->Support(v)
dim 			 w1  as variant = shape1.Support(vX, vY)

			' // b2Vec2 w2 = shape2->Support(-v)
dim 			 w2  as variant = shape2.Support(-vX, -vY)

			' // float32 vSqr = b2Dot(v, v)
			vSqr = (vX*vX + vY*vY)
			' // b2Vec2 w = w2 - w1
dim 			 wX  as variant = w2.x - w1.x

dim 			 wY  as variant = w2.y - w1.y

			' // float32 vw = b2Dot(v, w)
dim 			 vw  as variant = (vX*wX + vY*wY)

			' // if (vSqr - b2Dot(v, w) <= 0.01f * vSqr)
			if (vSqr - b2Dot(vX * wX + vY * wY) <= 0.01 * vSqr)
			
				if (pointCount == 0)
				
					' // *p1Out = w1
					p1Out.SetV(w1)
					' // *p2Out = w2
					p2Out.SetV(w2)
				
				b2Distance.g_GJK_Iterations = iter
				return Math.sqrt(vSqr)
 '' TODO: posible funcion (revisar)

			
			switch (pointCount)
			
			case 0:
				' // p1s[0] = w1
				p1s[0].SetV(w1)
				' // p2s[0] = w2
				p2s[0].SetV(w2)
				points[0] = w
				' // *p1Out = p1s[0]
				p1Out.SetV(p1s[0])
				' // *p2Out = p2s[0]
				p2Out.SetV(p2s[0])
				++pointCount
				break
			case 1:
				' // p1s[1] = w1
				p1s[1].SetV(w1)
				' // p2s[1] = w2
				p2s[1].SetV(w2)
				' // points[1] = w
				points[1].x = wX
				points[1].y = wY
				pointCount = b2Distance.ProcessTwo(p1Out, p2Out, p1s, p2s, points)
				break
			case 2:
				' // p1s[2] = w1
				p1s[2].SetV(w1)
				' // p2s[2] = w2
				p2s[2].SetV(w2)
				' // points[2] = w
				points[2].x = wX
				points[2].y = wY
				pointCount = b2Distance.ProcessThree(p1Out, p2Out, p1s, p2s, points)
				break
			
			' //  If we have three points, then the origin is in the corresponding triangle.
			if (pointCount == 3)
			
				b2Distance.g_GJK_Iterations = iter
				return 0.0
 '' TODO: posible funcion (revisar)

			
			' // float32 maxSqr = -FLT_MAX
dim 			 maxSqr  as variant = -Number.MAX_VALUE

			for (var i = 0; i < pointCount; ++i)
			
				' // maxSqr = b2Math.b2Max(maxSqr, b2Dot(points[i], points[i]))
				maxSqr = b2Math.b2Max(maxSqr, (points[i].x*points[i].x + points[i].y*points[i].y))
			
			if (pointCount == 3 || vSqr <= 100.0 * Number.MIN_VALUE * maxSqr)
			
				b2Distance.g_GJK_Iterations = iter
				return Math.sqrt(vSqr)
 '' TODO: posible funcion (revisar)

			
		b2Distance.g_GJK_Iterations = maxIterations
		return Math.sqrt(vSqr)
 '' TODO: posible funcion (revisar)

b2Distance.g_GJK_Iterations = 0
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2PairCallback  as variant = Class.create()

b2PairCallback.prototype = 
	' // virtual ~b2PairCallback() 
	' //  This returns the new pair user data. '' TODO: posible funcion (revisar)

end

public  sub 	PairAdded(proxyUserData1 as variant, proxyUserData2 as variant)
return null '' TODO: posible funcion (revisar)

	' //  This should free the pair's user data. In extreme circumstances, it is possible
	' //  this will be called with null pairUserData because the pair never existed.
end

public  sub 	PairRemoved(proxyUserData1 as variant, proxyUserData2 as variant, pairUserData as variant)

end

public  sub 	initialize()
 
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  A manifold for two touching convex shapes.
dim  b2OBB  as variant = Class.create()

b2OBB.prototype = 
Public R: new b2Mat22(), as new 2Mat22(),
Public r: new b2Vec2(), as new 2Vec2(),
Public s: new b2Vec2(), as new 2Vec2(),
end

public  sub 	initialize()
 
		' //  initialize instance variables for references
		 me.R = new b2Mat22()
		 me.center = new b2Vec2()
		 me.extents = new b2Vec2()
		' // 
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2Bound  as variant = Class.create()

b2Bound.prototype = 
end

public  sub 	IsLower()
 return ( me.value & 1) == 0
  '' TODO: posible funcion (revisar)

end

public  sub 	IsUpper()
 return ( me.value & 1) == 1
  '' TODO: posible funcion (revisar)

end

public  sub 	Swap(b as variant)

dim 		 tempValue  as variant = me.value

dim 		 tempProxyId  as variant = me.proxyId

dim 		 tempStabbingCount  as variant = me.stabbingCount

		 me.value = b.value
		 me.proxyId = b.proxyId
		 me.stabbingCount = b.stabbingCount
		b.value = tempValue
		b.proxyId = tempProxyId
		b.stabbingCount = tempStabbingCount
	value: 0
	proxyId: 0
	stabbingCount: 0
end

public  sub 	initialize()
 
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  A manifold for two touching convex shapes.
dim  b2Manifold  as variant = Class.create()

b2Manifold.prototype = 
end

public  sub 	initialize()

		 me.points = new Array(b2Settings.b2_maxManifoldPoints)
		for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++)
			 me.points[i] = new b2ContactPoint()
		 me.normal = new b2Vec2()
	points: null
	normal: null
	pointCount: 0
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  The pair manager is used by the broad-phase to quickly add/remove/find pairs
' //  of overlapping proxies. It is based closely on code provided by Pierre Terdiman.
' //  http:
dim  b2PairManager  as variant = Class.create()

b2PairManager.prototype = 
' // public:
end

public  sub 	initialize()

dim 		 i  as variant = 0

		' // b2Settings.b2Assert(b2Math.b2IsPowerOfTwo(b2Pair.b2_tableCapacity) == true)
		' // b2Settings.b2Assert(b2Pair.b2_tableCapacity >= b2Settings.b2_maxPairs)
		 me.m_hashTable = new Array(b2Pair.b2_tableCapacity)
		for (i = 0; i < b2Pair.b2_tableCapacity; ++i)
			 me.m_hashTable[i] = b2Pair.b2_nullPair
		 me.m_pairs = new Array(b2Settings.b2_maxPairs)
		for (i = 0; i < b2Settings.b2_maxPairs; ++i)
			 me.m_pairs[i] = new b2Pair()
		 me.m_pairBuffer = new Array(b2Settings.b2_maxPairs)
		for (i = 0; i < b2Settings.b2_maxPairs; ++i)
			 me.m_pairBuffer[i] = new b2BufferedPair()
		for (i = 0; i < b2Settings.b2_maxPairs; ++i)
			 me.m_pairs[i].proxyId1 = b2Pair.b2_nullProxy
			 me.m_pairs[i].proxyId2 = b2Pair.b2_nullProxy
			 me.m_pairs[i].userData = null
			 me.m_pairs[i].status = 0
			 me.m_pairs[i].next = (i + 1)
		 me.m_pairs[b2Settings.b2_maxPairs-1].next = b2Pair.b2_nullPair
		 me.m_pairCount = 0
	' // ~b2PairManager()
end

public  sub 	Initialize(broadPhase as variant, callback as variant)

		 me.m_broadPhase = broadPhase
		 me.m_callback = callback
	' /* 
	As proxies are created and moved, many pairs are created and destroyed. Even worse, the same
	pair may be added and removed multiple times in a single time step of the physics engine. To reduce
	traffic in the pair manager, we try to avoid destroying pairs in the pair manager until the
	end of the physics step. This is done by buffering all the me.RemovePair requests. me.AddPair
	requests are processed immediately because we need the hash table entry for quick lookup.
	All user user callbacks are delayed until the buffered pairs are confirmed in me.Commit.
	This is very important because the user callbacks may be very expensive and client logic
	may be harmed if pairs are added and removed within the same time step.
	Buffer a pair for addition.
	We may add a pair that is not in the pair manager or pair buffer.
	We may add a pair that is already in the pair manager and pair buffer.
	If the added pair is not a new pair, then it must be in the pair buffer (because me.RemovePair was called).
' 	*/
end

public  sub 	AddBufferedPair(proxyId1 as variant, proxyId2 as variant)

		' // b2Settings.b2Assert(id1 != b2_nullProxy && id2 != b2_nullProxy)
		' // b2Settings.b2Assert( me.m_pairBufferCount < b2_maxPairs)
dim 		 pair  as variant = me.AddPair(proxyId1, proxyId2)

		' //  If this pair is not in the pair buffer ...
		if (pair.IsBuffered() == false)
			' //  This must be a newly added pair.
			' // b2Settings.b2Assert(pair.IsFinal() == false)
			' //  Add it to the pair buffer.
			pair.SetBuffered()
			 me.m_pairBuffer[ me.m_pairBufferCount].proxyId1 = pair.proxyId1
			 me.m_pairBuffer[ me.m_pairBufferCount].proxyId2 = pair.proxyId2
			++ me.m_pairBufferCount
			' // b2Settings.b2Assert( me.m_pairBufferCount <= me.m_pairCount)
		' //  Confirm this pair for the subsequent call to me.Commit.
		pair.ClearRemoved()
		if (b2BroadPhase.s_validate)
			 me.ValidateBuffer()
	' //  Buffer a pair for removal.
end

public  sub 	RemoveBufferedPair(proxyId1 as variant, proxyId2 as variant) as variant ''funcion
		' // b2Settings.b2Assert(id1 != b2_nullProxy && id2 != b2_nullProxy)
		' // b2Settings.b2Assert( me.m_pairBufferCount < b2_maxPairs)
dim 		 pair  as variant = me.Find(proxyId1, proxyId2)

		if (pair == null)
			' //  The pair never existed. This is legal (due to collision filtering).
			return
 '' TODO: posible funcion (revisar)

		' //  If this pair is not in the pair buffer ...
		if (pair.IsBuffered() == false)
			' //  This must be an old pair.
			' // b2Settings.b2Assert(pair.IsFinal() == true)
			pair.SetBuffered()
			 me.m_pairBuffer[ me.m_pairBufferCount].proxyId1 = pair.proxyId1
			 me.m_pairBuffer[ me.m_pairBufferCount].proxyId2 = pair.proxyId2
			++ me.m_pairBufferCount
			' // b2Settings.b2Assert( me.m_pairBufferCount <= me.m_pairCount)
		pair.SetRemoved()
		if (b2BroadPhase.s_validate)
			 me.ValidateBuffer()
end

public  sub 	Commit() as variant ''funcio as variant ''funcion
dim 		 i  as variant = 0

dim 		 removeCount  as variant = 0

dim 		 proxies  as variant = me.m_broadPhase.m_proxyPool

		for (i = 0; i < me.m_pairBufferCount; ++i)
dim 			 pair  as variant = me.Find( me.m_pairBuffer[i].proxyId1, me.m_pairBuffer[i].proxyId2)

			' // b2Settings.b2Assert(pair.IsBuffered())
			pair.ClearBuffered()
			' // b2Settings.b2Assert(pair.proxyId1 < b2Settings.b2_maxProxies && pair.proxyId2 < b2Settings.b2_maxProxies)
dim 			 proxy1  as variant = proxies[ pair.proxyId1 ]

dim 			 proxy2  as variant = proxies[ pair.proxyId2 ]

			' // b2Settings.b2Assert(proxy1.IsValid())
			' // b2Settings.b2Assert(proxy2.IsValid())
			if (pair.IsRemoved())
			
				' //  It is possible a pair was added then removed before a commit. Therefore
				' //  we should be careful not to tell the user the pair was removed when the
				' //  the user didn't receive a matching add.
				if (pair.IsFinal() == true)
				
					 me.m_callback.PairRemoved(proxy1.userData, proxy2.userData, pair.userData)
				
				' //  Store the ids so we can actually remove the pair below.
				 me.m_pairBuffer[removeCount].proxyId1 = pair.proxyId1
				 me.m_pairBuffer[removeCount].proxyId2 = pair.proxyId2
				++removeCount
			
			else
			
				' // b2Settings.b2Assert( me.m_broadPhase.TestOverlap(proxy1, proxy2) == true)
				if (pair.IsFinal() == false)
				
					pair.userData = me.m_callback.PairAdded(proxy1.userData, proxy2.userData)
					pair.SetFinal()
				
			
		for (i = 0; i < removeCount; ++i)
			 me.RemovePair( me.m_pairBuffer[i].proxyId1, me.m_pairBuffer[i].proxyId2)
		 me.m_pairBufferCount = 0
		if (b2BroadPhase.s_validate)
			 me.ValidateTable()
' // private:
	' //  Add a pair and return the new pair. If the pair already exists, '' TODO: posible funcion (revisar)

	' //  no new pair is created and the old one is returned. '' TODO: posible funcion (revisar)

end

public  sub 	AddPair(proxyId1 as variant, proxyId2 as variant) as variant ''funcio as variant ''funcio as variant ''funcion
		if (proxyId1 > proxyId2)
dim 			 temp  as variant = proxyId1

			proxyId1 = proxyId2
			proxyId2 = temp
			' // b2Math.b2Swap(p1, p2)
dim 		 hash  as variant = b2PairManager.Hash(proxyId1, proxyId2) & b2Pair.b2_tableMask

		' // var pairIndex = me.FindHash(proxyId1, proxyId2, hash)
dim 		 pair  as variant = pair = me.FindHash(proxyId1, proxyId2, hash)

		if (pair != null)
			return pair
 '' TODO: posible funcion (revisar)

		' // b2Settings.b2Assert( me.m_pairCount < b2Settings.b2_maxPairs && me.m_freePair != b2_nullPair)
dim 		 pIndex  as variant = me.m_freePair

		pair = me.m_pairs[pIndex]
		 me.m_freePair = pair.next
		pair.proxyId1 = proxyId1
		pair.proxyId2 = proxyId2
		pair.status = 0
		pair.userData = null
		pair.next = me.m_hashTable[hash]
		 me.m_hashTable[hash] = pIndex
		++ me.m_pairCount
		return pair
 '' TODO: posible funcion (revisar)

	' //  Remove a pair, return the pair's userData. '' TODO: posible funcion (revisar)

end

public  sub 	RemovePair(proxyId1 as variant, proxyId2 as variant) as variant ''funcio as variant ''funcion
		' // b2Settings.b2Assert( me.m_pairCount > 0)
		if (proxyId1 > proxyId2)
dim 			 temp  as variant = proxyId1

			proxyId1 = proxyId2
			proxyId2 = temp
			' // b2Math.b2Swap(proxyId1, proxyId2)
dim 		 hash  as variant = b2PairManager.Hash(proxyId1, proxyId2) & b2Pair.b2_tableMask

dim 		 node  as variant = me.m_hashTable[hash]

dim 		 pNode  as variant = null

		while (node != b2Pair.b2_nullPair)
			if (b2PairManager.Equals( me.m_pairs[node], proxyId1, proxyId2))
			
dim 				 index  as variant = node

				' // *node = me.m_pairs[*node].next
				if (pNode)
					pNode.next = me.m_pairs[node].next
				
				else
					 me.m_hashTable[hash] = me.m_pairs[node].next
				
dim 				 pair  as variant = me.m_pairs[ index ]

dim 				 userData  as variant = pair.userData

				' //  Scrub
				pair.next = me.m_freePair
				pair.proxyId1 = b2Pair.b2_nullProxy
				pair.proxyId2 = b2Pair.b2_nullProxy
				pair.userData = null
				pair.status = 0
				 me.m_freePair = index
				-- me.m_pairCount
				return userData
 '' TODO: posible funcion (revisar)

			
			else
			
				' // node = & me.m_pairs[*node].next
				pNode = me.m_pairs[node]
				node = pNode.next
			
		' // b2Settings.b2Assert(false)
		return null
 '' TODO: posible funcion (revisar)

end

public  sub 	Find(proxyId1 as variant, proxyId2 as variant) as variant ''funcion
		if (proxyId1 > proxyId2)
dim 			 temp  as variant = proxyId1

			proxyId1 = proxyId2
			proxyId2 = temp
			' // b2Math.b2Swap(proxyId1, proxyId2)
dim 		 hash  as variant = b2PairManager.Hash(proxyId1, proxyId2) & b2Pair.b2_tableMask

		return me.FindHash(proxyId1, proxyId2, hash)
 '' TODO: posible funcion (revisar)

end

public  sub 	FindHash(proxyId1 as variant, proxyId2 as variant, hash as variant) as variant ''funcio as variant ''funcion
dim 		 index  as variant = me.m_hashTable[hash]

		while( index != b2Pair.b2_nullPair && b2PairManager.Equals( me.m_pairs[index], proxyId1, proxyId2) == false)
			index = me.m_pairs[index].next
		if ( index == b2Pair.b2_nullPair )
			return null
 '' TODO: posible funcion (revisar)

		' // b2Settings.b2Assert(index < b2_maxPairs)
		return me.m_pairs[ index ]
 '' TODO: posible funcion (revisar)

end

public  sub 	ValidateBuffer()

		' //  DEBUG
end

public  sub 	ValidateTable()

		' //  DEBUG
' // public:
	m_broadPhase: null
	m_callback: null
	m_pairs: null
	m_freePair: 0
	m_pairCount: 0
	m_pairBuffer: null
	m_pairBufferCount: 0
	m_hashTable: null
' //  static
	' //  Thomas Wang's hash, see: http:
end

public  sub Hash (proxyId1 as variant, proxyId2 as variant) as variant ''funcion
dim 		 key  as variant = ((proxyId2 << 16) & 0xffff0000) | proxyId1

		key = ~key + ((key << 15) & 0xFFFF8000)
		key = key ^ ((key >> 12) & 0x000fffff)
		key = key + ((key << 2) & 0xFFFFFFFC)
		key = key ^ ((key >> 4) & 0x0fffffff)
		key = key * 2057
		key = key ^ ((key >> 16) & 0x0000ffff)
		return key
 '' TODO: posible funcion (revisar)

end

public  sub Equals (pair as variant, proxyId1 as variant, proxyId2 as variant) as variant ''funcion
		return (pair.proxyId1 == proxyId1 && pair.proxyId2 == proxyId2)
 '' TODO: posible funcion (revisar)

end

public  sub EqualsPair (pair1 as variant, pair2 as variant) as variant ''funcion
		return pair1.proxyId1 == pair2.proxyId1 && pair1.proxyId2 == pair2.proxyId2
 '' TODO: posible funcion (revisar)
