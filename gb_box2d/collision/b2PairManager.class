' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
' you must not    
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  The pair manager is used by the broad-phase to quickly add/remove/find pairs
' //  of overlapping proxies. It is based closely on code provided by Pierre Terdiman.
' //  http:

public  sub _new()

dim 		 i  as variant = 0

		' // b2Settings.b2Assert(b2Math.b2IsPowerOfTwo(b2Pair.b2_tableCapacity) == true)
		' // b2Settings.b2Assert(b2Pair.b2_tableCapacity >= b2Settings.b2_maxPairs)
		 me.m_hashTable = new variant[]'Array(b2Pair.b2_tableCapacity)
		
		for i = 0 to b2Pair.b2_tableCapacity
			 me.m_hashTable.add( b2Pair.b2_nullPair)
		next
		
		 me.m_pairs = new variant[]'Array(b2Settings.b2_maxPairs)
		
		for i = 0  to b2Settings.b2_maxPairs
			 me.m_pairs.add( new b2Pair())
		next
		
		 me.m_pairBuffer = new variant[]'Array(b2Settings.b2_maxPairs)
		
		for i = 0 to  b2Settings.b2_maxPairs
			 me.m_pairBuffer.add( new b2BufferedPair())
		next
		
		
		
		for i = 0 to b2Settings.b2_maxPairs
			 me.m_pairs[i].proxyId1 = b2Pair.b2_nullProxy
			 me.m_pairs[i].proxyId2 = b2Pair.b2_nullProxy
			 me.m_pairs[i].userData = null
			 me.m_pairs[i].status = 0
			 me.m_pairs[i].nextt = (i + 1)
		next
		
		 me.m_pairs[b2Settings.b2_maxPairs-1].nextt = b2Pair.b2_nullPair
		 me.m_pairCount = 0
	
end

public  sub 	_new(broadPhase as variant, callback as variant)

		 me.m_broadPhase = broadPhase
		 me.m_callback = callback
end

'	As proxies are created and moved, many pairs are created and destroyed. Even worse, the same'
	'pair may be added and removed multiple times in a single time step of the physics engine. To reduce
	'traffic in the pair manager, we try to avoid destroying pairs in the pair manager until the
	'end of the physics step. This is done by buffering all the me.RemovePair requests. me.AddPair
	'requests are processed immediately because we need the hash table entry for quick lookup.
	'All user user callbacks are delayed until the buffered pairs are confirmed in me.Commit.
	'This is very important because the user callbacks may be very expensive and client logic
	'may be harmed if pairs are added and removed within the same time step.
	'Buffer a pair for addition.
	'We may add a pair that is not in the pair manager or pair buffer.
	'We may add a pair that is already in the pair manager and pair buffer.
	'If the added pair is not a new pair, then it must be in the pair buffer (because me.RemovePair was called).
' 	*/


public  sub 	AddBufferedPair(proxyId1 as variant, proxyId2 as variant)

		' // b2Settings.b2Assert(id1 != b2_nullProxy && id2 != b2_nullProxy)
		' // b2Settings.b2Assert( me.m_pairBufferCount < b2_maxPairs)
dim 		 pair  as variant = me.AddPair(proxyId1, proxyId2)

		' //  If this pair is not in the pair buffer ...
		if (pair.IsBuffered() = false) then 
			' //  This must be a newly added pair.
			' // b2Settings.b2Assert(pair.IsFinal() == false)
			' //  Add it to the pair buffer.
			pair.SetBuffered()
			 me.m_pairBuffer[ me.m_pairBufferCount].proxyId1 = pair.proxyId1
			 me.m_pairBuffer[ me.m_pairBufferCount].proxyId2 = pair.proxyId2
			 me.m_pairBufferCount +=1
			' // b2Settings.b2Assert( me.m_pairBufferCount <= me.m_pairCount)
		endif
		' //  Confirm this pair for the subsequent call to me.Commit.
		pair.ClearRemoved()
		if (b2BroadPhase.s_validate) then 
			 me.ValidateBuffer()
		endif
		
	' //  Buffer a pair for removal.
end

public  sub 	RemoveBufferedPair(proxyId1 as variant, proxyId2 as variant) as variant ''funcion
		' // b2Settings.b2Assert(id1 != b2_nullProxy && id2 != b2_nullProxy)
		' // b2Settings.b2Assert( me.m_pairBufferCount < b2_maxPairs)
dim 		 pair  as variant = me.Find(proxyId1, proxyId2)

		if (pair = null) then 
			' //  The pair never existed. This is legal (due to collision filtering).
			return
		endif
		


		' //  If this pair is not in the pair buffer ...
		if (pair.IsBuffered() = false) then 
			' //  This must be an old pair.
			' // b2Settings.b2Assert(pair.IsFinal() == true)
			 pair.SetBuffered()
			 me.m_pairBuffer[ me.m_pairBufferCount].proxyId1 = pair.proxyId1
			 me.m_pairBuffer[ me.m_pairBufferCount].proxyId2 = pair.proxyId2
			 me.m_pairBufferCount +=1
			' // b2Settings.b2Assert( me.m_pairBufferCount <= me.m_pairCount)
		endif
		
		pair.SetRemoved()
		if (b2BroadPhase.s_validate) then 	 me.ValidateBuffer()
end

public  sub 	Commit() as variant 
dim 		 i  as variant = 0

dim 		 removeCount  as variant = 0

dim 		 proxies  as variant = me.m_broadPhase.m_proxyPool

dim 			 pair  as variant

dim 			 proxy1  as variant
dim 			 proxy2  as variant

		for i = 0 to  me.m_pairBufferCount
   pair   = me.Find( me.m_pairBuffer[i].proxyId1, me.m_pairBuffer[i].proxyId2)

			' // b2Settings.b2Assert(pair.IsBuffered())
			pair.ClearBuffered()
			' // b2Settings.b2Assert(pair.proxyId1 < b2Settings.b2_maxProxies && pair.proxyId2 < b2Settings.b2_maxProxies)
			 proxy1 = proxies[ pair.proxyId1 ]

 			proxy2 = proxies[ pair.proxyId2 ]

			' // b2Settings.b2Assert(proxy1.IsValid())
			' // b2Settings.b2Assert(proxy2.IsValid())
			if (pair.IsRemoved()) then 
			
				' //  It is possible a pair was added then removed before a commit. Therefore
				' //  we should be careful not to tell the user the pair was removed when the
				' //  the user didn't receive a matching add.
				if (pair.IsFinal() = true) then 
					 me.m_callback.PairRemoved(proxy1.userData, proxy2.userData, pair.userData)
				endif
				
				' //  Store the ids so we can actually remove the pair below.
				 me.m_pairBuffer[removeCount].proxyId1 = pair.proxyId1
				 me.m_pairBuffer[removeCount].proxyId2 = pair.proxyId2
				removeCount +=1
			
			else
			
				' // b2Settings.b2Assert( me.m_broadPhase.TestOverlap(proxy1, proxy2) == true)
				if (pair.IsFinal() = false) then 
				
					pair.userData = me.m_callback.PairAdded(proxy1.userData, proxy2.userData)
					pair.SetFinal()
				endif
			endif
		next	
			
		for i = 0 to removeCount
			 me.RemovePair( me.m_pairBuffer[i].proxyId1, me.m_pairBuffer[i].proxyId2)
		next
		
		 me.m_pairBufferCount = 0

		if (b2BroadPhase.s_validate) then  			 me.ValidateTable()

end			 
' // private:
	' //  Add a pair and return the new pair. If the pair already exists, '' TODO: posible funcion (revisar)

	' //  no new pair is created and the old one is returned. '' TODO: posible funcion (revisar)



public  sub 	AddPair(proxyId1 as variant, proxyId2 as variant) as variant ''funcio as variant ''funcio as variant ''funcion
dim 			 temp  as variant = proxyId1
dim 		 hash  as variant 
dim 		 pair  as variant
dim 		 pIndex  as variant
		if (proxyId1 > proxyId2) then 
			proxyId1 = proxyId2
			proxyId2 = temp
			' // b2Math.b2Swap(p1, p2)
 hash  = b2PairManager.Hash(proxyId1, proxyId2) & b2Pair.b2_tableMask

		' // var pairIndex = me.FindHash(proxyId1, proxyId2, hash)
 pair = pair = me.FindHash(proxyId1, proxyId2, hash)

		if not isnull(pair) then 
			return pair
		endif
		
 '' TODO: posible funcion (revisar)

		' // b2Settings.b2Assert( me.m_pairCount < b2Settings.b2_maxPairs && me.m_freePair != b2_nullPair)
 		pIndex  = me.m_freePair

		pair = me.m_pairs[pIndex]
		 me.m_freePair = pair.nextt
		pair.proxyId1 = proxyId1
		pair.proxyId2 = proxyId2
		pair.status = 0
		pair.userData = null
		pair.nextt = me.m_hashTable[hash]
		 me.m_hashTable[hash] = pIndex
		 me.m_pairCount+=1
		return pair

end



	' //  Remove a pair, return the pair's userData. '' TODO: posible funcion (revisar)


public  sub 	RemovePair(proxyId1 as variant, proxyId2 as variant) as variant ''funcio as variant ''funcion
		' // b2Settings.b2Assert( me.m_pairCount > 0)

dim 			 temp  as variant
dim 		 hash  as variant 
dim 		 node  as variant 
dim 		 pNode  as variant

dim 				 index  as variant
dim 				 pair  as variant
dim 				 userData  as variant

		if (proxyId1 > proxyId2) then 
 			 temp  = proxyId1

			proxyId1 = proxyId2
			proxyId2 = temp
			' // b2Math.b2Swap(proxyId1, proxyId2)
		endif
		
		 hash   = b2PairManager.Hash(proxyId1, proxyId2) and b2Pair.b2_tableMask

		 node   = me.m_hashTable[hash]

		 pNode   = null

		while (node <> b2Pair.b2_nullPair)
			if (b2PairManager.Equals( me.m_pairs[node], proxyId1, proxyId2)) then 
			 index   = node

				' // *node = me.m_pairs[*node].next
				if (pNode)
					pNode.nextt = me.m_pairs[node].nextt
				
				else
					 me.m_hashTable[hash] = me.m_pairs[node].nextt
				endif
				
				 pair   = me.m_pairs[ index ]

				 userData   = pair.userData

				' //  Scrub
				pair.nextt = me.m_freePair
				pair.proxyId1 = b2Pair.b2_nullProxy
				pair.proxyId2 = b2Pair.b2_nullProxy
				pair.userData = null
				pair.status = 0
				 me.m_freePair = index
				 me.m_pairCount -=1
				return userData

			else
			
				' // node = & me.m_pairs[*node].next
				pNode = me.m_pairs[node]
				node = pNode.next
			endif
		wend
		
		' // b2Settings.b2Assert(false)
		return null
 '' TODO: posible funcion (revisar)

end




public  sub 	Find(proxyId1 as variant, proxyId2 as variant) as variant ''funcion
dim 		 temp  as variant
dim 		 hash  as variant


		if (proxyId1 > proxyId2) then 
			 temp   = proxyId1

			proxyId1 = proxyId2
			proxyId2 = temp
		endif
			' // b2Math.b2Swap(proxyId1, proxyId2)
	 		hash   = me.Hash(proxyId1, proxyId2) & b2Pair.b2_tableMask

		return me.FindHash(proxyId1, proxyId2, hash)
 
end

public  sub 	FindHash(proxyId1 as variant, proxyId2 as variant, hash as variant) as variant ''funcio as variant ''funcion
dim 		 index  as variant = me.m_hashTable[hash]

		while( index <>  b2Pair.b2_nullPair or  b2PairManager.Equals( me.m_pairs[index], proxyId1, proxyId2) = false)
			index = me.m_pairs[index].nextt
		wend
		
		if ( index = b2Pair.b2_nullPair ) then 
			return null
        endif

		' // b2Settings.b2Assert(index < b2_maxPairs)
		return me.m_pairs[ index ]
 '' TODO: posible funcion (revisar)

end

public  sub 	ValidateBuffer()

end

public  sub 	ValidateTable()


	m_broadPhase= null
	m_callback = null
	m_pairs = null
	m_freePair = 0
	m_pairCount = 0
	m_pairBuffer = null
	m_pairBufferCount = 0
	m_hashTable = null

end

' //  static
	' //  Thomas Wang's hash, see: http:

public  sub Hash (proxyId1 as variant, proxyId2 as variant) as variant ''funcion
dim 		 key  as variant = ((proxyId2 << 16) & 0xffff0000) | proxyId1
''TODO: FALTA POR TRADUCIR
'gambas-es.org: https://www.gambas-es.org/viewtopic.php?f=19&t=5402&highlight=

		key = ~key + ((key << 15) and 0xFFFF8000)
		key = key ^ ((key >> 12) & 0x000fffff)
		key = key + ((key << 2) & 0xFFFFFFFC)
		key = key ^ ((key >> 4) & 0x0fffffff)
		key = key * 2057
		key = key ^ ((key >> 16) & 0x0000ffff)
		return key

end

public  sub Equals (pair as variant, proxyId1 as variant, proxyId2 as variant) as boolean ''funcion
		return (pair.proxyId1 = proxyId1 and  pair.proxyId2 = proxyId2)
end

public  sub EqualsPair (pair1 as variant, pair2 as variant) as boolean ''funcion
		return ( pair1.proxyId1 = pair2.proxyId1) and (pair1.proxyId2 = pair2.proxyId2)
end
 '' TODO: posible funcion (revisar)
