' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  The pair manager is used by the broad-phase to quickly add/remove/find pairs
' //  of overlapping proxies. It is based closely on code provided by Pierre Terdiman.
' //  http:
dim  b2PairManager  as variant = Class.create()

b2PairManager.prototype = 
' // public:
end

public  sub 	initialize()

dim 		 i  as variant = 0

		' // b2Settings.b2Assert(b2Math.b2IsPowerOfTwo(b2Pair.b2_tableCapacity) == true)
		' // b2Settings.b2Assert(b2Pair.b2_tableCapacity >= b2Settings.b2_maxPairs)
		 me.m_hashTable = new Array(b2Pair.b2_tableCapacity)
		for (i = 0; i < b2Pair.b2_tableCapacity; ++i)
			 me.m_hashTable[i] = b2Pair.b2_nullPair
		 me.m_pairs = new Array(b2Settings.b2_maxPairs)
		for (i = 0; i < b2Settings.b2_maxPairs; ++i)
			 me.m_pairs[i] = new b2Pair()
		 me.m_pairBuffer = new Array(b2Settings.b2_maxPairs)
		for (i = 0; i < b2Settings.b2_maxPairs; ++i)
			 me.m_pairBuffer[i] = new b2BufferedPair()
		for (i = 0; i < b2Settings.b2_maxPairs; ++i)
			 me.m_pairs[i].proxyId1 = b2Pair.b2_nullProxy
			 me.m_pairs[i].proxyId2 = b2Pair.b2_nullProxy
			 me.m_pairs[i].userData = null
			 me.m_pairs[i].status = 0
			 me.m_pairs[i].next = (i + 1)
		 me.m_pairs[b2Settings.b2_maxPairs-1].next = b2Pair.b2_nullPair
		 me.m_pairCount = 0
	' // ~b2PairManager()
end

public  sub 	Initialize(broadPhase as variant, callback as variant)

		 me.m_broadPhase = broadPhase
		 me.m_callback = callback
	' /* 
	As proxies are created and moved, many pairs are created and destroyed. Even worse, the same
	pair may be added and removed multiple times in a single time step of the physics engine. To reduce
	traffic in the pair manager, we try to avoid destroying pairs in the pair manager until the
	end of the physics step. This is done by buffering all the me.RemovePair requests. me.AddPair
	requests are processed immediately because we need the hash table entry for quick lookup.
	All user user callbacks are delayed until the buffered pairs are confirmed in me.Commit.
	This is very important because the user callbacks may be very expensive and client logic
	may be harmed if pairs are added and removed within the same time step.
	Buffer a pair for addition.
	We may add a pair that is not in the pair manager or pair buffer.
	We may add a pair that is already in the pair manager and pair buffer.
	If the added pair is not a new pair, then it must be in the pair buffer (because me.RemovePair was called).
' 	*/
end

public  sub 	AddBufferedPair(proxyId1 as variant, proxyId2 as variant)

		' // b2Settings.b2Assert(id1 != b2_nullProxy && id2 != b2_nullProxy)
		' // b2Settings.b2Assert( me.m_pairBufferCount < b2_maxPairs)
dim 		 pair  as variant = me.AddPair(proxyId1, proxyId2)

		' //  If this pair is not in the pair buffer ...
		if (pair.IsBuffered() == false)
			' //  This must be a newly added pair.
			' // b2Settings.b2Assert(pair.IsFinal() == false)
			' //  Add it to the pair buffer.
			pair.SetBuffered()
			 me.m_pairBuffer[ me.m_pairBufferCount].proxyId1 = pair.proxyId1
			 me.m_pairBuffer[ me.m_pairBufferCount].proxyId2 = pair.proxyId2
			++ me.m_pairBufferCount
			' // b2Settings.b2Assert( me.m_pairBufferCount <= me.m_pairCount)
		' //  Confirm this pair for the subsequent call to me.Commit.
		pair.ClearRemoved()
		if (b2BroadPhase.s_validate)
			 me.ValidateBuffer()
	' //  Buffer a pair for removal.
end

public  sub 	RemoveBufferedPair(proxyId1 as variant, proxyId2 as variant) as variant ''funcion
		' // b2Settings.b2Assert(id1 != b2_nullProxy && id2 != b2_nullProxy)
		' // b2Settings.b2Assert( me.m_pairBufferCount < b2_maxPairs)
dim 		 pair  as variant = me.Find(proxyId1, proxyId2)

		if (pair == null)
			' //  The pair never existed. This is legal (due to collision filtering).
			return
 '' TODO: posible funcion (revisar)

		' //  If this pair is not in the pair buffer ...
		if (pair.IsBuffered() == false)
			' //  This must be an old pair.
			' // b2Settings.b2Assert(pair.IsFinal() == true)
			pair.SetBuffered()
			 me.m_pairBuffer[ me.m_pairBufferCount].proxyId1 = pair.proxyId1
			 me.m_pairBuffer[ me.m_pairBufferCount].proxyId2 = pair.proxyId2
			++ me.m_pairBufferCount
			' // b2Settings.b2Assert( me.m_pairBufferCount <= me.m_pairCount)
		pair.SetRemoved()
		if (b2BroadPhase.s_validate)
			 me.ValidateBuffer()
end

public  sub 	Commit() as variant ''funcio as variant ''funcion
dim 		 i  as variant = 0

dim 		 removeCount  as variant = 0

dim 		 proxies  as variant = me.m_broadPhase.m_proxyPool

		for (i = 0; i < me.m_pairBufferCount; ++i)
dim 			 pair  as variant = me.Find( me.m_pairBuffer[i].proxyId1, me.m_pairBuffer[i].proxyId2)

			' // b2Settings.b2Assert(pair.IsBuffered())
			pair.ClearBuffered()
			' // b2Settings.b2Assert(pair.proxyId1 < b2Settings.b2_maxProxies && pair.proxyId2 < b2Settings.b2_maxProxies)
dim 			 proxy1  as variant = proxies[ pair.proxyId1 ]

dim 			 proxy2  as variant = proxies[ pair.proxyId2 ]

			' // b2Settings.b2Assert(proxy1.IsValid())
			' // b2Settings.b2Assert(proxy2.IsValid())
			if (pair.IsRemoved())
			
				' //  It is possible a pair was added then removed before a commit. Therefore
				' //  we should be careful not to tell the user the pair was removed when the
				' //  the user didn't receive a matching add.
				if (pair.IsFinal() == true)
				
					 me.m_callback.PairRemoved(proxy1.userData, proxy2.userData, pair.userData)
				
				' //  Store the ids so we can actually remove the pair below.
				 me.m_pairBuffer[removeCount].proxyId1 = pair.proxyId1
				 me.m_pairBuffer[removeCount].proxyId2 = pair.proxyId2
				++removeCount
			
			else
			
				' // b2Settings.b2Assert( me.m_broadPhase.TestOverlap(proxy1, proxy2) == true)
				if (pair.IsFinal() == false)
				
					pair.userData = me.m_callback.PairAdded(proxy1.userData, proxy2.userData)
					pair.SetFinal()
				
			
		for (i = 0; i < removeCount; ++i)
			 me.RemovePair( me.m_pairBuffer[i].proxyId1, me.m_pairBuffer[i].proxyId2)
		 me.m_pairBufferCount = 0
		if (b2BroadPhase.s_validate)
			 me.ValidateTable()
' // private:
	' //  Add a pair and return the new pair. If the pair already exists, '' TODO: posible funcion (revisar)

	' //  no new pair is created and the old one is returned. '' TODO: posible funcion (revisar)

end

public  sub 	AddPair(proxyId1 as variant, proxyId2 as variant) as variant ''funcio as variant ''funcio as variant ''funcion
		if (proxyId1 > proxyId2)
dim 			 temp  as variant = proxyId1

			proxyId1 = proxyId2
			proxyId2 = temp
			' // b2Math.b2Swap(p1, p2)
dim 		 hash  as variant = b2PairManager.Hash(proxyId1, proxyId2) & b2Pair.b2_tableMask

		' // var pairIndex = me.FindHash(proxyId1, proxyId2, hash)
dim 		 pair  as variant = pair = me.FindHash(proxyId1, proxyId2, hash)

		if (pair != null)
			return pair
 '' TODO: posible funcion (revisar)

		' // b2Settings.b2Assert( me.m_pairCount < b2Settings.b2_maxPairs && me.m_freePair != b2_nullPair)
dim 		 pIndex  as variant = me.m_freePair

		pair = me.m_pairs[pIndex]
		 me.m_freePair = pair.next
		pair.proxyId1 = proxyId1
		pair.proxyId2 = proxyId2
		pair.status = 0
		pair.userData = null
		pair.next = me.m_hashTable[hash]
		 me.m_hashTable[hash] = pIndex
		++ me.m_pairCount
		return pair
 '' TODO: posible funcion (revisar)

	' //  Remove a pair, return the pair's userData. '' TODO: posible funcion (revisar)

end

public  sub 	RemovePair(proxyId1 as variant, proxyId2 as variant) as variant ''funcio as variant ''funcion
		' // b2Settings.b2Assert( me.m_pairCount > 0)
		if (proxyId1 > proxyId2)
dim 			 temp  as variant = proxyId1

			proxyId1 = proxyId2
			proxyId2 = temp
			' // b2Math.b2Swap(proxyId1, proxyId2)
dim 		 hash  as variant = b2PairManager.Hash(proxyId1, proxyId2) & b2Pair.b2_tableMask

dim 		 node  as variant = me.m_hashTable[hash]

dim 		 pNode  as variant = null

		while (node != b2Pair.b2_nullPair)
			if (b2PairManager.Equals( me.m_pairs[node], proxyId1, proxyId2))
			
dim 				 index  as variant = node

				' // *node = me.m_pairs[*node].next
				if (pNode)
					pNode.next = me.m_pairs[node].next
				
				else
					 me.m_hashTable[hash] = me.m_pairs[node].next
				
dim 				 pair  as variant = me.m_pairs[ index ]

dim 				 userData  as variant = pair.userData

				' //  Scrub
				pair.next = me.m_freePair
				pair.proxyId1 = b2Pair.b2_nullProxy
				pair.proxyId2 = b2Pair.b2_nullProxy
				pair.userData = null
				pair.status = 0
				 me.m_freePair = index
				-- me.m_pairCount
				return userData
 '' TODO: posible funcion (revisar)

			
			else
			
				' // node = & me.m_pairs[*node].next
				pNode = me.m_pairs[node]
				node = pNode.next
			
		' // b2Settings.b2Assert(false)
		return null
 '' TODO: posible funcion (revisar)

end

public  sub 	Find(proxyId1 as variant, proxyId2 as variant) as variant ''funcion
		if (proxyId1 > proxyId2)
dim 			 temp  as variant = proxyId1

			proxyId1 = proxyId2
			proxyId2 = temp
			' // b2Math.b2Swap(proxyId1, proxyId2)
dim 		 hash  as variant = b2PairManager.Hash(proxyId1, proxyId2) & b2Pair.b2_tableMask

		return me.FindHash(proxyId1, proxyId2, hash)
 '' TODO: posible funcion (revisar)

end

public  sub 	FindHash(proxyId1 as variant, proxyId2 as variant, hash as variant) as variant ''funcio as variant ''funcion
dim 		 index  as variant = me.m_hashTable[hash]

		while( index != b2Pair.b2_nullPair && b2PairManager.Equals( me.m_pairs[index], proxyId1, proxyId2) == false)
			index = me.m_pairs[index].next
		if ( index == b2Pair.b2_nullPair )
			return null
 '' TODO: posible funcion (revisar)

		' // b2Settings.b2Assert(index < b2_maxPairs)
		return me.m_pairs[ index ]
 '' TODO: posible funcion (revisar)

end

public  sub 	ValidateBuffer()

		' //  DEBUG
end

public  sub 	ValidateTable()

		' //  DEBUG
' // public:
	m_broadPhase: null
	m_callback: null
	m_pairs: null
	m_freePair: 0
	m_pairCount: 0
	m_pairBuffer: null
	m_pairBufferCount: 0
	m_hashTable: null
' //  static
	' //  Thomas Wang's hash, see: http:
end

public  sub Hash (proxyId1 as variant, proxyId2 as variant) as variant ''funcion
dim 		 key  as variant = ((proxyId2 << 16) & 0xffff0000) | proxyId1

		key = ~key + ((key << 15) & 0xFFFF8000)
		key = key ^ ((key >> 12) & 0x000fffff)
		key = key + ((key << 2) & 0xFFFFFFFC)
		key = key ^ ((key >> 4) & 0x0fffffff)
		key = key * 2057
		key = key ^ ((key >> 16) & 0x0000ffff)
		return key
 '' TODO: posible funcion (revisar)

end

public  sub Equals (pair as variant, proxyId1 as variant, proxyId2 as variant) as variant ''funcion
		return (pair.proxyId1 == proxyId1 && pair.proxyId2 == proxyId2)
 '' TODO: posible funcion (revisar)

end

public  sub EqualsPair (pair1 as variant, pair2 as variant) as variant ''funcion
		return pair1.proxyId1 == pair2.proxyId1 && pair1.proxyId2 == pair2.proxyId2
 '' TODO: posible funcion (revisar)
