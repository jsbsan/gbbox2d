' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
' you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  A convex polygon. The position of the polygon (m_position) is the
' //  position of the centroid. The vertices of the incoming polygon are pre-rotated
' //  according to the local rotation. The vertices are also shifted to be centered
' //  on the centroid. Since the local rotation is absorbed into the vertex
' //  coordinates, the polygon rotation is equal to the body rotation. However
' //  the polygon position is centered on the polygon centroid. This simplifies
' //  some collision algorithms.



inherits b2Shape



	' //  Local position of the shape centroid in parent body frame.
Public	m_localCentroid as new b2Vec2()
	' //  Local position oriented bounding box. The OBB center is relative to
	' //  shape centroid.
Public 	m_localOBB as new 2OBB()
public m_vertices as variant
public m_coreVertices as variant
public m_vertexCount as integer= 0
public 	m_normals as variant


public b2PolyShape.tempVec as new b2Vec2()
public b2PolyShape.tAbsR as new b2Mat22()

public  sub TestPoint(p as variant) as boolean  
		' // var pLocal = b2Math.b2MulTMV( me.m_R, b2Math.SubtractVV(p, me.m_position))
dim pLocal  as  new b2Vec2()
dim i as integer

dim tVec  as  new b2Vec2()
dim dot  as float

		pLocal.SetV(p)
		pLocal.Subtract( me.m_position)
		pLocal.MulTM( me.m_R)
	
	for i=0 to me.m_vertexCount
			' // var dot = b2Math.b2Dot( me.m_normals[i], b2Math.SubtractVV(pLocal, me.m_vertices[i]))
 			 tVec= new b2Vec2()

			tVec.SetV(pLocal)
			tVec.Subtract( me.m_vertices[i])
 			 dot =  b2Math.b2Dot( me.m_normals[i], tVec)

			if (dot > 0.0) then 
				return false
			else 
				return true
  			endif
  end

	' // --------------- Internals Below -------------------
	' //  Temp vec for b2Shape.PolyCentroid


public  sub _new(def as variant, body as variant, newOrigin as variant)
	dim i  as variant = 0
	dim hX   as variant
	dim hY  as variant
	dim tVec  as variant
	dim aabb  as new b2AABB()
	dim localR  as variant

	dim me.m_vertices as new variant[]
	dim	me.m_coreVertices as new variant[]
	dim me.m_normals as new variant[]


	dim box  as variant
	dim hcX  as variant  
	dim hcY  as variant 

	dim centroidX  as variant
	dim centroidY  as variant 
	dim i as integer

	dim  uX  as variant
	dim  uY  as variant
	dim length  as variant


	dim minVertexX  as float

	dim minVertexY  as float

	dim maxVertexX  as float

	dim maxVertexY  as float

	dim v  as variant 

	dim 		 i1  as  float=0

  DIM	 i2  as  float=0
  
  dim 		 positionX  as variant 
  
  dim 		 positionY  as variant

		' // for (i = 0; i < b2Settings.b2_maxPolyVertices; i++)
		' // 	 me.m_vertices[i] = new b2Vec2()
		' //  Normals


		' //  initialize instance variables for references
		 me.m_R = new b2Mat22()
		 me.m_position = new b2Vec2()
		' // 
		' //  The constructor for b2Shape
		 me.m_userData = def.userData
		 me.m_friction = def.friction
		 me.m_restitution = def.restitution
		 me.m_body = body
		 me.m_proxyId = b2Pair.b2_nullProxy
		 me.m_maxRadius = 0.0
		 me.m_categoryBits = def.categoryBits
		 me.m_maskBits = def.maskBits
		 me.m_groupIndex = def.groupIndex
		' // 
		' //  initialize instance variables for references
		 me.syncAABB = new b2AABB()
		 me.syncMat = new b2Mat22()
		 me.m_localCentroid = new b2Vec2()
		 me.m_localOBB = new b2OBB()
		' // 
		' // super(def, body)
		' //  Vertices
		 me.m_vertices = new variant[b2Settings.b2_maxPolyVertices]
		 me.m_coreVertices = new variant[b2Settings.b2_maxPolyVertices]
		' // for (i = 0; i < b2Settings.b2_maxPolyVertices; i++)
		' // 	 me.m_vertices[i] = new b2Vec2()
		' //  Normals
		 me.m_normals = new variant[(b2Settings.b2_maxPolyVertices]
		' // for (i = 0; i < b2Settings.b2_maxPolyVertices; i++)
		' // 	 me.m_normals[i] = new b2Vec2()
		' // b2Settings.b2Assert(def.type == b2Shape.e_boxShape || def.type == b2Shape.e_polyShape)
		 me.m_type = b2Shape.e_polyShape
		 localR  = new b2Mat22(def.localRotation)

		' //  Get the vertices transformed into the body frame.
		if (def.type = b2Shape.e_boxShape) then 
			' // me.m_localCentroid = def.localPosition - newOrigin
			 me.m_localCentroid.x = def.localPosition.x - newOrigin.x
			 me.m_localCentroid.y = def.localPosition.y - newOrigin.y
			box= def
			me.m_vertexCount = 4
			hX = box.extents.x
			hY = box.extents.y
			' // hc.x = b2Max(0.0f, h.x - 2.0f * b2_linearSlop)

			hcX=Math.max(0.0, hX - 2.0 * b2Settings.b2_linearSlop)

			' // hc.y = b2Max(0.0f, h.y - 2.0f * b2_linearSlop)

			hcY= Math.max(0.0, hY - 2.0 * b2Settings.b2_linearSlop)

			' // me.m_vertices[0] = b2Mul(localR, b2Vec2(h.x, h.y))
			tVec = (me.m_vertices[0] = new b2Vec2())
			tVec.x = localR.col1.x * hX + localR.col2.x * hY
			tVec.y = localR.col1.y * hX + localR.col2.y * hY
			' // me.m_vertices[1] = b2Mul(localR, b2Vec2(-h.x, h.y))
			tVec = me.m_vertices[1] = new b2Vec2()
			tVec.x = localR.col1.x * -hX + localR.col2.x * hY
			tVec.y = localR.col1.y * -hX + localR.col2.y * hY
			' // me.m_vertices[2] = b2Mul(localR, b2Vec2(-h.x, -h.y))
			tVec = me.m_vertices[2] = new b2Vec2()
			tVec.x = localR.col1.x * -hX + localR.col2.x * -hY
			tVec.y = localR.col1.y * -hX + localR.col2.y * -hY
			' // me.m_vertices[3] = b2Mul(localR, b2Vec2(h.x, -h.y))
			tVec = me.m_vertices[3] = new b2Vec2()
			tVec.x = localR.col1.x * hX + localR.col2.x * -hY
			tVec.y = localR.col1.y * hX + localR.col2.y * -hY
			' // me.m_coreVertices[0] = b2Mul(localR, b2Vec2(hc.x, hc.y))
			tVec = me.m_coreVertices[0] = new b2Vec2()
			tVec.x = localR.col1.x * hcX + localR.col2.x * hcY
			tVec.y = localR.col1.y * hcX + localR.col2.y * hcY
			' // me.m_coreVertices[1] = b2Mul(localR, b2Vec2(-hc.x, hc.y))
			tVec = me.m_coreVertices[1] = new b2Vec2()
			tVec.x = localR.col1.x * -hcX + localR.col2.x * hcY
			tVec.y = localR.col1.y * -hcX + localR.col2.y * hcY
			' // me.m_coreVertices[2] = b2Mul(localR, b2Vec2(-hc.x, -hc.y))
			tVec = me.m_coreVertices[2] = new b2Vec2()
			tVec.x = localR.col1.x * -hcX + localR.col2.x * -hcY
			tVec.y = localR.col1.y * -hcX + localR.col2.y * -hcY
			' // me.m_coreVertices[3] = b2Mul(localR, b2Vec2(hc.x, -hc.y))
			tVec = me.m_coreVertices[3] = new b2Vec2()
			tVec.x = localR.col1.x * hcX + localR.col2.x * -hcY
			tVec.y = localR.col1.y * hcX + localR.col2.y * -hcY
		else
 			 poly  = def

			 me.m_vertexCount = poly.vertexCount
			' // b2Settings.b2Assert(3 <= me.m_vertexCount && me.m_vertexCount <= b2Settings.b2_maxPolyVertices)
			' // b2Vec2 centroid = b2Shape.PolyCentroid(poly->vertices, poly->vertexCount)
			b2Shape.PolyCentroid(poly.vertices, poly.vertexCount, b2PolyShape.tempVec)
 			centroidX =b2PolyShape.tempVec.x
			centroidY = b2PolyShape.tempVec.y

			' // me.m_localCentroid = def->localPosition + b2Mul(localR, centroid) - newOrigin
			 me.m_localCentroid.x = def.localPosition.x + (localR.col1.x * centroidX + localR.col2.x * centroidY) - newOrigin.x
			 me.m_localCentroid.y = def.localPosition.y + (localR.col1.y * centroidX + localR.col2.y * centroidY) - newOrigin.y
			
			for i=0 to  me.m_vertexCount
			
				 me.m_vertices[i] = new b2Vec2()
				 me.m_coreVertices[i] = new b2Vec2()
				' // me.m_vertices[i] = b2Mul(localR, poly->vertices[i] - centroid)
				hX = poly.vertices[i].x - centroidX
				hY = poly.vertices[i].y - centroidY
				 me.m_vertices[i].x = localR.col1.x * hX + localR.col2.x * hY
				 me.m_vertices[i].y = localR.col1.y * hX + localR.col2.y * hY
				' // b2Vec2 u = me.m_vertices[i]
				 uX   = me.m_vertices[i].x

				 uY   = me.m_vertices[i].y

				' // float32 length = u.Length()
			 length = sqrt(uX*uX + uY*uY)

				if (length > Number.MIN_VALUE) then 
					uX = uX *1.0 / length
					uY = uY *1.0 / length
				endif
				
				' // me.m_coreVertices[i] = me.m_vertices[i] - 2.0f * b2_linearSlop * u
				 me.m_coreVertices[i].x = me.m_vertices[i].x - 2.0 * b2Settings.b2_linearSlop * uX
				 me.m_coreVertices[i].y = me.m_vertices[i].y - 2.0 * b2Settings.b2_linearSlop * uY
			
			next
		endif
		
			
		' //  Compute bounding box. TODO_ERIN optimize OBB
		' // var minVertex = new b2Vec2(Number.MAX_VALUE, Number.MAX_VALUE)

		 me.m_maxRadius = 0.0

		
	 	for i = 0 to me.m_vertexCount
			v =me.m_vertices[i]

			' // minVertex = b2Math.b2MinV(minVertex, me.m_vertices[i])
			minVertexX = Math.min(minVertexX, v.x)
			minVertexY = Math.min(minVertexY, v.y)
			' // maxVertex = b2Math.b2MaxV(maxVertex, me.m_vertices[i])
			maxVertexX = Math.max(maxVertexX, v.x)
			maxVertexY = Math.max(maxVertexY, v.y)
			' // me.m_maxRadius = b2Max( me.m_maxRadius, v.Length())
			 me.m_maxRadius = Math.max( me.m_maxRadius, v.Length())
		  next
		  
		  
		 me.m_localOBB.R.SetIdentity()
		' // me.m_localOBB.center = 0.5 * (minVertex + maxVertex)
		 me.m_localOBB.center.Set((minVertexX + maxVertexX) * 0.5, (minVertexY + maxVertexY) * 0.5)
		' // me.m_localOBB.extents = 0.5 * (maxVertex - minVertex)
		 me.m_localOBB.extents.Set((maxVertexX - minVertexX) * 0.5, (maxVertexY - minVertexY) * 0.5)
	
	' //  Compute the edge normals and next index map.
	 		 i1  =0

			 i2  =0

		for i = 0 TO  me.m_vertexCount
			 me.m_normals[i] =  new b2Vec2()
			i1 = i
			i2 = IF(i + 1 < me.m_vertexCount,i + 1, 0)
			' // b2Vec2 edge = me.m_vertices[i2] - me.m_vertices[i1]
			' // var edgeX = me.m_vertices[i2].x - me.m_vertices[i1].x
			' // var edgeY = me.m_vertices[i2].y - me.m_vertices[i1].y
			' // me.m_normals[i] = b2Cross(edge, 1.0f)
			 me.m_normals[i].x = me.m_vertices[i2].y - me.m_vertices[i1].y
			 me.m_normals[i].y = -( me.m_vertices[i2].x - me.m_vertices[i1].x)
			 me.m_normals[i].Normalize()
		NEXT
		
		' //  Ensure the polygon in convex. TODO_ERIN compute convex hull.
		for i = 0 TO me.m_vertexCount
			i1 = i
			i2 =IF( i + 1 < me.m_vertexCount, i + 1, 0)
		next
		
			' // b2Settings.b2Assert(b2Math.b2CrossVV( me.m_normals[i1], me.m_normals[i2]) > Number.MIN_VALUE)
		 me.m_R.SetM( me.m_body.m_R)
		' // me.m_position.SetV( me.m_body.m_position  + b2Mul( me.m_body-> me.m_R, me.m_localCentroid) )
		 me.m_position.x = me.m_body.m_position.x + ( me.m_R.col1.x * me.m_localCentroid.x + me.m_R.col2.x * me.m_localCentroid.y)
		 me.m_position.y = me.m_body.m_position.y + ( me.m_R.col1.y * me.m_localCentroid.x + me.m_R.col2.y * me.m_localCentroid.y)
		' // var R = b2Math.b2MulMM( me.m_R, me.m_localOBB.R)
			' // R.col1 = b2MulMV( me.m_R, me.m_localOBB.R.col1)
			b2PolyShape.tAbsR.col1.x = me.m_R.col1.x * me.m_localOBB.R.col1.x + me.m_R.col2.x * me.m_localOBB.R.col1.y
			b2PolyShape.tAbsR.col1.y = me.m_R.col1.y * me.m_localOBB.R.col1.x + me.m_R.col2.y * me.m_localOBB.R.col1.y
			' // R.col2 = b2MulMV( me.m_R, me.m_localOBB.R.col2)
			b2PolyShape.tAbsR.col2.x = me.m_R.col1.x * me.m_localOBB.R.col2.x + me.m_R.col2.x * me.m_localOBB.R.col2.y
			b2PolyShape.tAbsR.col2.y = me.m_R.col1.y * me.m_localOBB.R.col2.x + me.m_R.col2.y * me.m_localOBB.R.col2.y
		' // var absR = b2Math.b2AbsM(R)
		b2PolyShape.tAbsR.Abs()
		' // h = b2Math.b2MulMV(b2PolyShape.tAbsR, me.m_localOBB.extents)
		hX = b2PolyShape.tAbsR.col1.x * me.m_localOBB.extents.x + b2PolyShape.tAbsR.col2.x * me.m_localOBB.extents.y
		hY = b2PolyShape.tAbsR.col1.y * me.m_localOBB.extents.x + b2PolyShape.tAbsR.col2.y * me.m_localOBB.extents.y
		' // var position = me.m_position + b2Mul( me.m_R, me.m_localOBB.center)
 		 positionX   = me.m_position.x + ( me.m_R.col1.x * me.m_localOBB.center.x + me.m_R.col2.x * me.m_localOBB.center.y)

 		 positionY   = me.m_position.y + ( me.m_R.col1.y * me.m_localOBB.center.x + me.m_R.col2.y * me.m_localOBB.center.y)

		' // aabb.minVertex = b2Math.SubtractVV( me.m_position, h)
		aabb.minVertex.x = positionX - hX
		aabb.minVertex.y = positionY - hY
		' // aabb.maxVertex = b2Math.AddVV( me.m_position, h)
		aabb.maxVertex.x = positionX + hX
		aabb.maxVertex.y = positionY + hY

 		 broadPhase  = me.m_body.m_world.m_broadPhase

		if (broadPhase.InRange(aabb)) then 
			 me.m_proxyId = broadPhase.CreateProxy(aabb, this)
		else
			 me.m_proxyId = b2Pair.b2_nullProxy
		endif
		
		if ( me.m_proxyId = b2Pair.b2_nullProxy) then  me.m_body.Freeze()

	end


	' //  Temp AABB for Synch function
Public syncAABB as new 2AABB()
Public	syncMat as new 2Mat22()


public  sub  Synchronize(position1 as variant, R1 as variant, position2 as variant, R2 as variant) as variant ''funcion
 		' // b2AABB aabb1, aabb2
dim 		hX  as variant
dim 		hY  as variant
		' // b2Mat22 obbR = b2Mul(R1, me.m_localOBB.R)
dim 			 v1  as variant = R1.col1

dim 			 v2  as variant = R1.col2

dim 			 v3  as variant = me.m_localOBB.R.col1

dim 			 v4  as variant = me.m_localOBB.R.col2

dim 		 centerX  as variant 

dim 		 centerY  as variant 

dim 		 broadPhase  as variant

		' //  The body transform is copied for convenience.
		 me.m_R.SetM(R2)
		' // me.m_position = me.m_body-> me.m_position + b2Mul( me.m_body-> me.m_R, me.m_localCentroid)
		 me.m_position.x = me.m_body.m_position.x + (R2.col1.x * me.m_localCentroid.x + R2.col2.x * me.m_localCentroid.y)
		 me.m_position.y = me.m_body.m_position.y + (R2.col1.y * me.m_localCentroid.x + R2.col2.y * me.m_localCentroid.y)
		if ( me.m_proxyId = b2Pair.b2_nullProxy) then 
			return
		endif
		
			' // me.syncMat.col1 = b2MulMV(R1, me.m_localOBB.R.col1)
			 me.syncMat.col1.x = v1.x * v3.x + v2.x * v3.y
			 me.syncMat.col1.y = v1.y * v3.x + v2.y * v3.y
			' // me.syncMat.col2 = b2MulMV(R1, me.m_localOBB.R.col2)
			 me.syncMat.col2.x = v1.x * v4.x + v2.x * v4.y
			 me.syncMat.col2.y = v1.y * v4.x + v2.y * v4.y
		' // b2Mat22 absR = b2Abs(obbR)
		 me.syncMat.Abs()
		' // b2Vec2 center = position1 + b2Mul(R1, me.m_localCentroid + me.m_localOBB.center)
		hX = me.m_localCentroid.x + me.m_localOBB.center.x
		hY = me.m_localCentroid.y + me.m_localOBB.center.y
 		 centerX   = position1.x + (R1.col1.x * hX + R1.col2.x * hY)

 		 centerY  = position1.y + (R1.col1.y * hX + R1.col2.y * hY)

		' // b2Vec2 h = b2Mul( me.syncMat, me.m_localOBB.extents)
		hX = me.syncMat.col1.x * me.m_localOBB.extents.x + me.syncMat.col2.x * me.m_localOBB.extents.y
		hY = me.syncMat.col1.y * me.m_localOBB.extents.x + me.syncMat.col2.y * me.m_localOBB.extents.y
		' // aabb1.minVertex = center - h
		 me.syncAABB.minVertex.x = centerX - hX
		 me.syncAABB.minVertex.y = centerY - hY
		' // aabb1.maxVertex = center + h
		 me.syncAABB.maxVertex.x = centerX + hX
		 me.syncAABB.maxVertex.y = centerY + hY
		' // b2Mat22 obbR = b2Mul(R2, me.m_localOBB.R)
			v1 = R2.col1
			v2 = R2.col2
			v3 = me.m_localOBB.R.col1
			v4 = me.m_localOBB.R.col2
			' // me.syncMat.col1 = b2MulMV(R1, me.m_localOBB.R.col1)
			 me.syncMat.col1.x = v1.x * v3.x + v2.x * v3.y
			 me.syncMat.col1.y = v1.y * v3.x + v2.y * v3.y
			' // me.syncMat.col2 = b2MulMV(R1, me.m_localOBB.R.col2)
			 me.syncMat.col2.x = v1.x * v4.x + v2.x * v4.y
			 me.syncMat.col2.y = v1.y * v4.x + v2.y * v4.y
		' // b2Mat22 absR = b2Abs(obbR)
		 me.syncMat.Abs()
		' // b2Vec2 center = position2 + b2Mul(R2, me.m_localCentroid + me.m_localOBB.center)
		hX = me.m_localCentroid.x + me.m_localOBB.center.x
		hY = me.m_localCentroid.y + me.m_localOBB.center.y
		centerX = position2.x + (R2.col1.x * hX + R2.col2.x * hY)
		centerY = position2.y + (R2.col1.y * hX + R2.col2.y * hY)
		' // b2Vec2 h = b2Mul(absR, me.m_localOBB.extents)
		hX = me.syncMat.col1.x * me.m_localOBB.extents.x + me.syncMat.col2.x * me.m_localOBB.extents.y
		hY = me.syncMat.col1.y * me.m_localOBB.extents.x + me.syncMat.col2.y * me.m_localOBB.extents.y
		' // aabb2.minVertex = center - h
		' // aabb2.maxVertex = center + h
		' // aabb.minVertex = b2Min(aabb1.minVertex, aabb2.minVertex)
		 me.syncAABB.minVertex.x =min( me.syncAABB.minVertex.x, centerX - hX)
		 me.syncAABB.minVertex.y = min( me.syncAABB.minVertex.y, centerY - hY)
		' // aabb.maxVertex = b2Max(aabb1.maxVertex, aabb2.maxVertex)
		 me.syncAABB.maxVertex.x = max( me.syncAABB.maxVertex.x, centerX + hX)
		 me.syncAABB.maxVertex.y = max( me.syncAABB.maxVertex.y, centerY + hY)

 		 broadPhase   = me.m_body.m_world.m_broadPhase

		if (broadPhase.InRange( me.syncAABB)) then 
			broadPhase.MoveProxy( me.m_proxyId, me.syncAABB)
		else
			 me.m_body.Freeze()
		endif
end



public  sub QuickSync(position as variant, R as variant)
		' // me.m_R = R
		 me.m_R.SetM(R)
		' // me.m_position = position + b2Mul(R, me.m_localCentroid)
		 me.m_position.x = position.x + (R.col1.x * me.m_localCentroid.x + R.col2.x * me.m_localCentroid.y)
		 me.m_position.y = position.y + (R.col1.y * me.m_localCentroid.x + R.col2.y * me.m_localCentroid.y)
end

public  sub ResetProxy(broadPhase as variant) ''funcion
dim 		 proxy  as variant
dim 		 R  as variant 
dim 		 absR  as variant
dim 		 h  as variant

dim 		 position  as variant
dim 		 aabb  as variant 
	
		if ( me.m_proxyId = b2Pair.b2_nullProxy) then 
			return
		endif
		

 		 proxy  = broadPhase.GetProxy( me.m_proxyId)

		broadPhase.DestroyProxy( me.m_proxyId)
		proxy = null
	 	R  =b2Math.b2MulMM( me.m_R, me.m_localOBB.R)

 		absR = b2Math.b2AbsM(R)

		 h = b2Math.b2MulMV(absR, me.m_localOBB.extents)

		' // var position = me.m_position + b2Mul( me.m_R, me.m_localOBB.center)
		 position  = b2Math.b2MulMV( me.m_R, me.m_localOBB.center)

		position.Add( me.m_position)
		
		aabb   = new b2AABB()

		' // aabb.minVertex = position - h
		aabb.minVertex.SetV(position)
		aabb.minVertex.Subtract(h)
		' // aabb.maxVertex = position + h
		aabb.maxVertex.SetV(position)
		aabb.maxVertex.Add(h)
		if (broadPhase.InRange(aabb)) then
			 me.m_proxyId = broadPhase.CreateProxy(aabb, this)
		else
			 me.m_proxyId = b2Pair.b2_nullProxy
		endif
		
		if ( me.m_proxyId = b2Pair.b2_nullProxy) if
			 me.m_body.Freeze()
		endif
		
end

public  sub 	Support(dX as variant, dY as variant, out as variant) 
		' // b2Vec2 dLocal = b2MulT( me.m_R, d)
dim 		 dLocalX  as float = (dX* me.m_R.col1.x + dY* me.m_R.col1.y)

dim 		 dLocalY  as float = (dX* me.m_R.col2.x + dY* me.m_R.col2.y)

dim 		 bestIndex  as integer = 0

		' // float32 bestValue = b2Dot( me.m_vertices[0], dLocal)
dim 		 bestValue  as float = ( me.m_coreVertices[0].x * dLocalX + me.m_coreVertices[0].y * dLocalY)

dim value as variant
		
dim i as integer

		for  i = 1 to  me.m_vertexCount
			' // float32 value = b2Dot( me.m_vertices[i], dLocal)
			 value  = ( me.m_coreVertices[i].x * dLocalX + me.m_coreVertices[i].y * dLocalY)

			if (value > bestValue) then
			    bestIndex = i
				bestValue = value
			endif
			
		' // return me.m_position + b2Mul( me.m_R, me.m_vertices[bestIndex])
 '' TODO: posible funcion (revisar)

		out.Set( me.m_position.x + ( me.m_R.col1.x * me.m_coreVertices[bestIndex].x + me.m_R.col2.x * me.m_coreVertices[bestIndex].y), me.m_position.y + ( me.m_R.col1.y * me.m_coreVertices[bestIndex].x + me.m_R.col2.y * me.m_coreVertices[bestIndex].y))
	
	
end
	
