
' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
' you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */

inherits  b2Shape


Public 	m_localPosition as new b2Vec2()
public 	m_radius as float

public  sub TestPoint(p as variant) as variant 
	dim  d  as variant = new b2Vec2()
	d.SetV(p)
	d.Subtract( me.m_position)
	return b2Math.b2Dot(d, d) <= me.m_radius * me.m_radius
end

public  sub 	initialize(def as variant, body as variant, localCenter as variant)
		' //  initialize instance variables for references
dim circle  as variant = def
dim rX  as variant = me.m_R.col1.x * me.m_localPosition.x + me.m_R.col2.x * me.m_localPosition.y
dim rY  as variant = me.m_R.col1.y * me.m_localPosition.x + me.m_R.col2.y * me.m_localPosition.y
dim aabb  as variant = new b2AABB()
dim broadPhase  as variant = me.m_body.m_world.m_broadPhase

		 me.m_R = new b2Mat22()
		 me.m_position = new b2Vec2()
		' // 
		' //  The constructor for b2Shape
		 me.m_userData = def.userData
		 me.m_friction = def.friction
		 me.m_restitution = def.restitution
		 me.m_body = body
		 me.m_proxyId = b2Pair.b2_nullProxy
		 me.m_maxRadius = 0.0
		 me.m_categoryBits = def.categoryBits
		 me.m_maskBits = def.maskBits
		 me.m_groupIndex = def.groupIndex
		' // 
		' //  initialize instance variables for references
		 me.m_localPosition = new b2Vec2()
		' // 
		' // super(def, body)
		' // b2Settings.b2Assert(def.type == b2Shape.e_circleShape)


		' // me.m_localPosition = def.localPosition - localCenter
		 me.m_localPosition.Set(def.localPosition.x - localCenter.x, def.localPosition.y - localCenter.y)
		 me.m_type = b2Shape.e_circleShape
		 me.m_radius = circle.radius
		 me.m_R.SetM( me.m_body.m_R)
		' // b2Vec2 r = b2Mul( me.m_body-> me.m_R, me.m_localPosition)

		' // me.m_position = me.m_body-> me.m_position + r
		 me.m_position.x = me.m_body.m_position.x + rX
		 me.m_position.y = me.m_body.m_position.y + rY
		' // me.m_maxRadius = r.Length() + me.m_radius
		 me.m_maxRadius = Math.sqrt(rX*rX+rY*rY) + me.m_radius

		aabb.minVertex.Set( me.m_position.x - me.m_radius, me.m_position.y - me.m_radius)
		aabb.maxVertex.Set( me.m_position.x + me.m_radius, me.m_position.y + me.m_radius)

		if (broadPhase.InRange(aabb))
			 me.m_proxyId = broadPhase.CreateProxy(aabb, me)
		else
			 me.m_proxyId = b2Pair.b2_nullProxy
		endif
		
		
		if ( me.m_proxyId == b2Pair.b2_nullProxy)
			 me.m_body.Freeze()
		endif
		
end

public  sub 	Synchronize(position1 as variant, R1 as variant, position2 as variant, R2 as variant) as variant ''funcion
	dim p1X  as variant = position1.x + (R1.col1.x * me.m_localPosition.x + R1.col2.x * me.m_localPosition.y)
	dim p1Y  as variant = position1.y + (R1.col1.y * me.m_localPosition.x + R1.col2.y * me.m_localPosition.y)
		' // b2Vec2 lower = b2Min(p1, me.m_position)
	dim lowerX  as variant = Math.min(p1X, me.m_position.x)
	dim lowerY  as variant = Math.min(p1Y, me.m_position.y)
		' // b2Vec2 upper = b2Max(p1, me.m_position)
	dim upperX  as variant = Math.max(p1X, me.m_position.x)
	dim upperY  as variant = Math.max(p1Y, me.m_position.y)
	dim aabb  as variant = new b2AABB()
	dim broadPhase  as variant = me.m_body.m_world.m_broadPhase

		 me.m_R.SetM(R2)
		' // me.m_position = position2 + b2Mul(R2, me.m_localPosition)
		 me.m_position.x = (R2.col1.x * me.m_localPosition.x + R2.col2.x * me.m_localPosition.y) + position2.x
		 me.m_position.y = (R2.col1.y * me.m_localPosition.x + R2.col2.y * me.m_localPosition.y) + position2.y
		if ( me.m_proxyId = b2Pair.b2_nullProxy)
			return
		endif
 '' TODO: posible funcion (revisar)

		' //  Compute an AABB that covers the swept shape (may miss some rotation effect).
		' // b2Vec2 p1 = position1 + b2Mul(R1, me.m_localPosition)


		aabb.minVertex.Set(lowerX - me.m_radius, lowerY - me.m_radius)
		aabb.maxVertex.Set(upperX + me.m_radius, upperY + me.m_radius)


		if (broadPhase.InRange(aabb)) then
			broadPhase.MoveProxy( me.m_proxyId, aabb)
		else
			 me.m_body.Freeze()
		endif
		
end

public  sub 	QuickSync(position as variant, R as variant)
		 me.m_R.SetM(R)
		' // me.m_position = position + b2Mul(R, me.m_localPosition)
		 me.m_position.x = (R.col1.x * me.m_localPosition.x + R.col2.x * me.m_localPosition.y) + position.x
		 me.m_position.y = (R.col1.y * me.m_localPosition.x + R.col2.y * me.m_localPosition.y) + position.y
end

public  sub 	ResetProxy(broadPhase as variant) 
dim proxy  as variant = broadPhase.GetProxy( me.m_proxyId)
dim aabb  as variant = new b2AABB()

		if ( me.m_proxyId == b2Pair.b2_nullProxy) then 
			return
		 endif
 
		broadPhase.DestroyProxy( me.m_proxyId)
		proxy = null

		aabb.minVertex.Set( me.m_position.x - me.m_radius, me.m_position.y - me.m_radius)
		aabb.maxVertex.Set( me.m_position.x + me.m_radius, me.m_position.y + me.m_radius)
		if (broadPhase.InRange(aabb)) then 
			 me.m_proxyId = broadPhase.CreateProxy(aabb, this)
		else
			 me.m_proxyId = b2Pair.b2_nullProxy
		endif
		
		
		if ( me.m_proxyId == b2Pair.b2_nullProxy) then 
			 me.m_body.Freeze()
		endif
		
end

public  sub 	Support(dX as variant, dY as variant, out as variant) as variant ''funcion
		' // b2Vec2 u = d
		' // u.Normalize()
	dim  leng  as variant = Math.sqrt(dX*dX + dY*dY)

		dX=dx / leng
		dY=dy / leng
		' // return me.m_position + me.m_radius * u
 '' TODO: posible funcion (revisar)

		out.Set( me.m_position.x + me.m_radius*dX, me.m_position.y + me.m_radius*dY)
	' //  Local position in parent body
end

