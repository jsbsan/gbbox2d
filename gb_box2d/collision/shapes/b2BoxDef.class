' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2Math  as variant = Class.create()

b2Math.prototype = 
	' /* static public function b2InvSqrt(x)
		float32 xhalf = 0.5f * x
		int32 i = *(int32*)&x
		i = 0x5f3759df - (i >> 1)
		x = *(float32*)&i
		x = x * (1.5f - xhalf * x * x)
		return x
 '' TODO: posible funcion (revisar)

	*/
	' //  A * B
	' //  A^T * B
	' //  b2Math.b2Random number in range [-1,1]
	' /* inline float32 b2Math.b2Random(float32 lo, float32 hi)
		float32 r = (float32)rand()
		r /= RAND_MAX
		r = (hi - lo) * r + lo
		return r
 '' TODO: posible funcion (revisar)

	*/
	' //  "Next Largest Power of 2
	' //  Given a binary integer value x, the next largest power of 2 can be computed by a SWAR algorithm
	' //  that recursively "folds" the upper bits into the lower bits. This process yields a bit vector with
	' //  the same most significant 1, but all 1's below it. Adding 1 to that value yields the next
	' //  largest power of 2. For a 32-bit value:"
	' //  Temp vector functions to reduce calls to 'new'
	' /* static public var tempVec = new b2Vec2()
	static public var tempAABB = new b2AABB()
	*/
public  sub 	initialize()
 
public  sub b2IsValid (x as variant) as variant ''funcion
		return isFinite(x)
 '' TODO: posible funcion (revisar)

end

public  sub b2Dot (a as variant, b as variant) as variant ''funcion
		return a.x * b.x + a.y * b.y
 '' TODO: posible funcion (revisar)

end

public  sub b2CrossVV (a as variant, b as variant) as variant ''funcion
		return a.x * b.y - a.y * b.x
 '' TODO: posible funcion (revisar)

end

public  sub b2CrossVF (a as variant, s as variant) as variant ''funcion
dim 		 v  as variant = new b2Vec2(s * a.y, -s * a.x)

		return v
 '' TODO: posible funcion (revisar)

end

public  sub b2CrossFV (s as variant, a as variant) as variant ''funcion
dim 		 v  as variant = new b2Vec2(-s * a.y, s * a.x)

		return v
 '' TODO: posible funcion (revisar)

end

public  sub b2MulMV (A as variant, v as variant) as variant ''funcion
dim 		 u  as variant = new b2Vec2(A.col1.x * v.x + A.col2.x * v.y, A.col1.y * v.x + A.col2.y * v.y)

		return u
 '' TODO: posible funcion (revisar)

end

public  sub b2MulTMV (A as variant, v as variant) as variant ''funcion
dim 		 u  as variant = new b2Vec2(b2Math.b2Dot(v, A.col1), b2Math.b2Dot(v, A.col2))

		return u
 '' TODO: posible funcion (revisar)

end

public  sub AddVV (a as variant, b as variant) as variant ''funcion
dim 		 v  as variant = new b2Vec2(a.x + b.x, a.y + b.y)

		return v
 '' TODO: posible funcion (revisar)

end

public  sub SubtractVV (a as variant, b as variant) as variant ''funcion
dim 		 v  as variant = new b2Vec2(a.x - b.x, a.y - b.y)

		return v
 '' TODO: posible funcion (revisar)

end

public  sub MulFV (s as variant, a as variant) as variant ''funcion
dim 		 v  as variant = new b2Vec2(s * a.x, s * a.y)

		return v
 '' TODO: posible funcion (revisar)

end

public  sub AddMM (A as variant, B as variant) as variant ''funcion
dim 		 C  as variant = new b2Mat22(0, b2Math.AddVV(A.col1, B.col1), b2Math.AddVV(A.col2, B.col2))

		return C
 '' TODO: posible funcion (revisar)

end

public  sub b2MulMM (A as variant, B as variant) as variant ''funcion
dim 		 C  as variant = new b2Mat22(0, b2Math.b2MulMV(A, B.col1), b2Math.b2MulMV(A, B.col2))

		return C
 '' TODO: posible funcion (revisar)

end

public  sub b2MulTMM (A as variant, B as variant) as variant ''funcion
dim 		 c1  as variant = new b2Vec2(b2Math.b2Dot(A.col1, B.col1), b2Math.b2Dot(A.col2, B.col1))

dim 		 c2  as variant = new b2Vec2(b2Math.b2Dot(A.col1, B.col2), b2Math.b2Dot(A.col2, B.col2))

dim 		 C  as variant = new b2Mat22(0, c1, c2)

		return C
 '' TODO: posible funcion (revisar)

end

public  sub b2Abs (a as variant) as variant ''funcion
		return a > 0.0 ? a : -a
 '' TODO: posible funcion (revisar)

end

public  sub b2AbsV (a as variant) as variant ''funcion
dim 		 b  as variant = new b2Vec2(b2Math.b2Abs(a.x), b2Math.b2Abs(a.y))

		return b
 '' TODO: posible funcion (revisar)

end

public  sub b2AbsM (A as variant) as variant ''funcion
dim 		 B  as variant = new b2Mat22(0, b2Math.b2AbsV(A.col1), b2Math.b2AbsV(A.col2))

		return B
 '' TODO: posible funcion (revisar)

end

public  sub b2Min (a as variant, b as variant) as variant ''funcion
		return a < b ? a : b
 '' TODO: posible funcion (revisar)

end

public  sub b2MinV (a as variant, b as variant) as variant ''funcion
dim 		 c  as variant = new b2Vec2(b2Math.b2Min(a.x, b.x), b2Math.b2Min(a.y, b.y))

		return c
 '' TODO: posible funcion (revisar)

end

public  sub b2Max (a as variant, b as variant) as variant ''funcion
		return a > b ? a : b
 '' TODO: posible funcion (revisar)

end

public  sub b2MaxV (a as variant, b as variant) as variant ''funcion
dim 		 c  as variant = new b2Vec2(b2Math.b2Max(a.x, b.x), b2Math.b2Max(a.y, b.y))

		return c
 '' TODO: posible funcion (revisar)

end

public  sub b2Clamp (a as variant, low as variant, high as variant) as variant ''funcion
		return b2Math.b2Max(low, b2Math.b2Min(a, high))
 '' TODO: posible funcion (revisar)

end

public  sub b2ClampV (a as variant, low as variant, high as variant) as variant ''funcion
		return b2Math.b2MaxV(low, b2Math.b2MinV(a, high))
 '' TODO: posible funcion (revisar)

end

public  sub b2Swap (a as variant, b as variant)

dim 		 tmp  as variant = a[0]

		a[0] = b[0]
		b[0] = tmp
end

public  sub b2Random () as variant ''funcion
		return Math.random() * 2 - 1
 '' TODO: posible funcion (revisar)

end

public  sub b2NextPowerOfTwo (x as variant) as variant ''funcion
		x |= (x >> 1) & 0x7FFFFFFF
		x |= (x >> 2) & 0x3FFFFFFF
		x |= (x >> 4) & 0x0FFFFFFF
		x |= (x >> 8) & 0x00FFFFFF
		x |= (x >> 16)& 0x0000FFFF
		return x + 1
 '' TODO: posible funcion (revisar)

end

public  sub b2IsPowerOfTwo (x as variant) as variant ''funcion
dim 		 result  as variant = x > 0 && (x & (x - 1)) == 0

		return result
 '' TODO: posible funcion (revisar)

b2Math.tempVec2 = new b2Vec2()
b2Math.tempVec3 = new b2Vec2()
b2Math.tempVec4 = new b2Vec2()
b2Math.tempVec5 = new b2Vec2()
b2Math.tempMat = new b2Mat22()
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2Mat22  as variant = Class.create()

b2Mat22.prototype = 
end

public  sub 	initialize(angle as variant, c1 as variant, c2 as variant)

		if (angle==null) angle = 0
		' //  initialize instance variables for references
		 me.col1 = new b2Vec2()
		 me.col2 = new b2Vec2()
		' // 
		if (c1!=null && c2!=null)
			 me.col1.SetV(c1)
			 me.col2.SetV(c2)
		else
dim 			 c  as variant = Math.cos(angle)

dim 			 s  as variant = Math.sin(angle)

			 me.col1.x = c
 me.col2.x = -s
			 me.col1.y = s
 me.col2.y = c
end

public  sub 	Set(angle as variant)

dim 		 c  as variant = Math.cos(angle)

dim 		 s  as variant = Math.sin(angle)

		 me.col1.x = c
 me.col2.x = -s
		 me.col1.y = s
 me.col2.y = c
end

public  sub 	SetVV(c1 as variant, c2 as variant)

		 me.col1.SetV(c1)
		 me.col2.SetV(c2)
end

public  sub 	Copy() as variant ''funcion
		return new b2Mat22(0, me.col1, me.col2)
 '' TODO: posible funcion (revisar)

end

public  sub 	SetM(m as variant)

		 me.col1.SetV(m.col1)
		 me.col2.SetV(m.col2)
end

public  sub 	AddM(m as variant)

		 me.col1.x += m.col1.x
		 me.col1.y += m.col1.y
		 me.col2.x += m.col2.x
		 me.col2.y += m.col2.y
end

public  sub 	SetIdentity()

		 me.col1.x = 1.0
 me.col2.x = 0.0
		 me.col1.y = 0.0
 me.col2.y = 1.0
end

public  sub 	SetZero()

		 me.col1.x = 0.0
 me.col2.x = 0.0
		 me.col1.y = 0.0
 me.col2.y = 0.0
end

public  sub 	Invert(out as variant) as variant ''funcion
dim 		 a  as variant = me.col1.x

dim 		 b  as variant = me.col2.x

dim 		 c  as variant = me.col1.y

dim 		 d  as variant = me.col2.y

		' // var B = new b2Mat22()
dim 		 det  as variant = a * d - b * c

		' // b2Settings.b2Assert(det != 0.0)
		det = 1.0 / det
		out.col1.x =  det * d
	out.col2.x = -det * b
		out.col1.y = -det * c
	out.col2.y =  det * a
		return out
 '' TODO: posible funcion (revisar)

	' //  me.Solve A * x = b
end

public  sub 	Solve(out as variant, bX as variant, bY as variant) as variant ''funcion
		' // float32 a11 = me.col1.x, a12 = me.col2.x, a21 = me.col1.y, a22 = me.col2.y
dim 		 a11  as variant = me.col1.x

dim 		 a12  as variant = me.col2.x

dim 		 a21  as variant = me.col1.y

dim 		 a22  as variant = me.col2.y

		' // float32 det = a11 * a22 - a12 * a21
dim 		 det  as variant = a11 * a22 - a12 * a21

		' // b2Settings.b2Assert(det != 0.0)
		det = 1.0 / det
		out.x = det * (a22 * bX - a12 * bY)
		out.y = det * (a11 * bY - a21 * bX)
		return out
 '' TODO: posible funcion (revisar)

end

public  sub 	Abs()

		 me.col1.Abs()
		 me.col2.Abs()
Public 1: new b2Vec2(), as new 2Vec2(),
Public 2: new b2Vec2()
 as new 2Vec2()

﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  b2Vec2 has no constructor so that it
' //  can be placed in a union.
dim  b2Vec2  as variant = Class.create()

b2Vec2.prototype = 
end

public  sub 	initialize(x_ as variant, y_ as variant)
  me.x=x_
 me.y=y_
end

public  sub 	SetZero()
  me.x = 0.0
 me.y = 0.0
 
end

public  sub 	Set(x_ as variant, y_ as variant)
  me.x=x_
 me.y=y_
end

public  sub 	SetV(v as variant)
  me.x=v.x
 me.y=v.y
end

public  sub 	Negative()
 return new b2Vec2(- me.x, - me.y)
  '' TODO: posible funcion (revisar)

end

public  sub 	Copy() as variant ''funcion
		return new b2Vec2( me.x, me.y)
 '' TODO: posible funcion (revisar)

end

public  sub 	Add(v as variant)

		 me.x += v.x
 me.y += v.y
end

public  sub 	Subtract(v as variant)

		 me.x -= v.x
 me.y -= v.y
end

public  sub 	Multiply(a as variant)

		 me.x *= a
 me.y *= a
end

public  sub 	MulM(A as variant)

dim 		 tX  as variant = me.x

		 me.x = A.col1.x * tX + A.col2.x * me.y
		 me.y = A.col1.y * tX + A.col2.y * me.y
end

public  sub 	MulTM(A as variant)

dim 		 tX  as variant = b2Math.b2Dot(this, A.col1)

		 me.y = b2Math.b2Dot(this, A.col2)
		 me.x = tX
end

public  sub 	CrossVF(s as variant)

dim 		 tX  as variant = me.x

		 me.x = s * me.y
		 me.y = -s * tX
end

public  sub 	CrossFV(s as variant)

dim 		 tX  as variant = me.x

		 me.x = -s * me.y
		 me.y = s * tX
end

public  sub 	MinV(b as variant)

		 me.x = me.x < b.x ? me.x : b.x
		 me.y = me.y < b.y ? me.y : b.y
end

public  sub 	MaxV(b as variant)

		 me.x = me.x > b.x ? me.x : b.x
		 me.y = me.y > b.y ? me.y : b.y
end

public  sub 	Abs()

		 me.x = Math.abs( me.x)
		 me.y = Math.abs( me.y)
end

public  sub 	Length() as variant ''funcion
		return Math.sqrt( me.x * me.x + me.y * me.y)
 '' TODO: posible funcion (revisar)

end

public  sub 	Normalize() as variant ''funcio as variant ''funcion
dim 		 length  as variant = me.Length()

		if (length < Number.MIN_VALUE)
			return 0.0
 '' TODO: posible funcion (revisar)

dim 		 invLength  as variant = 1.0 / length

		 me.x *= invLength
		 me.y *= invLength
		return length
 '' TODO: posible funcion (revisar)

end

public  sub 	IsValid() as variant ''funcion
		return b2Math.b2IsValid( me.x) && b2Math.b2IsValid( me.y)
 '' TODO: posible funcion (revisar)

	x: null
	y: null
end

public  sub Make (x_ as variant, y_ as variant) as variant ''funcion
		return new b2Vec2(x_, y_)
 '' TODO: posible funcion (revisar)

﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2Settings  as variant = Class.create()

b2Settings.prototype = 
	' //  Define your unit system here. The default system is
	' //  meters-kilograms-seconds. For the tuning to work well
	' //  your dynamic objects should be bigger than a pebble and smaller
	' //  than a house.
	' // static public const b2Settings.b2_lengthUnitsPerMeter = 1.0
	' //  Use this for pixels:
	' //  Global tuning constants based on MKS units.
	' //  Collision
	' //  Dynamics
	' //  Sleep
	' //  assert
end

public  sub 	initialize()
 
b2Settings.USHRT_MAX = 0x0000ffff
b2Settings.b2_pi = Math.PI
b2Settings.b2_massUnitsPerKilogram = 1.0
b2Settings.b2_timeUnitsPerSecond = 1.0
b2Settings.b2_lengthUnitsPerMeter = 30.0
b2Settings.b2_maxManifoldPoints = 2
b2Settings.b2_maxShapesPerBody = 64
b2Settings.b2_maxPolyVertices = 8
b2Settings.b2_maxProxies = 1024
b2Settings.b2_maxPairs = 8 * b2Settings.b2_maxProxies
b2Settings.b2_linearSlop = 0.005 * b2Settings.b2_lengthUnitsPerMeter
b2Settings.b2_angularSlop = 2.0 / 180.0 * b2Settings.b2_pi
b2Settings.b2_velocityThreshold = 1.0 * b2Settings.b2_lengthUnitsPerMeter / b2Settings.b2_timeUnitsPerSecond
b2Settings.b2_maxLinearCorrection = 0.2 * b2Settings.b2_lengthUnitsPerMeter
b2Settings.b2_maxAngularCorrection = 8.0 / 180.0 * b2Settings.b2_pi
b2Settings.b2_contactBaumgarte = 0.2
b2Settings.b2_timeToSleep = 0.5 * b2Settings.b2_timeUnitsPerSecond
b2Settings.b2_linearSleepTolerance = 0.01 * b2Settings.b2_lengthUnitsPerMeter / b2Settings.b2_timeUnitsPerSecond
b2Settings.b2_angularSleepTolerance = 2.0 / 180.0 / b2Settings.b2_timeUnitsPerSecond
end

public  sub b2Assert (a as variant)

		if (!a)
dim 			nullVec
 as variant
			nullVec.x++
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2CircleDef  as variant = Class.create()

inherits , b2ShapeDef
inherits 
end

public  sub 	initialize()

		' //  The constructor for b2ShapeDef
		 me.type = b2Shape.e_unknownShape
		 me.userData = null
		 me.localPosition = new b2Vec2(0.0, 0.0)
		 me.localRotation = 0.0
		 me.friction = 0.2
		 me.restitution = 0.0
		 me.density = 0.0
		 me.categoryBits = 0x0001
		 me.maskBits = 0xFFFF
		 me.groupIndex = 0
	
		' // 
		 me.type = b2Shape.e_circleShape
		 me.radius = 1.0
	radius: null)
' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  A convex polygon. The position of the polygon (m_position) is the
' //  position of the centroid. The vertices of the incoming polygon are pre-rotated
' //  according to the local rotation. The vertices are also shifted to be centered
' //  on the centroid. Since the local rotation is absorbed into the vertex
' //  coordinates, the polygon rotation is equal to the body rotation. However
' //  the polygon position is centered on the polygon centroid. This simplifies
' //  some collision algorithms.
dim  b2PolyShape  as variant = Class.create()

inherits , b2Shape
inherits 
end

public  sub 	TestPoint(p as variant) as variant ''funcio as variant ''funcion
		' // var pLocal = b2Math.b2MulTMV( me.m_R, b2Math.SubtractVV(p, me.m_position))
dim 		 pLocal  as variant = new b2Vec2()

		pLocal.SetV(p)
		pLocal.Subtract( me.m_position)
		pLocal.MulTM( me.m_R)
		for (var i = 0; i < me.m_vertexCount; ++i)
			' // var dot = b2Math.b2Dot( me.m_normals[i], b2Math.SubtractVV(pLocal, me.m_vertices[i]))
dim 			 tVec  as variant = new b2Vec2()

			tVec.SetV(pLocal)
			tVec.Subtract( me.m_vertices[i])
dim 			 dot  as variant = b2Math.b2Dot( me.m_normals[i], tVec)

			if (dot > 0.0)
			
				return false
 '' TODO: posible funcion (revisar)

			
		return true
 '' TODO: posible funcion (revisar)

	' // --------------- Internals Below -------------------
	' //  Temp vec for b2Shape.PolyCentroid
end

public  sub 	initialize(def as variant, body as variant, newOrigin as variant)

		' //  initialize instance variables for references
		 me.m_R = new b2Mat22()
		 me.m_position = new b2Vec2()
		' // 
		' //  The constructor for b2Shape
		 me.m_userData = def.userData
		 me.m_friction = def.friction
		 me.m_restitution = def.restitution
		 me.m_body = body
		 me.m_proxyId = b2Pair.b2_nullProxy
		 me.m_maxRadius = 0.0
		 me.m_categoryBits = def.categoryBits
		 me.m_maskBits = def.maskBits
		 me.m_groupIndex = def.groupIndex
		' // 
		' //  initialize instance variables for references
		 me.syncAABB = new b2AABB()
		 me.syncMat = new b2Mat22()
		 me.m_localCentroid = new b2Vec2()
		 me.m_localOBB = new b2OBB()
		' // 
		' // super(def, body)
dim 		 i  as variant = 0

dim 		hX
 as variant
dim 		hY
 as variant
dim 		tVec
 as variant
dim 		 aabb  as variant = new b2AABB()

		' //  Vertices
		 me.m_vertices = new Array(b2Settings.b2_maxPolyVertices)
		 me.m_coreVertices = new Array(b2Settings.b2_maxPolyVertices)
		' // for (i = 0; i < b2Settings.b2_maxPolyVertices; i++)
		' // 	 me.m_vertices[i] = new b2Vec2()
		' //  Normals
		 me.m_normals = new Array(b2Settings.b2_maxPolyVertices)
		' // for (i = 0; i < b2Settings.b2_maxPolyVertices; i++)
		' // 	 me.m_normals[i] = new b2Vec2()
		' // b2Settings.b2Assert(def.type == b2Shape.e_boxShape || def.type == b2Shape.e_polyShape)
		 me.m_type = b2Shape.e_polyShape
dim 		 localR  as variant = new b2Mat22(def.localRotation)

		' //  Get the vertices transformed into the body frame.
		if (def.type == b2Shape.e_boxShape)
			' // me.m_localCentroid = def.localPosition - newOrigin
			 me.m_localCentroid.x = def.localPosition.x - newOrigin.x
			 me.m_localCentroid.y = def.localPosition.y - newOrigin.y
dim 			 box  as variant = def

			 me.m_vertexCount = 4
			hX = box.extents.x
			hY = box.extents.y
			' // hc.x = b2Max(0.0f, h.x - 2.0f * b2_linearSlop)
dim 			 hcX  as variant = Math.max(0.0, hX - 2.0 * b2Settings.b2_linearSlop)

			' // hc.y = b2Max(0.0f, h.y - 2.0f * b2_linearSlop)
dim 			 hcY  as variant = Math.max(0.0, hY - 2.0 * b2Settings.b2_linearSlop)

			' // me.m_vertices[0] = b2Mul(localR, b2Vec2(h.x, h.y))
			tVec = me.m_vertices[0] = new b2Vec2()
			tVec.x = localR.col1.x * hX + localR.col2.x * hY
			tVec.y = localR.col1.y * hX + localR.col2.y * hY
			' // me.m_vertices[1] = b2Mul(localR, b2Vec2(-h.x, h.y))
			tVec = me.m_vertices[1] = new b2Vec2()
			tVec.x = localR.col1.x * -hX + localR.col2.x * hY
			tVec.y = localR.col1.y * -hX + localR.col2.y * hY
			' // me.m_vertices[2] = b2Mul(localR, b2Vec2(-h.x, -h.y))
			tVec = me.m_vertices[2] = new b2Vec2()
			tVec.x = localR.col1.x * -hX + localR.col2.x * -hY
			tVec.y = localR.col1.y * -hX + localR.col2.y * -hY
			' // me.m_vertices[3] = b2Mul(localR, b2Vec2(h.x, -h.y))
			tVec = me.m_vertices[3] = new b2Vec2()
			tVec.x = localR.col1.x * hX + localR.col2.x * -hY
			tVec.y = localR.col1.y * hX + localR.col2.y * -hY
			' // me.m_coreVertices[0] = b2Mul(localR, b2Vec2(hc.x, hc.y))
			tVec = me.m_coreVertices[0] = new b2Vec2()
			tVec.x = localR.col1.x * hcX + localR.col2.x * hcY
			tVec.y = localR.col1.y * hcX + localR.col2.y * hcY
			' // me.m_coreVertices[1] = b2Mul(localR, b2Vec2(-hc.x, hc.y))
			tVec = me.m_coreVertices[1] = new b2Vec2()
			tVec.x = localR.col1.x * -hcX + localR.col2.x * hcY
			tVec.y = localR.col1.y * -hcX + localR.col2.y * hcY
			' // me.m_coreVertices[2] = b2Mul(localR, b2Vec2(-hc.x, -hc.y))
			tVec = me.m_coreVertices[2] = new b2Vec2()
			tVec.x = localR.col1.x * -hcX + localR.col2.x * -hcY
			tVec.y = localR.col1.y * -hcX + localR.col2.y * -hcY
			' // me.m_coreVertices[3] = b2Mul(localR, b2Vec2(hc.x, -hc.y))
			tVec = me.m_coreVertices[3] = new b2Vec2()
			tVec.x = localR.col1.x * hcX + localR.col2.x * -hcY
			tVec.y = localR.col1.y * hcX + localR.col2.y * -hcY
		else
dim 			 poly  as variant = def

			 me.m_vertexCount = poly.vertexCount
			' // b2Settings.b2Assert(3 <= me.m_vertexCount && me.m_vertexCount <= b2Settings.b2_maxPolyVertices)
			' // b2Vec2 centroid = b2Shape.PolyCentroid(poly->vertices, poly->vertexCount)
			b2Shape.PolyCentroid(poly.vertices, poly.vertexCount, b2PolyShape.tempVec)
dim 			 centroidX  as variant = b2PolyShape.tempVec.x

dim 			 centroidY  as variant = b2PolyShape.tempVec.y

			' // me.m_localCentroid = def->localPosition + b2Mul(localR, centroid) - newOrigin
			 me.m_localCentroid.x = def.localPosition.x + (localR.col1.x * centroidX + localR.col2.x * centroidY) - newOrigin.x
			 me.m_localCentroid.y = def.localPosition.y + (localR.col1.y * centroidX + localR.col2.y * centroidY) - newOrigin.y
			for (i = 0; i < me.m_vertexCount; ++i)
			
				 me.m_vertices[i] = new b2Vec2()
				 me.m_coreVertices[i] = new b2Vec2()
				' // me.m_vertices[i] = b2Mul(localR, poly->vertices[i] - centroid)
				hX = poly.vertices[i].x - centroidX
				hY = poly.vertices[i].y - centroidY
				 me.m_vertices[i].x = localR.col1.x * hX + localR.col2.x * hY
				 me.m_vertices[i].y = localR.col1.y * hX + localR.col2.y * hY
				' // b2Vec2 u = me.m_vertices[i]
dim 				 uX  as variant = me.m_vertices[i].x

dim 				 uY  as variant = me.m_vertices[i].y

				' // float32 length = u.Length()
dim 				 length  as variant = Math.sqrt(uX*uX + uY*uY)

				if (length > Number.MIN_VALUE)
				
					uX *= 1.0 / length
					uY *= 1.0 / length
				
				' // me.m_coreVertices[i] = me.m_vertices[i] - 2.0f * b2_linearSlop * u
				 me.m_coreVertices[i].x = me.m_vertices[i].x - 2.0 * b2Settings.b2_linearSlop * uX
				 me.m_coreVertices[i].y = me.m_vertices[i].y - 2.0 * b2Settings.b2_linearSlop * uY
			
		' //  Compute bounding box. TODO_ERIN optimize OBB
		' // var minVertex = new b2Vec2(Number.MAX_VALUE, Number.MAX_VALUE)
dim 		 minVertexX  as variant = Number.MAX_VALUE

dim 		 minVertexY  as variant = Number.MAX_VALUE

dim 		 maxVertexX  as variant = -Number.MAX_VALUE

dim 		 maxVertexY  as variant = -Number.MAX_VALUE

		 me.m_maxRadius = 0.0
		for (i = 0; i < me.m_vertexCount; ++i)
dim 			 v  as variant = me.m_vertices[i]

			' // minVertex = b2Math.b2MinV(minVertex, me.m_vertices[i])
			minVertexX = Math.min(minVertexX, v.x)
			minVertexY = Math.min(minVertexY, v.y)
			' // maxVertex = b2Math.b2MaxV(maxVertex, me.m_vertices[i])
			maxVertexX = Math.max(maxVertexX, v.x)
			maxVertexY = Math.max(maxVertexY, v.y)
			' // me.m_maxRadius = b2Max( me.m_maxRadius, v.Length())
			 me.m_maxRadius = Math.max( me.m_maxRadius, v.Length())
		 me.m_localOBB.R.SetIdentity()
		' // me.m_localOBB.center = 0.5 * (minVertex + maxVertex)
		 me.m_localOBB.center.Set((minVertexX + maxVertexX) * 0.5, (minVertexY + maxVertexY) * 0.5)
		' // me.m_localOBB.extents = 0.5 * (maxVertex - minVertex)
		 me.m_localOBB.extents.Set((maxVertexX - minVertexX) * 0.5, (maxVertexY - minVertexY) * 0.5)
		' //  Compute the edge normals and next index map.
dim 		 i1  as variant = 0

dim 		 i2  as variant = 0

		for (i = 0; i < me.m_vertexCount; ++i)
			 me.m_normals[i] =  new b2Vec2()
			i1 = i
			i2 = i + 1 < me.m_vertexCount ? i + 1 : 0
			' // b2Vec2 edge = me.m_vertices[i2] - me.m_vertices[i1]
			' // var edgeX = me.m_vertices[i2].x - me.m_vertices[i1].x
			' // var edgeY = me.m_vertices[i2].y - me.m_vertices[i1].y
			' // me.m_normals[i] = b2Cross(edge, 1.0f)
			 me.m_normals[i].x = me.m_vertices[i2].y - me.m_vertices[i1].y
			 me.m_normals[i].y = -( me.m_vertices[i2].x - me.m_vertices[i1].x)
			 me.m_normals[i].Normalize()
		' //  Ensure the polygon in convex. TODO_ERIN compute convex hull.
		for (i = 0; i < me.m_vertexCount; ++i)
			i1 = i
			i2 = i + 1 < me.m_vertexCount ? i + 1 : 0
			' // b2Settings.b2Assert(b2Math.b2CrossVV( me.m_normals[i1], me.m_normals[i2]) > Number.MIN_VALUE)
		 me.m_R.SetM( me.m_body.m_R)
		' // me.m_position.SetV( me.m_body.m_position  + b2Mul( me.m_body-> me.m_R, me.m_localCentroid) )
		 me.m_position.x = me.m_body.m_position.x + ( me.m_R.col1.x * me.m_localCentroid.x + me.m_R.col2.x * me.m_localCentroid.y)
		 me.m_position.y = me.m_body.m_position.y + ( me.m_R.col1.y * me.m_localCentroid.x + me.m_R.col2.y * me.m_localCentroid.y)
		' // var R = b2Math.b2MulMM( me.m_R, me.m_localOBB.R)
			' // R.col1 = b2MulMV( me.m_R, me.m_localOBB.R.col1)
			b2PolyShape.tAbsR.col1.x = me.m_R.col1.x * me.m_localOBB.R.col1.x + me.m_R.col2.x * me.m_localOBB.R.col1.y
			b2PolyShape.tAbsR.col1.y = me.m_R.col1.y * me.m_localOBB.R.col1.x + me.m_R.col2.y * me.m_localOBB.R.col1.y
			' // R.col2 = b2MulMV( me.m_R, me.m_localOBB.R.col2)
			b2PolyShape.tAbsR.col2.x = me.m_R.col1.x * me.m_localOBB.R.col2.x + me.m_R.col2.x * me.m_localOBB.R.col2.y
			b2PolyShape.tAbsR.col2.y = me.m_R.col1.y * me.m_localOBB.R.col2.x + me.m_R.col2.y * me.m_localOBB.R.col2.y
		' // var absR = b2Math.b2AbsM(R)
		b2PolyShape.tAbsR.Abs()
		' // h = b2Math.b2MulMV(b2PolyShape.tAbsR, me.m_localOBB.extents)
		hX = b2PolyShape.tAbsR.col1.x * me.m_localOBB.extents.x + b2PolyShape.tAbsR.col2.x * me.m_localOBB.extents.y
		hY = b2PolyShape.tAbsR.col1.y * me.m_localOBB.extents.x + b2PolyShape.tAbsR.col2.y * me.m_localOBB.extents.y
		' // var position = me.m_position + b2Mul( me.m_R, me.m_localOBB.center)
dim 		 positionX  as variant = me.m_position.x + ( me.m_R.col1.x * me.m_localOBB.center.x + me.m_R.col2.x * me.m_localOBB.center.y)

dim 		 positionY  as variant = me.m_position.y + ( me.m_R.col1.y * me.m_localOBB.center.x + me.m_R.col2.y * me.m_localOBB.center.y)

		' // aabb.minVertex = b2Math.SubtractVV( me.m_position, h)
		aabb.minVertex.x = positionX - hX
		aabb.minVertex.y = positionY - hY
		' // aabb.maxVertex = b2Math.AddVV( me.m_position, h)
		aabb.maxVertex.x = positionX + hX
		aabb.maxVertex.y = positionY + hY
dim 		 broadPhase  as variant = me.m_body.m_world.m_broadPhase

		if (broadPhase.InRange(aabb))
			 me.m_proxyId = broadPhase.CreateProxy(aabb, this)
		else
			 me.m_proxyId = b2Pair.b2_nullProxy
		if ( me.m_proxyId == b2Pair.b2_nullProxy)
			 me.m_body.Freeze()
	' //  Temp AABB for Synch function
Public B: new b2AABB(), as new 2AABB(),
Public t: new b2Mat22(), as new 2Mat22(),
end

public  sub 	Synchronize(position1 as variant, R1 as variant, position2 as variant, R2 as variant) as variant ''funcion
		' //  The body transform is copied for convenience.
		 me.m_R.SetM(R2)
		' // me.m_position = me.m_body-> me.m_position + b2Mul( me.m_body-> me.m_R, me.m_localCentroid)
		 me.m_position.x = me.m_body.m_position.x + (R2.col1.x * me.m_localCentroid.x + R2.col2.x * me.m_localCentroid.y)
		 me.m_position.y = me.m_body.m_position.y + (R2.col1.y * me.m_localCentroid.x + R2.col2.y * me.m_localCentroid.y)
		if ( me.m_proxyId == b2Pair.b2_nullProxy)
			return
 '' TODO: posible funcion (revisar)

		' // b2AABB aabb1, aabb2
dim 		hX
 as variant
dim 		hY
 as variant
		' // b2Mat22 obbR = b2Mul(R1, me.m_localOBB.R)
dim 			 v1  as variant = R1.col1

dim 			 v2  as variant = R1.col2

dim 			 v3  as variant = me.m_localOBB.R.col1

dim 			 v4  as variant = me.m_localOBB.R.col2

			' // me.syncMat.col1 = b2MulMV(R1, me.m_localOBB.R.col1)
			 me.syncMat.col1.x = v1.x * v3.x + v2.x * v3.y
			 me.syncMat.col1.y = v1.y * v3.x + v2.y * v3.y
			' // me.syncMat.col2 = b2MulMV(R1, me.m_localOBB.R.col2)
			 me.syncMat.col2.x = v1.x * v4.x + v2.x * v4.y
			 me.syncMat.col2.y = v1.y * v4.x + v2.y * v4.y
		' // b2Mat22 absR = b2Abs(obbR)
		 me.syncMat.Abs()
		' // b2Vec2 center = position1 + b2Mul(R1, me.m_localCentroid + me.m_localOBB.center)
		hX = me.m_localCentroid.x + me.m_localOBB.center.x
		hY = me.m_localCentroid.y + me.m_localOBB.center.y
dim 		 centerX  as variant = position1.x + (R1.col1.x * hX + R1.col2.x * hY)

dim 		 centerY  as variant = position1.y + (R1.col1.y * hX + R1.col2.y * hY)

		' // b2Vec2 h = b2Mul( me.syncMat, me.m_localOBB.extents)
		hX = me.syncMat.col1.x * me.m_localOBB.extents.x + me.syncMat.col2.x * me.m_localOBB.extents.y
		hY = me.syncMat.col1.y * me.m_localOBB.extents.x + me.syncMat.col2.y * me.m_localOBB.extents.y
		' // aabb1.minVertex = center - h
		 me.syncAABB.minVertex.x = centerX - hX
		 me.syncAABB.minVertex.y = centerY - hY
		' // aabb1.maxVertex = center + h
		 me.syncAABB.maxVertex.x = centerX + hX
		 me.syncAABB.maxVertex.y = centerY + hY
		' // b2Mat22 obbR = b2Mul(R2, me.m_localOBB.R)
			v1 = R2.col1
			v2 = R2.col2
			v3 = me.m_localOBB.R.col1
			v4 = me.m_localOBB.R.col2
			' // me.syncMat.col1 = b2MulMV(R1, me.m_localOBB.R.col1)
			 me.syncMat.col1.x = v1.x * v3.x + v2.x * v3.y
			 me.syncMat.col1.y = v1.y * v3.x + v2.y * v3.y
			' // me.syncMat.col2 = b2MulMV(R1, me.m_localOBB.R.col2)
			 me.syncMat.col2.x = v1.x * v4.x + v2.x * v4.y
			 me.syncMat.col2.y = v1.y * v4.x + v2.y * v4.y
		' // b2Mat22 absR = b2Abs(obbR)
		 me.syncMat.Abs()
		' // b2Vec2 center = position2 + b2Mul(R2, me.m_localCentroid + me.m_localOBB.center)
		hX = me.m_localCentroid.x + me.m_localOBB.center.x
		hY = me.m_localCentroid.y + me.m_localOBB.center.y
		centerX = position2.x + (R2.col1.x * hX + R2.col2.x * hY)
		centerY = position2.y + (R2.col1.y * hX + R2.col2.y * hY)
		' // b2Vec2 h = b2Mul(absR, me.m_localOBB.extents)
		hX = me.syncMat.col1.x * me.m_localOBB.extents.x + me.syncMat.col2.x * me.m_localOBB.extents.y
		hY = me.syncMat.col1.y * me.m_localOBB.extents.x + me.syncMat.col2.y * me.m_localOBB.extents.y
		' // aabb2.minVertex = center - h
		' // aabb2.maxVertex = center + h
		' // aabb.minVertex = b2Min(aabb1.minVertex, aabb2.minVertex)
		 me.syncAABB.minVertex.x = Math.min( me.syncAABB.minVertex.x, centerX - hX)
		 me.syncAABB.minVertex.y = Math.min( me.syncAABB.minVertex.y, centerY - hY)
		' // aabb.maxVertex = b2Max(aabb1.maxVertex, aabb2.maxVertex)
		 me.syncAABB.maxVertex.x = Math.max( me.syncAABB.maxVertex.x, centerX + hX)
		 me.syncAABB.maxVertex.y = Math.max( me.syncAABB.maxVertex.y, centerY + hY)
dim 		 broadPhase  as variant = me.m_body.m_world.m_broadPhase

		if (broadPhase.InRange( me.syncAABB))
			broadPhase.MoveProxy( me.m_proxyId, me.syncAABB)
		else
			 me.m_body.Freeze()
end

public  sub 	QuickSync(position as variant, R as variant)

		' // me.m_R = R
		 me.m_R.SetM(R)
		' // me.m_position = position + b2Mul(R, me.m_localCentroid)
		 me.m_position.x = position.x + (R.col1.x * me.m_localCentroid.x + R.col2.x * me.m_localCentroid.y)
		 me.m_position.y = position.y + (R.col1.y * me.m_localCentroid.x + R.col2.y * me.m_localCentroid.y)
end

public  sub 	ResetProxy(broadPhase as variant) as variant ''funcion
		if ( me.m_proxyId == b2Pair.b2_nullProxy)
			return
 '' TODO: posible funcion (revisar)

dim 		 proxy  as variant = broadPhase.GetProxy( me.m_proxyId)

		broadPhase.DestroyProxy( me.m_proxyId)
		proxy = null
dim 		 R  as variant = b2Math.b2MulMM( me.m_R, me.m_localOBB.R)

dim 		 absR  as variant = b2Math.b2AbsM(R)

dim 		 h  as variant = b2Math.b2MulMV(absR, me.m_localOBB.extents)

		' // var position = me.m_position + b2Mul( me.m_R, me.m_localOBB.center)
dim 		 position  as variant = b2Math.b2MulMV( me.m_R, me.m_localOBB.center)

		position.Add( me.m_position)
dim 		 aabb  as variant = new b2AABB()

		' // aabb.minVertex = position - h
		aabb.minVertex.SetV(position)
		aabb.minVertex.Subtract(h)
		' // aabb.maxVertex = position + h
		aabb.maxVertex.SetV(position)
		aabb.maxVertex.Add(h)
		if (broadPhase.InRange(aabb))
			 me.m_proxyId = broadPhase.CreateProxy(aabb, this)
		else
			 me.m_proxyId = b2Pair.b2_nullProxy
		if ( me.m_proxyId == b2Pair.b2_nullProxy)
			 me.m_body.Freeze()
end

public  sub 	Support(dX as variant, dY as variant, out as variant) as variant ''funcion
		' // b2Vec2 dLocal = b2MulT( me.m_R, d)
dim 		 dLocalX  as variant = (dX* me.m_R.col1.x + dY* me.m_R.col1.y)

dim 		 dLocalY  as variant = (dX* me.m_R.col2.x + dY* me.m_R.col2.y)

dim 		 bestIndex  as variant = 0

		' // float32 bestValue = b2Dot( me.m_vertices[0], dLocal)
dim 		 bestValue  as variant = ( me.m_coreVertices[0].x * dLocalX + me.m_coreVertices[0].y * dLocalY)

		for (var i = 1; i < me.m_vertexCount; ++i)
			' // float32 value = b2Dot( me.m_vertices[i], dLocal)
dim 			 value  as variant = ( me.m_coreVertices[i].x * dLocalX + me.m_coreVertices[i].y * dLocalY)

			if (value > bestValue)
			
				bestIndex = i
				bestValue = value
			
		' // return me.m_position + b2Mul( me.m_R, me.m_vertices[bestIndex])
 '' TODO: posible funcion (revisar)

		out.Set(	 me.m_position.x + ( me.m_R.col1.x * me.m_coreVertices[bestIndex].x + me.m_R.col2.x * me.m_coreVertices[bestIndex].y)
					 me.m_position.y + ( me.m_R.col1.y * me.m_coreVertices[bestIndex].x + me.m_R.col2.y * me.m_coreVertices[bestIndex].y))
	' //  Local position of the shape centroid in parent body frame.
Public d: new b2Vec2(), as new 2Vec2(),
	' //  Local position oriented bounding box. The OBB center is relative to
	' //  shape centroid.
Public B: new b2OBB(), as new 2OBB(),
	m_vertices: null
	m_coreVertices: null
	m_vertexCount: 0
	m_normals: null)
b2PolyShape.tempVec = new b2Vec2()
b2PolyShape.tAbsR = new b2Mat22()
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2PolyDef  as variant = Class.create()

inherits , b2ShapeDef
inherits 
end

public  sub 	initialize()

		' //  The constructor for b2ShapeDef
		 me.type = b2Shape.e_unknownShape
		 me.userData = null
		 me.localPosition = new b2Vec2(0.0, 0.0)
		 me.localRotation = 0.0
		 me.friction = 0.2
		 me.restitution = 0.0
		 me.density = 0.0
		 me.categoryBits = 0x0001
		 me.maskBits = 0xFFFF
		 me.groupIndex = 0
	
		' // 
		' //  initialize instance variables for references
		 me.vertices = new Array(b2Settings.b2_maxPolyVertices)
		' // 
		 me.type = b2Shape.e_polyShape
		 me.vertexCount = 0
		for (var i = 0; i < b2Settings.b2_maxPolyVertices; i++)
			 me.vertices[i] = new b2Vec2()
Public s: new Array(b2Settings.b2_maxPolyVertices), as new rray(b2Settings.b2_maxPolyVertices),
	vertexCount: 0)
﻿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
dim  b2BoxDef  as variant = Class.create()

inherits , b2ShapeDef
inherits 
end

public  sub 	initialize()

		' //  The constructor for b2ShapeDef
		 me.type = b2Shape.e_unknownShape
		 me.userData = null
		 me.localPosition = new b2Vec2(0.0, 0.0)
		 me.localRotation = 0.0
		 me.friction = 0.2
		 me.restitution = 0.0
		 me.density = 0.0
		 me.categoryBits = 0x0001
		 me.maskBits = 0xFFFF
		 me.groupIndex = 0
	
		' // 
		 me.type = b2Shape.e_boxShape
		 me.extents = new b2Vec2(1.0, 1.0)
	extents: null)