' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 'you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' //  Shapes are created automatically when a body is created.
' //  Client code does not normally interact with shapes.



public 	m_next as variant =null

Public m_R as new 2Mat22()
Public m_position as new b2Vec2()

public 	m_type as integer= 0
public m_userData as variant= null
public 	m_body as variant= null
public 	m_friction as variant= null
public m_restitution as variant= null
public m_maxRadius as variant= null
public m_proxyId as integer= 0
public m_categoryBits as integer= 0
public m_maskBits as integer= 0
public m_groupIndex as integer= 0


public e_unknownShape  as integer= -1
public e_circleShape as integer= 0
public e_boxShape as integer= 1
public e_polyShape as integer= 2
public e_meshShape as integer= 3
public e_shapeTypeCount as integer= 4





public  sub 	TestPoint(p as variant) as variant
	return false 
end

public  sub 	GetUserData() as variant
	return me.m_userData
end

public  sub 	GetType() as variant 
		return me.m_type
end
 

	' //  Get the parent body of this shape.
public  sub 	GetBody() as variant ''funcion
		return me.m_body
end

public  sub 	GetPosition() as variant ''funcion
		return me.m_position
end

public  sub 	GetRotationMatrix() as variant 
		return me.m_R
end


	' //  Remove and then add proxy from the broad-phase.
	' //  This is used to refresh the collision filters.
public  sub 	ResetProxy(broadPhase as variant)
end

	' //  Get the next shape in the parent body's shape list.

public  sub 	GetNext() as variant ''funcion
		return me.m_next
end

	' // --------------- Internals Below -------------------

public  sub _new (def as variant, body as variant)

		' //  initialize instance variables for references
		 me.m_R = new b2Mat22()
		 me.m_position = new b2Vec2()
		' // 
		 me.m_userData = def.userData
		 me.m_friction = def.friction
		 me.m_restitution = def.restitution
		 me.m_body = body
		 me.m_proxyId = b2Pair.b2_nullProxy
		 me.m_maxRadius = 0.0
		 me.m_categoryBits = def.categoryBits
		 me.m_maskBits = def.maskBits
		 me.m_groupIndex = def.groupIndex
end
	' //  Internal use only. Do not call.
	' // b2Shape::~b2Shape()
	' // 
	' // 	 me.m_body->m_world->m_broadPhase-> me.DestroyProxy( me.m_proxyId)
	' // 


public  sub 	DestroyProxy()
		if ( me.m_proxyId != b2Pair.b2_nullProxy) then 
			 me.m_body.m_world.m_broadPhase.DestroyProxy( me.m_proxyId)
			 me.m_proxyId = b2Pair.b2_nullProxy
		 endif
end

	' //  Internal use only. Do not call.
public  sub 	Synchronize(position1 as variant, R1 as variant, position2 as variant, R2 as variant)

end

public  sub 	QuickSync(position as variant, R as variant)

end

public  sub 	Support(dX as variant, dY as variant, out as variant)

end

public  sub 	GetMaxRadius() as variant ''funcion
		return me.m_maxRadius
end



public  sub Create(def as variant, body as variant, center as variant) as variant 
	select case def.type
		case b2Shape.e_circleShape
			' // void* mem = body->m_world->m_blockAllocator.Allocate(sizeof(b2CircleShape))
				return new b2CircleShape(def, body, center)
 		case b2Shape.e_boxShape
		case b2Shape.e_polyShape
					' // void* mem = body->m_world->m_blockAllocator.Allocate(sizeof(b2PolyShape))
				return new b2PolyShape(def, body, center)
 	end select
			
		' // b2Settings.b2Assert(false)
		return null
 end

public  sub Destroy (shape as variant)
	' //  FROM DESTRUCTOR
		if (shape.m_proxyId != b2Pair.b2_nullProxy) then 
			shape.m_body.m_world.m_broadPhase.DestroyProxy(shape.m_proxyId)
		endif
end



public  sub PolyMass (massData as variant, vs as variant, count as variant, rho as variant)

		' // b2Settings.b2Assert(count >= 3)
		' // var center = new b2Vec2(0.0, 0.0)
dim center  as new b2Vec2()
dim area  as variant = 0.0

dim I  as variant = 0.0

		' //  pRef is the reference point for forming triangles.
		' //  It's location doesn't change the result (except for rounding error).
dim pRef  as new b2Vec2(0.0, 0.0)

dim inv3  as variant = 1.0 / 3.0

dim i as integer

dim 	p1  as variant
dim 	p2  as variant 
dim 	p3  as variant 
dim 	e1  as variant
dim 	e2  as variant
dim 	D  as variant
dim 	triangleArea  as variant
dim 	tVec  as variant


dim 	px  as variant
dim 	py  as variant
dim 	ex1  as varian
dim 	ey1  as varian
dim 	ex2  as varian
dim 	ey2  as varian
dim 	intx2  as variant
dim 	inty2  as variant


		center.SetZero()

		for i = 0 to count
			' //  Triangle vertices.
			p1   = pRef
		
			p2   = vs[i]
		
			p3   = if( i + 1 < count, vs[i+1], vs[0])
		
			e1   = b2Math.SubtractVV(p2, p1)
		
			e2   = b2Math.SubtractVV(p3, p1)
		
			D   = b2Math.b2CrossVV(e1, e2)
		
			triangleArea   = 0.5 * D

			area += triangleArea
			' //  Area weighted centroid
			' //  center += triangleArea * inv3 * (p1 + p2 + p3)
 			tVec   = new b2Vec2()

			tVec.SetV(p1)
			tVec.Add(p2)
			tVec.Add(p3)
			tVec.Multiply(inv3*triangleArea)
			center.Add(tVec)
			px  = p1.x

			py  = p1.y

			ex1  = e1.x

			ey1  = e1.y

			ex2  = e2.x

			ey2  = e2.y

			intx2  = inv3 * (0.25 * (ex1*ex1 + ex2*ex1 + ex2*ex2) + (px*ex1 + px*ex2)) + 0.5*px*px

			inty2  = inv3 * (0.25 * (ey1*ey1 + ey2*ey1 + ey2*ey2) + (py*ey1 + py*ey2)) + 0.5*py*py

			I += D * (intx2 + inty2)
		next
		
		' //  Total mass
		massData.mass = rho * area
		' //  Center of mass
		' // b2Settings.b2Assert(area > Number.MIN_VALUE)
		center.Multiply( 1.0 / area )
		massData.center = center
		' //  Inertia tensor relative to the center.
		I = rho * (I - area * b2Math.b2Dot(center, center))
		massData.I = I
end


public  sub PolyCentroid (vs as variant, count as variant, out as variant) as variant ''funcio as variant ''funcion
		' // b2Settings.b2Assert(count >= 3)
		' // b2Vec2 c;c.Set(0.0f, 0.0f)

dim cX  as float= 0.0

dim cY  as float= 0.0

		' // float32 area = 0.0f
dim area  as float= 0.0

		' //  pRef is the reference point for forming triangles.
		' //  It's location doesn't change the result (except for rounding error).
		' // b2Vec2 pRef(0.0f, 0.0f)
dim pRefX  as float= 0.0

dim pRefY  as float= 0.0


		' // const float32 inv3 = 1.0f / 3.0f
dim inv3  as variant = 1.0 / 3.0


dim 	p1X  as variant

dim 	p1Y  as variant 

			' // b2Vec2 p2 = vs[i]
dim 	p2X  as variant 

dim 	p2Y  as variant 

			' // b2Vec2 p3 = i + 1 < count ? vs[i+1] : vs[0]
dim 	p3X  as variant

dim 	p3Y  as variant 

			' // b2Vec2 e1 = p2 - p1
dim 	e1X  as variant

dim 	e1Y  as variant 

			' // b2Vec2 e2 = p3 - p1
dim 	e2X  as variant 

dim 	e2Y  as variant 

			' // float32 D = b2Cross(e1, e2)
dim 	D  as variant 

			' // float32 triangleArea = 0.5f * D
dim 	triangleArea   as variant

dim i as variant




		for  i = 0 to  count
			' //  Triangle vertices.
			' // b2Vec2 p1 = pRef
			p1X  = pRefX

			p1Y  = pRefY

			' // b2Vec2 p2 = vs[i]
			p2X  = vs[i].x

			p2Y  = vs[i].y

			' // b2Vec2 p3 = i + 1 < count ? vs[i+1] : vs[0]
			p3X  =if( i + 1 < count, vs[i+1].x, vs[0].x)

			p3Y  =if( i + 1 < count, vs[i+1].y , vs[0].y)

			' // b2Vec2 e1 = p2 - p1
			e1X  = p2X - p1X

			e1Y  = p2Y - p1Y

			' // b2Vec2 e2 = p3 - p1
			e2X  = p3X - p1X

			e2Y  = p3Y - p1Y

			' // float32 D = b2Cross(e1, e2)
			D  = (e1X * e2Y - e1Y * e2X)

			' // float32 triangleArea = 0.5f * D
			triangleArea  = 0.5 * D

			area += triangleArea
			' //  Area weighted centroid
			' // c += triangleArea * inv3 * (p1 + p2 + p3)
			cX += triangleArea * inv3 * (p1X + p2X + p3X)
			cY += triangleArea * inv3 * (p1Y + p2Y + p3Y)
		next
		
		' //  Centroid
		' // b2Settings.b2Assert(area > Number.MIN_VALUE)
		cX *= 1.0 / area
		cY *= 1.0 / area


		out.Set(cX, cY)

end
	