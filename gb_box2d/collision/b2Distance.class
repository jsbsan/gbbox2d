' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
 'you must not  
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
 
	' //  GJK using Voronoi regions (Christer Ericson) and region selection
	' //  optimizations (Casey Muratori).
	' //  The origin is either in the region of points[1] or in the edge region. The origin is
	' //  not in region of points[0] because that is the old point.
	' //  Possible regions:
	' //  - points[2]
	' //  - edge points[0]-points[2]
	' //  - edge points[1]-points[2]
	' //  - inside the triangle

 public g_GJK_Iterations as integer = 0


public  sub ProcessTwo (p1Out as variant, p2Out as variant, p1s as variant, p2s as variant, points as variant) as integer ''funcio as variant ''funcion
		' //  If in point[1] region
		' // b2Vec2 r = -points[1]
dim 		 rX  as variant = -points[1].x

dim 		 rY  as variant = -points[1].y

		' // b2Vec2 d = points[1] - points[0]
dim 		 dX  as variant = points[0].x - points[1].x

dim 		 dY  as variant = points[0].y - points[1].y

		' // float32 length = d.Normalize()
dim 		 length  as variant = Math.sqrt(dX*dX + dY*dY)
dim 		 lambda  as variant

		dX /= length
		dY /= length
		' // float32 lambda = b2Dot(r, d)
		 lambda = rX * dX + rY * dY

		if (lambda <= 0.0 and length < Number.MIN_VALUE) then 
			' //  The simplex is reduced to a point.
			' // *p1Out = p1s[1]
			p1Out.SetV(p1s[1])
			' // *p2Out = p2s[1]
			p2Out.SetV(p2s[1])
			' // p1s[0] = p1s[1]
			p1s[0].SetV(p1s[1])
			' // p2s[0] = p2s[1]
			p2s[0].SetV(p2s[1])
			points[0].SetV(points[1])
			return 1
		endif 
 
		' //  Else in edge region
		lambda /= length
		' // *p1Out = p1s[1] + lambda * (p1s[0] - p1s[1])
		p1Out.x = p1s[1].x + lambda * (p1s[0].x - p1s[1].x)
		p1Out.y = p1s[1].y + lambda * (p1s[0].y - p1s[1].y)
		' // *p2Out = p2s[1] + lambda * (p2s[0] - p2s[1])
		p2Out.x = p2s[1].x + lambda * (p2s[0].x - p2s[1].x)
		p2Out.y = p2s[1].y + lambda * (p2s[0].y - p2s[1].y)
		return 2


end

public  sub ProcessThree (p1Out as variant, p2Out as variant, p1s as variant, p2s as variant, points as variant) as integer ''funcio as variant ''funcio as variant ''funcio as variant ''funcion
		' // b2Vec2 a = points[0]
dim 		 aX  as variant = points[0].x

dim 		 aY  as variant = points[0].y

		' // b2Vec2 b = points[1]
dim 		 bX  as variant = points[1].x

dim 		 bY  as variant = points[1].y

		' // b2Vec2 c = points[2]
dim 		 cX  as variant = points[2].x

dim 		 cY  as variant = points[2].y

		' // b2Vec2 ab = b - a
dim 		 abX  as variant = bX - aX

dim 		 abY  as variant = bY - aY

		' // b2Vec2 ac = c - a
dim 		 acX  as variant = cX - aX

dim 		 acY  as variant = cY - aY

		' // b2Vec2 bc = c - b
dim 		 bcX  as variant = cX - bX

dim 		 bcY  as variant = cY - bY

		' // float32 sn = -b2Dot(a, ab), sd = b2Dot(b, ab)
dim 		 sn  as variant = -(aX * abX + aY * abY)

dim 		 sd  as variant = (bX * abX + bY * abY)

		' // float32 tn = -b2Dot(a, ac), td = b2Dot(c, ac)
dim 		 tn  as variant = -(aX * acX + aY * acY)

dim 		 td  as variant = (cX * acX + cY * acY)

		' // float32 un = -b2Dot(b, bc), ud = b2Dot(c, bc)
dim 		 un  as variant = -(bX * bcX + bY * bcY)

dim 		 ud  as variant = (cX * bcX + cY * bcY)


dim 		 n  as variant
dim 		 vc  as variant 
dim 		 vc  as variant 
dim 			 lambda  as variant 
dim 		 vb  as variant

dim 		 denom  as variant 
dim 		 u  as variant
dim 		 v  as variant
dim 		 w  as variant

		' //  In vertex c region?
		if (td <= 0.0 and ud <= 0.0) then 
			' //  Single point
			' // *p1Out = p1s[2]
			p1Out.SetV(p1s[2])
			' // *p2Out = p2s[2]
			p2Out.SetV(p2s[2])
			' // p1s[0] = p1s[2]
			p1s[0].SetV(p1s[2])
			' // p2s[0] = p2s[2]
			p2s[0].SetV(p2s[2])
			points[0].SetV(points[2])
			return 1
		endif
			

		' //  Should not be in vertex a or b region.
		' // b2Settings.b2Assert(sn > 0.0 || tn > 0.0)
		' // b2Settings.b2Assert(sd > 0.0 || un > 0.0)
		' // float32 n = b2Cross(ab, ac)
 		 n  = abX * acY - abY * acX

		' //  Should not be in edge ab region.
		' // float32 vc = n * b2Cross(a, b)
 		 vc  = n * (aX * bY - aY * bX)

		' // b2Settings.b2Assert(vc > 0.0 || sn > 0.0 || sd > 0.0)
		' //  In edge bc region?
		' // float32 va = n * b2Cross(b, c)
 		 vc  = n * (bX * cY - bY * cX)

		if (va <= 0.0 && un >= 0.0 && ud >= 0.0)
			' // b2Settings.b2Assert(un + ud > 0.0)
			' // float32 lambda = un / (un + ud)
 			 lambda  = un / (un + ud)

			' // *p1Out = p1s[1] + lambda * (p1s[2] - p1s[1])
			p1Out.x = p1s[1].x + lambda * (p1s[2].x - p1s[1].x)
			p1Out.y = p1s[1].y + lambda * (p1s[2].y - p1s[1].y)
			' // *p2Out = p2s[1] + lambda * (p2s[2] - p2s[1])
			p2Out.x = p2s[1].x + lambda * (p2s[2].x - p2s[1].x)
			p2Out.y = p2s[1].y + lambda * (p2s[2].y - p2s[1].y)
			' // p1s[0] = p1s[2]
			p1s[0].SetV(p1s[2])
			' // p2s[0] = p2s[2]
			p2s[0].SetV(p2s[2])
			' // points[0] = points[2]
			points[0].SetV(points[2])
			return 2
endif
		' //  In edge ac region?
		' // float32 vb = n * b2Cross(c, a)
 		 vb  = n * (cX * aY - cY * aX)

		if (vb <= 0.0 and tn >= 0.0 and td >= 0.0)
			' // b2Settings.b2Assert(tn + td > 0.0)
			' // float32 lambda = tn / (tn + td)
 			 lambda  = tn / (tn + td)

			' // *p1Out = p1s[0] + lambda * (p1s[2] - p1s[0])
			p1Out.x = p1s[0].x + lambda * (p1s[2].x - p1s[0].x)
			p1Out.y = p1s[0].y + lambda * (p1s[2].y - p1s[0].y)
			' // *p2Out = p2s[0] + lambda * (p2s[2] - p2s[0])
			p2Out.x = p2s[0].x + lambda * (p2s[2].x - p2s[0].x)
			p2Out.y = p2s[0].y + lambda * (p2s[2].y - p2s[0].y)
			' // p1s[1] = p1s[2]
			p1s[1].SetV(p1s[2])
			' // p2s[1] = p2s[2]
			p2s[1].SetV(p2s[2])
			' // points[1] = points[2]
			points[1].SetV(points[2])
			return 2
	endif
	
 '' TODO: posible funcion (revisar)

		' //  Inside the triangle, compute barycentric coordinates
		' // float32 denom = va + vb + vc
 		 denom  = va + vb + vc

		' // b2Settings.b2Assert(denom > 0.0)
		denom = 1.0 / denom
		' // float32 u = va * denom
 		 u  = va * denom

		' // float32 v = vb * denom
 		 v  = vb * denom

		' // float32 w = 1.0f - u - v
 		 w  = 1.0 - u - v

		' // *p1Out = u * p1s[0] + v * p1s[1] + w * p1s[2]
		p1Out.x = u * p1s[0].x + v * p1s[1].x + w * p1s[2].x
		p1Out.y = u * p1s[0].y + v * p1s[1].y + w * p1s[2].y
		' // *p2Out = u * p2s[0] + v * p2s[1] + w * p2s[2]
		p2Out.x = u * p2s[0].x + v * p2s[1].x + w * p2s[2].x
		p2Out.y = u * p2s[0].y + v * p2s[1].y + w * p2s[2].y
		return 3
	endif

end

public  sub InPoinsts (w as variant, points as variant, pointCount as variant) as boolean ''funcio as variant ''funcion
	dim i as integer
	
		for  i = 0 to  pointCount
			if (w.x = points[i].x and w.y = points[i].y) then 
				return true
 			endif
 		next

		return false

end

public  sub Distance (p1Out as variant, p2Out as variant, shape1 as variant, shape2 as variant) as variant ''funcio as variant ''funcio as variant ''funcio as variant ''funcion
		' // b2Vec2 p1s[3], p2s[3]
dim 		 p1s  as new variant = [null,null,null]

dim 		 p2s  as new variant =  [null,null,null]

		' // b2Vec2 points[3]
dim 		 points  as new variant =   [null,null,null]

		' // int32 pointCount = 0
dim 		 pointCount  as variant = 0

		
dim 		 vSqr  as variant = 0.0

dim 		 maxIterations  as variant = 20

dim iter as integer



dim 			 vX  as variant 
dim 			 vY  as variant
dim 			 w1  as variant
dim 			 w2  as variant 
dim 			 wX  as variant
dim 			 wY  as variant 
dim 			 vw  as variant 
dim 			 maxSqr  as variant

dim i as integer
' // *p1Out = shape1->m_position
		p1Out.SetV(shape1.m_position)
		' // *p2Out = shape2->m_position
		p2Out.SetV(shape2.m_position)
		
		for iter = 0 to maxIterations
			' // b2Vec2 v = *p2Out - *p1Out
 			 vX   = p2Out.x - p1Out.x

 			 vY   = p2Out.y - p1Out.y

			' // b2Vec2 w1 = shape1->Support(v)
 			 w1   = shape1.Support(vX, vY)

			' // b2Vec2 w2 = shape2->Support(-v)
 			 w2   = shape2.Support(-vX, -vY)

			' // float32 vSqr = b2Dot(v, v)
			vSqr = (vX*vX + vY*vY)
			' // b2Vec2 w = w2 - w1
 			 wX   = w2.x - w1.x

 			 wY   = w2.y - w1.y

			' // float32 vw = b2Dot(v, w)
 			 vw   = (vX*wX + vY*wY)




			' // if (vSqr - b2Dot(v, w) <= 0.01f * vSqr)
			if (vSqr - b2Dot(vX * wX + vY * wY) <= 0.01 * vSqr)
			
				if (pointCount = 0) then 
				
					' // *p1Out = w1
					p1Out.SetV(w1)
					' // *p2Out = w2
					p2Out.SetV(w2)
				endif
				b2Distance.g_GJK_Iterations = iter
				return Math.sqrt(vSqr)
			endif

			
			select case pointCount
			case 0
				' // p1s[0] = w1
				p1s[0].SetV(w1)
				' // p2s[0] = w2
				p2s[0].SetV(w2)
				points[0] = w
				' // *p1Out = p1s[0]
				p1Out.SetV(p1s[0])
				' // *p2Out = p2s[0]
				p2Out.SetV(p2s[0])
				++pointCount
				break
			case 1
				' // p1s[1] = w1
				p1s[1].SetV(w1)
				' // p2s[1] = w2
				p2s[1].SetV(w2)
				' // points[1] = w
				points[1].x = wX
				points[1].y = wY
				pointCount = b2Distance.ProcessTwo(p1Out, p2Out, p1s, p2s, points)
				break
			case 2
				' // p1s[2] = w1
				p1s[2].SetV(w1)
				' // p2s[2] = w2
				p2s[2].SetV(w2)
				' // points[2] = w
				points[2].x = wX
				points[2].y = wY
				pointCount = b2Distance.ProcessThree(p1Out, p2Out, p1s, p2s, points)
				break
			end select
			' //  If we have three points, then the origin is in the corresponding triangle.
			if (pointCount = 3) then 
						me.g_GJK_Iterations = iter
				return 0.0
			endif

			
			' // float32 maxSqr = -FLT_MAX
 			 maxSqr   = -Number.MAX_VALUE

			for  i = 0 to pointCount
			
				' // maxSqr = b2Math.b2Max(maxSqr, b2Dot(points[i], points[i]))
				maxSqr = b2Math.b2Max(maxSqr, (points[i].x*points[i].x + points[i].y*points[i].y))
			next
			
			if (pointCount = 3 or vSqr <= 100.0 * Number.MIN_VALUE * maxSqr) then 
				me.g_GJK_Iterations = iter
				return Math.sqrt(vSqr)
 			endif

		next
		
		me.g_GJK_Iterations = maxIterations
		return sqrt(vSqr)
end
