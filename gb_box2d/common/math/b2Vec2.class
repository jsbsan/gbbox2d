'gambas class'
'b2Vec2'

ï»¿' /* 
' * Copyright (c) 2006-2007 Erin Catto http:
' *
' * This software is provided 'as-is', without any express or implied
' * warranty.  In no event will the authors be held liable for any damages
' * arising from the use of this software.
' * Permission is granted to anyone to use this software for any purpose
' * including commercial applications, and to alter it and redistribute it
' * freely, subject to the following restrictions:
' * 1. The origin of this software must not be misrepresented
' you must not
' * claim that you wrote the original software. If you use this software
' * in a product, an acknowledgment in the product documentation would be
' * appreciated but is not required.
' * 2. Altered source versions must be plainly marked, and must not be
' * misrepresented the original software.
' * 3. This notice may not be removed or altered from any source distribution.
' */
' b2Vec2 has no constructor so that it
' can be placed in a union.



public x as float
public y as float

public sub _new(x as flot, y as float)
	me.initialize(x,y)
end


public sub initialize(x as float, y as float )
	me.x=x
	me.y=y
end

public sub SetZero()
	me.x=0
	me.y=0
end

public sub Set(x as float, y as float )
	me.x=x
	me.y=y
end

public sub SetV(v as b2Vec2)
	me.x=v.x
	me.y=v.y
end

public function Negative() as b2Vec2
	return new b2Vec2(-me.x,-me.y)
end

public function copy() as b2Vec2
 	return new b2Vec2(me.x,me.y)
end


public sub add(v as b2Vec2)
   	me.x += v.x
    me.y += v.y
end

public sub Subtract(v as b2Vec2)
   	me.x -= v.x
    me.y -= v.y
end

public sub Multiply(a as float)
   	me.x *= a
    me.y *= a
end

public sub MulM(A as variant)
	dim tx as float
 	tX = me.x
	me.x = A.col1.x * tX + A.col2.x * me.y
	me.y = A.col1.y * tX + A.col2.y * me.y
end


public sub MulTM(A as variant)
	dim tx as float
 	tX = b2Math.b2Dot(me, A.col1)
	me.y = b2Math.b2Dot(me, A.col2)
	me.x = tX
end


public sub CrossVF(s as float)
	dim tx as float
	tX = me.x
	me.x = s * me.y
	me.y = -s * tX
end



public sub CrossFV(s as float)
	dim tx as float
	tX = me.x
	me.x = -s * me.y
	me.y = s * tX
end

public sub MinV(b as variant)
	me.x=min(me.x,b.x)
	me.y=min(me.y,b.y)
end

public sub MaxV(b as variant)
	me.x=max(me.x,b.x)
	me.y=max(me.y,b.y)
end

public sub Abs()
	me.x=abs(me.x)
	me.y=abs(me.y)
end

public function length() as float
	return sqrt(me.x*me.x+me.y*me.y)
end

public function Normalize() as float
		dim  length as float = me.Length()
		dim invLength as float

		if (length <  -8.98846567431105E+307 ) then 
			return 0.0
		endif

		invLength = 1.0 / length
		
		me.x *= invLength
		me.y *= invLength
		return length
end

public function Isvalid() as variant
	return (b2Math.b2IsValid(me.x) and b2Math.b2IsValid(me.y)
end



public function make(x as variant, y as variant) as variant
	return new b2vec2(x,y)
end


